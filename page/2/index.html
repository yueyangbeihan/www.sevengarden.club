<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="seven 的精神家园，学习笔记">
<meta name="keywords" content="云计算,大数据，kuberntes">
<meta property="og:type" content="website">
<meta property="og:title" content="岳阳北寒">
<meta property="og:url" content="http://sevengarden.club/page/2/index.html">
<meta property="og:site_name" content="岳阳北寒">
<meta property="og:description" content="seven 的精神家园，学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="岳阳北寒">
<meta name="twitter:description" content="seven 的精神家园，学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sevengarden.club/page/2/"/>





  <title>岳阳北寒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">岳阳北寒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">要有最朴素的生活和最遥远的梦想，即使明日天寒地冻，路远马亡.......</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-somrthing">
          <a href="/有料" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            somrthing
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/20/AWS-High-Availability-Fault-Tolerance-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/AWS-High-Availability-Fault-Tolerance-Architecture/" itemprop="url">AWS High Availability & Fault Tolerance Architecture</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T17:30:32+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>前言：AWS提供众多服务和基础架构能力，以在云中构建可靠，容错且高度可用的系统。一下为AWS的定义范围和解释</li>
</ul>
<ul>
<li>Fault Tolerance定义了构建系统的某些组件发生故障时，系统仍能保持运行的能力</li>
<li>大多数高级服务（如S3，RDS，SQS和ELB）都考虑了容错和高可用性（<font size="3" color="orange">自设计冗余性和高可用</font>）</li>
<li>提供基本基础架构（如EC2和EBS）的服务提供特定功能，例如可用区，弹性IP地址和快照，系统需要正确利用和使用这些功能才能达到容错和高可用性（<strong><font color="red">需要借助AWS基础架构实现高可用性和容错性</font></strong>）</li>
</ul>
<p><img src="https://i.loli.net/2019/08/20/UKcMhzL8VOBtHmD.png" alt="AWS-High-Availability-and-Fault-Tolerance.png"></p>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h3><ul>
<li>高可用性是指提供在本地系统单个组件故障情况下，能继续访问应用的能力，无论这个故障是业务流程、物理设施、IT软/硬件的故障。</li>
<li>主要用于确保关键系统始终正常运行，如核心业务系统、数据库场景。</li>
<li>（RPO=0，共享存储的情况下，RTO分钟级）</li>
<li>一般使用通过运行时间百分比表示其可用性，5 个9：99.999%年可用率，意味着每年停机时间在一到两分钟</li>
</ul>
<h3 id="FT"><a href="#FT" class="headerlink" title="FT"></a>FT</h3><ul>
<li>设计方式时当一个组件发生故障（无论是硬件还是软件）时，备份组件立即接管操作，从而不会丢失服务</li>
<li>容错是高可用性的更严格版本。 HA专注于提供尽可能少的停机时间，而FT则通过实现零停机而进一步提升， 但是，在容错模型中，系统在发生故障时提供高性能的能力不是首要任务，相反，预计系统可以保持运行性能，甚至降低水平</li>
<li>（ 设计目标RTO =0 &amp;&amp; RPO = 0）</li>
</ul>
<h3 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h3><ul>
<li><p>灾难恢复涉及<font color="red">一系列政策，工具和程序</font>，以便在自然灾害或人为灾难之后恢复或延续重要技术基础设施和系统。</p>
</li>
<li><p>DR需要具有异地设施，可以在其中恢复关键数据和工作负载（无论是完全还是部分），以便在发生破坏性事件后恢复足够的业务运营。要将工作负载转移到远程位置，必须采用适当的灾难恢复解决方案</p>
</li>
<li><p>灾难恢复是一个更广泛，更复杂的概念，它指的是一套具有全面组件的战略，包括：风险评估，规划，依赖关系分析，远程站点配置，员工培训，测试，自动化设置等等。灾难恢复超越了<font color="red">HA和FT</font>，但可以而且应该将这些因素包括在其技术设计中。</p>
</li>
<li><p>由于DR场景已经跨单数据中心，基本上RPO可小时级，RTO小时级到天级别</p>
</li>
<li><p>相比HA、FT，DR强调发生灾难后处理，而不是应急或预防，而是减弱灾难带来的影响。DR处理的不是单个组件的故障情况，而是DC级别的故障，应对人力不可控的风险。</p>
</li>
<li><p>在场景上一般都是有着严格行业监管要求的，如金融、医疗等</p>
</li>
<li><p>容灾通常意义上分为<font color="red"><strong>三个级别（数据、应用、业务</strong></font>，国际上专业划分为7个层次）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>级别</th>
<th>定义</th>
<th>RTO</th>
<th>RTO</th>
</tr>
</thead>
<tbody><tr>
<td>数据级</td>
<td>指通过建立异地容灾中心，做数据的远程备份，在灾难发生之后要确保原有的数据不会丢失或者遭到破坏。但在数据级容灾这个级别，发生灾难时应用是会中断的。在数据级容灾方式下，所建立的异地容灾中心可以简单地把它理解成一个远程的数据备份中心。数据级容灾的恢复时间比较长，但是相比其他容灾级别来讲它的费用比较低，而且构建实施也相对简单。但是，“数据源是一切关键性业务系统的生命源泉”，因此数据级容灾必不可少。</td>
<td>RTO 最长(若干天) ，因为灾难发生时，需要重新部署机器，利用备份数据恢复业务。</td>
<td>最低</td>
</tr>
<tr>
<td>应用级</td>
<td>在数据级容灾的基础之上，在备份站点同样构建一套相同的应用系统，通过同步或异步复制技术，这样可以保证关键应用在允许的时间范围内恢复运行，尽可能减少灾难带来的损失，让用户基本感受不到灾难的发生，这样就使系统所提供的服务是完整的、可靠的和安全的。</td>
<td>RTO 中等（若干小时）</td>
<td>中等。异地可以搭建一样的系统，或者小些的系统。</td>
</tr>
<tr>
<td>业务级</td>
<td>全业务的灾备，除了必要的 IT 相关技术，还要求具备全部的基础设施。其大部分内容是非IT系统（如电话、办公地点等），当大灾难发生后，原有的办公场所都会受到破坏，除了数据和应用的恢复，更需要一个备份的工作场所能够正常的开展业务。</td>
<td>RTO 最小（若干分钟或者秒）</td>
<td>最高</td>
</tr>
</tbody></table>
<ul>
<li><strong>RTO （Recovery Time Objective）和 RPO（Recovery Point Objective）</strong></li>
</ul>
<p><img src="https://i.loli.net/2019/08/20/o7k6O5vtfeIEcUP.png" alt="002.png"></p>
<h3 id="HA与DR关系"><a href="#HA与DR关系" class="headerlink" title="HA与DR关系"></a>HA与DR关系</h3><h4 id="两者相互关联，互相补充，互有交叉，同时又有显著的区别："><a href="#两者相互关联，互相补充，互有交叉，同时又有显著的区别：" class="headerlink" title="两者相互关联，互相补充，互有交叉，同时又有显著的区别："></a>两者相互关联，互相补充，互有交叉，同时又有显著的区别：</h4><ul>
<li>HA 往往指本地的高可用系统，表示在多个服务器运行一个或多种应用的情况下，应确保任意服务器出现任何故障时，其运行的应用不能中断，应用程序和系统应能迅速切换到其它服务器上运行，即本地系统集群和热备份。HA 往往是用共享存储，因此往往不会有数据丢失（RPO = 0），更多的是切换时间长度考虑即 RTO。</li>
<li>DR 是指异地（同城或者异地）的高可用系统，表示在灾害发生时，数据、应用以及业务的恢复能力。异地灾备的数据灾备部分是使用数据复制，根据使用的不同数据复制技术（同步、异步、Strectched Cluster 等），数据往往有损失导致 RPO &gt;0；而异地的应用切换往往需要更长的时间，这样 RT0 &gt;0。 因此，需要结合特定的业务需求，来定制所需要的 RTO 和 RPO，以实现最优的 CTO。</li>
</ul>
<h4 id="也可以从别的角度上看待两者的区别："><a href="#也可以从别的角度上看待两者的区别：" class="headerlink" title="也可以从别的角度上看待两者的区别："></a>也可以从别的角度上看待两者的区别：</h4><ul>
<li>从故障角度，HA 主要处理单组件的故障导致负载在集群内的服务器之间的切换，DR 则是应对大规模的故障导致负载在数据中心之间做切换。</li>
<li>从网络角度，LAN 尺度的任务是 HA 的范畴，WAN 尺度的任务是 DR 的范围。</li>
<li>从云的角度看，HA 是一个云环境内保障业务持续性的机制，DR 是多个云环境间保障业务持续性的机制。</li>
<li>从目标角度，HA 主要是保证业务高可用，DR 是保证数据可靠的基础上的业务可用<br>当前的国内IT对于这两个技术术语有着太多差异化的理解。从个人角度来讲<font color="red" size="5"><strong>容灾更强调业务级，而HA更强调数据的高可用，独立应用的可用性。</strong></font></li>
</ul>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://i.loli.net/2019/08/20/eBGgKt6F527nRLf.jpg" alt="HA&amp;DR (2).jpeg"></p>
<h2 id="Regions-amp-Availability-Zones"><a href="#Regions-amp-Availability-Zones" class="headerlink" title="Regions &amp; Availability Zones"></a>Regions &amp; Availability Zones</h2><ul>
<li>AWS提供多Region基础架构，并且在一个内具有多个可用区域（AZs），t提供更简易的可以轻松访问冗余部署位置。</li>
<li>AZ分布在不同的地理位置，其设计与其他AZ物理故障隔离</li>
<li>区域和AZ在地理上分布应用程序并帮助构建多站点解决方案来帮助实现更高的容错能力</li>
<li>AZ之间提供低成本，低延迟的网络连接</li>
<li>将EC2实例放置在多个AZ中，可以保护应用程序免于在单个数据中心发生故障</li>
<li>在同一区域或另一个区域中的多个AZ中运行独立的应用程序堆栈非常重要，这样，如果一个区域出现故障，另一个区域中的应用程序可以继续运行</li>
</ul>
<h2 id="Amazon-Machine-Image-–-AMIs"><a href="#Amazon-Machine-Image-–-AMIs" class="headerlink" title="Amazon Machine Image – AMIs"></a>Amazon Machine Image – AMIs</h2><ul>
<li>EC2是AWS中提供计算资源的服务</li>
<li>Amazon机器映像（AMI）提供了可用于定义服务实例的模板</li>
<li>模板包含软件配置（OS，应用服务和应用程序）并通过实例类型提供服务</li>
<li>AMI可以包含所有软件、应用程序和内置代码，也可以配置为具有启动时安装的引导脚本</li>
<li>单一的AMI可用于创建不同的实例类型的服务器，用于创建新实例或更换故障实例</li>
</ul>
<h2 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h2><ul>
<li>Auto Scaling可根据自定义的规则自动扩展或缩小EC2</li>
<li>AS除了在响应增大时，增加多个实例; 当不再需要这些实例时，它们将自动终止</li>
<li>AS可以根据需要终止服务器实例，他们将自动启动替换实例</li>
<li>AS可以在AWS Region范围内跨AZ部署</li>
</ul>
<h2 id="Elastic-Load-Balancing-–-ELB"><a href="#Elastic-Load-Balancing-–-ELB" class="headerlink" title="Elastic Load Balancing – ELB"></a>Elastic Load Balancing – ELB</h2><ul>
<li>ELB 在单个可用区或多个可用区内的多个目标（Amazon EC2 实例、容器和 IP 地址）之间自动分配流量</li>
<li>随着创建ELB，会产生一个DNS域名，发送到这个域名的任何请求都会被转发到后端处理实例上</li>
<li>ELB支持主机上的运行状况检查，在跨多个可用区域的EC2实例的流量分配，根据健康状态检查动态添加和删除EC2主机</li>
<li>ELB 可以检测无法正常运行的目标、停止向它们发送流量，然后将负载分散到剩余的正常运行的目标上，直至使用AS组无缝地恢复不健康的实例</li>
<li>AS和ELB是一个理想的组合——ELB为请求提供对外DNS访问域名，ELB自动确保始终有正确数量的健康EC2实例来接受请求处理</li>
<li>ELB可用于在一个区域的多个AZs中的多个实例之间进行平衡（<font color="red">跨AZ多实例</font>）</li>
</ul>
<h2 id="Elastic-IPs-–-EIP"><a href="#Elastic-IPs-–-EIP" class="headerlink" title="Elastic IPs – EIP"></a>Elastic IPs – EIP</h2><ul>
<li>弹性IP地址是公共静态IP地址，仅在所属区域内的实现地址于实例之间映射</li>
<li>EIP与AWS账户绑定，而不是与实例关联</li>
<li>弹性IP地址可用于固定终端服务的需求，例如，主数据库，文件服务器和EC2托管负载平衡器</li>
<li>可以通过快速将地址重新映射到另一个正在运行的实例或刚刚启动的替换实例，弹性IP地址可用于解决主机或可用区故障（EIP与实例解耦）</li>
</ul>
<h2 id="Reserved-Instance"><a href="#Reserved-Instance" class="headerlink" title="Reserved Instance"></a>Reserved Instance</h2><ul>
<li>预留实例有助于保留并保证计算始终以较低的成本提供</li>
</ul>
<h2 id="Elastic-Block-Store-–-EBS"><a href="#Elastic-Block-Store-–-EBS" class="headerlink" title="Elastic Block Store – EBS"></a>Elastic Block Store – EBS</h2><ul>
<li>弹性块存储（EBS）提供持久的实例存储卷，这些存储卷独立于实例的生命周期而存在，并且比实例存储大多个数量级</li>
<li>EBS卷以冗余方式存储数据，并在单个可用区内自动复制</li>
<li>在故障转移场景，如果EC2实例发生故障并需要更换，则EBS卷可以附加到新的EC2实例</li>
<li>有价值的数据不应该对实例（临时）存储上当没有没有适当的备份，复制或重新创建数据的能力的时候</li>
</ul>
<h2 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h2><ul>
<li>EBS卷是高度可靠的，为了进一步减轻故障的可能性并提高数据可靠性性，基于时间点的快照可以存储在S3中，然后将其复制到多个AZ</li>
<li>快照可用于创建新的EBS卷，这些卷是快照时原始卷的精确副本</li>
<li>快照提供了一种有效的方法来处理磁盘故障、主机、AZ的故障问题</li>
<li>快照是增量备份，仅备份自上一个快照以来的更改，因此建议保留最近的快照</li>
<li><font color="red">快照属于region范围内，而EBS卷属于AZ范围内</font></li>
</ul>
<h2 id="Relational-Database-Service-–-RDS"><a href="#Relational-Database-Service-–-RDS" class="headerlink" title="Relational Database Service – RDS"></a>Relational Database Service – RDS</h2><ul>
<li>RDS是在云上交付的一种数据库服务，并使数据库服务使用变得更加简单</li>
<li>RDS Multi-AZ部署，在不同的AZ提供数据库的同步备用副本，提高数据库的可用性，并保护数据库不受意外停机的影响</li>
<li>在出现故障转移的情况下，备用服务器被无缝地提升为主服务器，并将处理数据库操作</li>
<li>默认情况下，数据库启用的自动备份为数据库实例提供时间点恢复</li>
<li>RDS将备份数据库和事务日志，并将其存储在用户指定的保留期内</li>
<li>除自动备份外，还可以执行手动RDS备份，这些备份在明确删除之前一直保留</li>
<li>备份有助于从更高级别的故障中恢复，例如无意中的数据修改，无论是操作员错误还是应用程序中的错误</li>
<li>RDS只读副本提供数据库的只读副本，并提供扩展超出单个数据库部署容量的能力，用于读取大量数据库工作负载（<font color="red">注意数据库引擎，不是所有RDS支持</font>）</li>
<li>RDS只读副本是一种可扩展性而非高可用性解决方案</li>
</ul>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><ul>
<li>S3提供高度持久，容错和冗余的对象存储</li>
<li>跨S3区域中的多个设施在多个设备上冗余地存储对象</li>
<li>S3是作为一个非常理想的存储解决方案，适用于静态或缓慢变化的对象，例如图像，视频和其他静态媒体</li>
<li>S3结合Amazon CloudFront服务交互来支持静态内容缓存加速和流式数据加速传输</li>
</ul>
<h2 id="Simple-Queue-Service-–-SQS"><a href="#Simple-Queue-Service-–-SQS" class="headerlink" title="Simple Queue Service – SQS"></a>Simple Queue Service – SQS</h2><ul>
<li>简单队列服务（SQS）是一种高度可靠的分布式消息传递系统，作为容错应用程序的主干环节</li>
<li>SQS旨在提供所有消息的“至少一次”传送</li>
<li>消息被保证发送到队列被保留长达四天（默认，并且可以扩展高达14天）或直到它们被应用程序读出并删除</li>
<li>消息可由多个worker轮询并进行处理，而SQS使用称为可见性超时的可配置时间间隔，一次只由一个worker处理请求</li>
<li>如果队列中的消息数量开始增加，或者处理消息的平均时间变得过高，则可以通过添加额外的EC2实例来向上扩展worker</li>
</ul>
<h2 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h2><ul>
<li>Route 53是一种高度可用且可扩展的域名解析 服务</li>
<li>域名的查询自动路由到最近的DNS服务器，从而提供最佳的性能作了解答</li>
<li>Route 53支持将域名请求（例如，<a href="http://www.example.com）解析为Elastic" target="_blank" rel="noopener">www.example.com）解析为Elastic</a> Load Balancer地址以及域名root记录（example.com）</li>
</ul>
<h2 id="Cloud-Front"><a href="#Cloud-Front" class="headerlink" title="Cloud Front"></a>Cloud Front</h2><ul>
<li>CloudFront可用于使用全球边缘位置网络提供网站加速访问，包括动态，静态和流媒体内容</li>
<li>对内容的请求会自动路由到最近的边缘位置，以最佳性能体验</li>
<li>CloudFront可以与其他AWS（如S3和EC2）配合使用以获得的最好的体验</li>
<li>CloudFront还可以与任何非AWS原始服务器无缝协作，该服务器存储文件的源目标</li>
</ul>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol>
<li><a href="https://www.cnblogs.com/sammyliu/p/4741967.html" target="_blank" rel="noopener">https://www.cnblogs.com/sammyliu/p/4741967.html</a></li>
<li><a href="http://jayendrapatil.com/aws-high-availability-fault-tolerance-architecture-certification/" target="_blank" rel="noopener">http://jayendrapatil.com/aws-high-availability-fault-tolerance-architecture-certification/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/19/AWS-Disaster-Recovery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/AWS-Disaster-Recovery/" itemprop="url">AWS Disaster Recovery</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T21:08:22+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>前言：HA目标保障应用的连续运行（7\</em>24），备份确保数据的安全性，DR确保在距离上主站点故障而其应用、数据都还能够使用.</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><ul>
<li>AWS灾难恢复白皮书重点介绍了可用于灾难恢复流程的AWS服务和功能，以显著降低企业或组织的影响，包括数据、系统和业务运营方面。</li>
<li>概述实现灾难恢复的最佳实践，从最小投资到全面可用性以及容错机制，描述了如何使用AWS服务来降低成本并确保灾难事件后业务连续性的实践</li>
<li>灾备（Disaster Recovery）包括灾备方案和环境准备，以及从灾难中恢复两部分。任何对企业的业务持续性或财务有负面影响的事件都可成为灾难。AWS最佳实践之一就是始终故障设计系统的构建。</li>
<li>灾难包括硬件或软件故障、断网、断电、火灾、水灾、人为错误等等。为了减少灾难带来的损失，企业往往会投入时间和金钱来计划和准备、训练员工、定义和更新流程。为DR 计划而做的投资往往有很大不同。灾难恢复往往有两个指标：</li>
</ul>
<p>RTO - Recovery time objective：从灾难发生到恢复到满足计划SLA服务的时间<br>RPO - Reovery point objective：允许丢失的数据的时间长度<br><img src="https://i.loli.net/2019/08/19/EXpeLb4d6JwfrgO.jpg" alt="001.jpg"></p>
<ul>
<li>常见故障位置</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>硬件故障</td>
<td>系统中任何硬件组件的故障，包括主机，存储，网络或其他等。</td>
</tr>
<tr>
<td>部署失败</td>
<td>由于软件，硬件，网络或配置部署而直接导致的故障。 包括自动和手动更改。</td>
</tr>
<tr>
<td>负载因素</td>
<td>负载相关的故障可以是一个行为触发、特定进程或负载聚合加重，或者服务达到临界点。 而网络尤其可能发生负载故障。</td>
</tr>
<tr>
<td>数据因素</td>
<td>系统接受了无法处理的操作（毒丸）</td>
</tr>
<tr>
<td>凭证过期</td>
<td>证书或凭证到期导致的系统无法继续运行</td>
</tr>
<tr>
<td>依赖关系</td>
<td>相关依赖的服务故障</td>
</tr>
<tr>
<td>基础设施</td>
<td>电力或环境因素导致的硬件故障风险</td>
</tr>
<tr>
<td>资源耗尽</td>
<td>超出可用容量，达到限制条件，ID耗尽，提供的资源不再可用</td>
</tr>
</tbody></table>
<ul>
<li>常见应用应用程序设计目标和可用性</li>
</ul>
<table>
<thead>
<tr>
<th>可用性</th>
<th>最大停机时间（年）</th>
<th>应用类别</th>
</tr>
</thead>
<tbody><tr>
<td>99%</td>
<td>3天15小时</td>
<td>Batch processing, data extraction, transfer, and load jobs</td>
</tr>
<tr>
<td>99.90%</td>
<td>8小时45分钟</td>
<td>Internal tools like knowledge management, project tracking</td>
</tr>
<tr>
<td>99.95%</td>
<td>4小时22分钟</td>
<td>Online commerce, point of sale</td>
</tr>
<tr>
<td><font color="orange">99.99% </font></td>
<td><font color="orange"> 52分钟 </font></td>
<td><font color="orange">Video delivery, broadcast systems    </font></td>
</tr>
<tr>
<td><font color="orange">99.999% </font></td>
<td><font color="orange">5分钟  </font></td>
<td><font color="orange"> ATM transactions, telecommunications systems </font></td>
</tr>
</tbody></table>
<p><font face="黑体" size="5" color="red">针对最后两个AWS建议多Region部署</font></p>
<h2 id="Region级别服务"><a href="#Region级别服务" class="headerlink" title="Region级别服务"></a>Region级别服务</h2><ul>
<li><p>默认S3 DynamoDB EFS SQS Kinesis 提供区域内可靠性保障（无单点）</p>
</li>
<li><p>RDS ElasticCache ElasticSearch 需要配置多可用区部署实现可靠性保障<br><img src="https://i.loli.net/2019/08/19/IOTGYH4Q9EFVcLB.jpg" alt="002.jpg"></p>
</li>
<li><p><strong>AWS服务设计可用性目标</strong>（具体可相见文末《Reliability Pillar》，白皮书包含了非常详细的每一个服务的设计可用性）</p>
</li>
<li><p>基本上来讲，每一个服务都包含控制平面和数据平面，每一个纬度可用性不一样</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>服务</strong></th>
<th align="center"><strong>组件</strong></th>
<th align="center"><strong>可用性</strong></th>
<th align="center"><strong>多可用区可用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">EC2</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">单AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">多AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9990%</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">数据平面（卷可用性）</td>
<td align="center">99.999%</td>
<td align="center">100.0000%</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">单AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">多AZ数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">Route 53</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">Route 53</td>
<td align="center">数据平面(查询结果)</td>
<td align="center">100.000%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">服务（标准）</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">Auto Scaling</td>
<td align="center">控制平面</td>
<td align="center">99.900%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">Auto Scaling</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">EFS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EFS</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">控制平面</td>
<td align="center">99.900%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">数据平面</td>
<td align="center">99.995%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">Lambda</td>
<td align="center">函数调用</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">ELB</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">ELB</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">KMS</td>
<td align="center">控制平面</td>
<td align="center">99.990%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">KMS</td>
<td align="center">数据平面（卷可用性）</td>
<td align="center">99.995%</td>
<td align="center">N/A</td>
</tr>
</tbody></table>
<h1 id="实现DR的AWS关键服务"><a href="#实现DR的AWS关键服务" class="headerlink" title="实现DR的AWS关键服务"></a>实现DR的AWS关键服务</h1><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><ul>
<li>AWS服务在全球多个地区都可以使用，并DR站点位置可以适当地选择与主站点位置不同的区域</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><ul>
<li>11个9的持久性设计的存储架构，专为关键任务和主要数据存储设计</li>
<li>对象数据冗余的存储区域内多个设施多个设备上</li>
</ul>
<h4 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h4><ul>
<li>为数据存档和备份提供极具性价比的存储系统</li>
<li>针对不频繁访问模型进行优化，通常减速时间在3～5小时即可完成</li>
</ul>
<h4 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h4><ul>
<li>提供基于时间点的快照功能</li>
<li>快照卷可以用于创建新卷并附加到运行的实例上</li>
</ul>
<h4 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h4><ul>
<li>提供本地环境与AWS存储系统之间无缝和高度安全的集成服务</li>
</ul>
<h4 id="Snow-Family"><a href="#Snow-Family" class="headerlink" title="Snow Family"></a>Snow Family</h4><ul>
<li>使用便携式存储设备绕过Internet进行传输，加速大量数据移入和移出AWS</li>
<li>通过设高速内部网络将数据直接在设备与存储服务之间传输<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3></li>
</ul>
<h4 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h4><ul>
<li>在云中提供可调整大小的实例，轻松实现创建和扩展</li>
<li>实例使用预配置的AMI模板</li>
<li>EC2可以在多个AZ中启动，实现AZ级别的故障隔离<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3></li>
</ul>
<h4 id="Route53"><a href="#Route53" class="headerlink" title="Route53"></a>Route53</h4><ul>
<li>高度可用且可扩展的域名解析服务</li>
<li>支持全局负载均衡功能，这在处理灾难场景时非常有效。在多站点进行故障转移的时候，站点健康检查非常有用</li>
</ul>
<h4 id="Elastic-IP"><a href="#Elastic-IP" class="headerlink" title="Elastic IP"></a>Elastic IP</h4><ul>
<li>在实例或AZ故障的情况下，IP地址可以被重新映射到健康实例上</li>
<li>EIP专为云计算动态资源设计</li>
</ul>
<h4 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h4><ul>
<li>运行运行状况检查并自动在多个目标（如EC2实例）之间分配的应用程序流量</li>
</ul>
<h4 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h4><ul>
<li>允许配置AWS云的私有隔离部分，以便在定义的虚拟网络中启动资源</li>
</ul>
<h4 id="Direct-Connect"><a href="#Direct-Connect" class="headerlink" title="Direct Connect"></a>Direct Connect</h4><ul>
<li>设置从本地环境到AWS的专用网络连接</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>RDS，DynamoDb，Redshift提供完全托管的RDBMS，NoSQL和数据仓库解决方案，可轻松扩展</li>
<li>DynamoDB提供跨区域复制</li>
<li>RDS提供多可用区部署和只读副本，还能够将数据从一个区域快照到另一个区域</li>
</ul>
<h3 id="部署编排"><a href="#部署编排" class="headerlink" title="部署编排"></a>部署编排</h3><h4 id="CloudFormation"><a href="#CloudFormation" class="headerlink" title="CloudFormation"></a>CloudFormation</h4><ul>
<li>为开发人员和系统管理员提供了一种简单的方法来创建相关AWS资源的集合，并以有序和可预测的方式进行配置（DIY）</li>
</ul>
<h4 id="Elastice-Beanstalk"><a href="#Elastice-Beanstalk" class="headerlink" title="Elastice Beanstalk"></a>Elastice Beanstalk</h4><ul>
<li>是一种易于使用的服务，用于部署和扩展Web应用程序和服务</li>
</ul>
<h4 id="OpsWorks"><a href="#OpsWorks" class="headerlink" title="OpsWorks"></a>OpsWorks</h4><ul>
<li>完全托管的配置管理服务，基础设施和应用程序管理的自动化工具</li>
<li>应用程序塑造成一个包含不同层级 (例如负载均衡层、数据库层和应用程序服务器层) 的堆栈</li>
<li>具实例发生故障时，它将自动替换实例</li>
<li>可用于准备阶段以模拟环境，并在恢复阶段与AWS CloudFormation配合使用</li>
<li>可以依托预配置的堆栈快速的恢复预设环境（达到预设RTO）</li>
</ul>
<h1 id="四种场景"><a href="#四种场景" class="headerlink" title="四种场景"></a>四种场景</h1><p>从“备份和还原”选项（左侧）移至“多站点”选项（右侧）时，RTO和RPO会随着成本的增加而降低<br><img src="https://i.loli.net/2019/08/19/Kqtkb1VrwO5ISAh.png" alt="003.png"></p>
<h2 id="Backup-amp-Restore"><a href="#Backup-amp-Restore" class="headerlink" title="Backup &amp; Restore"></a>Backup &amp; Restore</h2><ul>
<li>备份恢复是最常见的一种容灾手段，将主站点数据备份到与主站点隔离的存储设备。当生产环境故障后，能够在备站点将数据恢复。<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a><strong>备份</strong></h3><img src="https://i.loli.net/2019/08/19/lzv5RpfmHdFo16h.jpg" alt="005.jpg"></li>
</ul>
<p><img src="https://i.loli.net/2019/08/19/S2Wusy9fhACOVko.jpg" alt="006.jpg"></p>
<ul>
<li>在大多数传统环境中，数据备份到磁带并定期发送到异地，需要花费更长时间在中断或灾难时恢复系统</li>
</ul>
<ol>
<li>S3可以在任何位置上进行数据备份和快速恢复</li>
<li>Snow Family系列设备可以直接绕过Internet进行大规模数据的传输</li>
<li>Glacier可用于存档场景，几个小时即可取回数据</li>
<li>Storage Gateway支持将本地数据卷（EBS卷）透明的复制到云上S3中进行备份。既可以作为备份解决方案的网关，也可作为主数据存储（缓存卷）</li>
<li>Direct Connect用于构建高速稳定一致的链路层（本地环境到云上）</li>
<li>EBS卷、RDS、Redshift的快照都可以存储到S3中</li>
</ol>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a><strong>恢复</strong></h3><p><img src="https://i.loli.net/2019/08/19/HYOyPK4SIceX2kb.jpg" alt="007.jpg"></p>
<ul>
<li>备份数据可以快速恢复和创建EC2、数据库实例的运行环境</li>
<li>几个关键步骤<ol>
<li>选择适当的工具或方法将数据备份到AWS</li>
<li>确保对此数据采用适当的保留策略</li>
<li>确保为此数据采取适当的安全措施，包括加密和访问策略</li>
<li>定期测试此数据的恢复和系统的恢复</li>
</ol>
</li>
</ul>
<h2 id="Pilot-Light"><a href="#Pilot-Light" class="headerlink" title="Pilot Light"></a>Pilot Light</h2><p>   Pilot Light 则在AWS上创建最小运行环境，它包含业务系统中最核心部分，比如数据库。这会节省恢复时间，因为系统中最核心部分已经在运行，而且数据是最新的了。而不经常更新部分，比如操作系统和应用，则可以定期打包到AMI中</p>
<ul>
<li>通过在AWS中维持配置和运行最小或关键系统，如数据库应用（保持数据库的复制和更新）</li>
<li>在恢复过程中，一个完整的生产环境，包括应用程序、Web服务等，可以围绕这个核心系统快速配置（预配置AMI模板和EBS快照）；</li>
<li>网络层面，可以使用ELB实现流量分配，并将DNS指向ELB，也可以使用预先分配的EIP与相关实例绑定</li>
</ul>
<h3 id="Pilotlight-prep"><a href="#Pilotlight-prep" class="headerlink" title="Pilotlight-prep"></a>Pilotlight-prep</h3><p><img src="https://i.loli.net/2019/08/19/xdZmK2tVSb9plRD.jpg" alt="008.jpg"></p>
<ol>
<li>建立EC2实例或RDS实例复制或镜像关系，保持关键数据两边一致</li>
<li>确保所有的软件在AWS环境中都可用</li>
<li>建立和维护在故障恢复时的关键服务的AMI（将操作系统和应用，则可以定期打包到AMI）</li>
<li>定期运行这些服务并测试，及时更新配置、软件更新</li>
<li>建议优先考虑自动化配置AWS服务</li>
</ol>
<h3 id="Pilot-light-recovery"><a href="#Pilot-light-recovery" class="headerlink" title="Pilot light-recovery"></a>Pilot light-recovery</h3><p><img src="https://i.loli.net/2019/08/19/C18ZsEtOWjmNDSq.jpg" alt="009.jpg"></p>
<ol>
<li>启动AMI创建EC2实例</li>
<li>视情况调整数据库实例大小/存储实例大小，以应对可能增大的流量，如RDS支持scale up，而EC2也可轻松实现水平扩展</li>
<li>建议在DR站点开启RDS 多可用区部署，以增强站点数据层的健壮性</li>
<li>更改DNS域名解析到新的EC2服务器</li>
<li>安装和配置任何非基于AMI的系统，最好使用自动化方式（避免手工错误）</li>
</ol>
<h2 id="Warm-Standby"><a href="#Warm-Standby" class="headerlink" title="Warm Standby"></a>Warm Standby</h2><ul>
<li>在温备场景下，一个小规模的完整业务环境会运行在AWS中</li>
<li>还能用于非生产环境，比如测试和内部使用</li>
<li>在灾难的情况下，系统可以轻松地按比例放大或缩小处理生产负载</li>
</ul>
<h3 id="Warm-standby—prep"><a href="#Warm-standby—prep" class="headerlink" title="Warm standby—prep"></a>Warm standby—prep</h3><p><img src="https://i.loli.net/2019/08/19/VfY2FtMjGD65a89.jpg" alt="010.jpg"></p>
<ol>
<li>建立实例级别的复制或镜像关系</li>
<li>创建和维护AMI以加快部署速度</li>
<li>使用最小配置环境运行服务</li>
<li>根据需要及时更新软件、补丁和配置文件，保持与主站点一致</li>
</ol>
<h3 id="Warm-standby—recover"><a href="#Warm-standby—recover" class="headerlink" title="Warm standby—recover"></a>Warm standby—recover</h3><p><img src="https://i.loli.net/2019/08/19/UYPvqVmub3FwCnj.jpg" alt="011.jpg"></p>
<ol>
<li>增加EC2数量（横向扩展）（扩成与主站点一致）</li>
<li>根据需要增大EC2配置（纵向扩展）使其启动应用程序</li>
<li>手动更改DNS记录，或使用Route 53自动运行状况检查将所有流量路由到AWS环境</li>
<li>增大或扩展数据库以防止DR发生故障</li>
<li>考虑使用AutoScaling组以调整适应负载的变化</li>
</ol>
<h2 id="Multi-Site"><a href="#Multi-Site" class="headerlink" title="Multi Site"></a>Multi Site</h2><ul>
<li>Multi Site 指的是 active-active 的架构，在两个站点上提供同样的基础架构</li>
<li>主备站点同时对外提供服务，由DNS根据加权路由决定将请求转发到相应站点</li>
<li>在故障的情况下，通过DNS解析可以将流量转发到健康站点，并同时扩展其架构以使用负载增大</li>
</ul>
<h3 id="Multi-site—prep"><a href="#Multi-site—prep" class="headerlink" title="Multi site—prep"></a>Multi site—prep</h3><p><img src="https://i.loli.net/2019/08/19/EAqiml5hf7Iwp19.jpg" alt="012.jpg"></p>
<ol>
<li>在AWS上复制生产环境到站点</li>
<li>DNS 可以根据加权规则进行不同比率流量分配</li>
<li>配置自动故障转移以将流量从受影响的站点重新路由。 例如用于检查主数据库是否可用的应用程序，若master故障则重定向到另外一边</li>
</ol>
<h3 id="Multi-site—recovery"><a href="#Multi-site—recovery" class="headerlink" title="Multi site—recovery"></a>Multi site—recovery</h3><p><img src="https://i.loli.net/2019/08/19/lyESjqAcoma8UPg.jpg" alt="013.jpg"></p>
<ol>
<li>手动或使用DNS故障转移集群，修改DNS权重，以便将所有请求转发到将康站点</li>
<li>具备故障转移应用程r 需要能够逻辑处理在切换后使用本地的数据库（健康）</li>
<li>建议使用AutoScaling组以自动调整其负载规模的变化</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Fail-back"><a href="#Fail-back" class="headerlink" title="Fail back"></a>Fail back</h2><p>当主站点恢复以后，你往往需要将运行环境从灾备环境切换到原来的主环境，此成为 fail-back。对于不同的灾备场景，有不同的做法。</p>
<p><strong>备份和恢复</strong></p>
<ol>
<li>冻结向 DR site 的数据更新</li>
<li>做备份</li>
<li>将备份 restore 到主 site</li>
<li>将用户引流到主site</li>
<li>解冻数据更新</li>
</ol>
<p><strong>Pilot light, warm standby, and multi-site：</strong></p>
<ol>
<li>从 DR site 往主site 做数据同步，直到主site数据一致</li>
<li>冻结向 DR site 的数据更新</li>
<li>将用户引流到主site</li>
<li>解冻数据更新</li>
</ol>
<h2 id="多站点部署需要考虑的因素"><a href="#多站点部署需要考虑的因素" class="headerlink" title="多站点部署需要考虑的因素"></a>多站点部署需要考虑的因素</h2><ul>
<li>站点间的距离 - 距离越远，往往延迟越高</li>
<li>可用的带宽</li>
<li>应用所需的数据同步速率 - 这速度需要低于可用带宽</li>
<li>同步技术 - 同步需要是并行的，以提高效率</li>
<li>同步方式 - 同步的和异步的。AWS RDS 在可用区之间是同步的</li>
<li>同步目标 - 是往一个目标站点同步，还是往多个目标站点同步</li>
</ul>
<h2 id="灾备计划"><a href="#灾备计划" class="headerlink" title="灾备计划"></a>灾备计划</h2><ul>
<li>测试：一旦DR site 准备就绪，需要有完整的测试来验证</li>
<li>持续的监控和告警：对 DR site 做持续监控，并及时处理问题</li>
<li>备份：即使切换到DR site，还是要做常规备份</li>
<li>用户访问：要保证用户访问 DR site 的安全性</li>
</ul>
<p>Refer</p>
<ol>
<li><a href="https://media.amazonwebservices.com/AWS_Disaster_Recovery.pdf" target="_blank" rel="noopener">https://media.amazonwebservices.com/AWS_Disaster_Recovery.pdf</a> 《Using Amazon Web Services for Disaster Recovery》</li>
<li><a href="https://www.cnblogs.com/sammyliu/p/8902556.html" target="_blank" rel="noopener">https://www.cnblogs.com/sammyliu/p/8902556.html</a></li>
<li>《Building Fault-Tolerant Application on AWS》</li>
<li><a href="https://d1.awsstatic.com/whitepapers/architecture/AWS-Reliability-Pillar.pdf" target="_blank" rel="noopener">https://d1.awsstatic.com/whitepapers/architecture/AWS-Reliability-Pillar.pdf</a> 《Reliability Pillar》</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/19/AWS-S3-Deep-Dive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/AWS-S3-Deep-Dive/" itemprop="url">AWS S3 Deep Dive</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T17:24:15+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>前言：本文主要介绍S3的详细功能，涉及S3 存储分类，一致性模型，生命周期管理，版本控制，权限管理，数据加密和最佳实践建议等。</em> </p>
<h1 id="S3-Overview"><a href="#S3-Overview" class="headerlink" title="S3 Overview"></a>S3 Overview</h1><h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><ul>
<li>Amazon S3是一个面向Internet设计的简单的键值对象存储系统</li>
<li>S3提供无限的存储空间，并仅在使用时才产生付费（按需）。费用随着使用量增加将变得更便宜。</li>
<li>S3是对象级别存储(不是块级存储)，不能用于托管OS或动态网站</li>
<li>S3资源在默认情况下是私有的，包含bucket和对象数据</li>
</ul>
<h2 id="S3-Bucket-amp-Objects"><a href="#S3-Bucket-amp-Objects" class="headerlink" title="S3 Bucket&amp;Objects"></a>S3 Bucket&amp;Objects</h2><ul>
<li>Buckets<ul>
<li>Bucket(存储桶)是存储对象的容器空间，组织和管理S3的命名空间</li>
<li>bucket由AWS帐户拥有，该帐户创建bucket并帮助标识负责存储和数据传输费用，bucket所有权不可转让</li>
<li>S3桶名是全局惟一的，但bueket创建是需要指定其所在区域（Region），<table><tr><td bgcolor="orange"> 也就是指其名字是Global，而数据仅限于Region范围内</td></tr></table></li>
<li>每一个object依附于bucket中</li>
<li>可以存储在存储桶中的对象数量没有限制，性能也没有差异(无论使用多buckets或单一bucket)</li>
<li>S3数据模型是扁平结构，即桶内没有层次结构或文件夹。可以通过使用键名称前缀（例如Folder1 / Object1）来推断逻辑层次结构</li>
<li>限制<ul>
<li>每个AWS账户中创建100个存储桶（软限制）</li>
</ul>
</li>
<li>存储桶名称应该是全局唯一且符合DNS的要求<table><tr><td bgcolor="orange">（小写，每一个对象都能通过其唯一url访问，url包含域名）</td></tr></table><ul>
<li>bucket所有权不可转让</li>
<li>bucket不能嵌套bucket</li>
</ul>
</li>
<li>可以删除空桶或非空桶</li>
<li>S3允许检索1000个对象并提供分页支持</li>
</ul>
</li>
<li>Objects<ul>
<li>对象是存储在S3 bucket中的基本实体</li>
<li>对象的唯一标识通过<table><tr><td bgcolor="orange">键名和版本ID</td></tr></table></li>
<li>对象由对象数据、元数据等其他信息组成</li>
<li>Key（键）是对象名称</li>
<li>Value(值)是数据部分且对S3不透明</li>
<li>元数据是关于数据的数据，并且是一组name-value，其描述例如内容类型，大小，最后修改时间。还可以在存储对象时自定义元数据</li>
<li>版本ID是对象的版本，与key结合使用在桶中唯一标识对象</li>
<li>Subresource（子资源） 有助于为对象提供附加信息</li>
<li>Access Control控制对象的访问权限</li>
<li>S3对象允许对象两种元数据<ul>
<li>System metadata<ul>
<li>诸如Last-Modified 时间之类的元数据，只能有S3有权限进行修改</li>
<li>用户可以控制的系统元数据，例如为对象配置的存储类（class）。</li>
</ul>
</li>
<li>User-defined metadata<ul>
<li>User可以自定义其对象元数据上传之前或之后</li>
<li>字定义的元数据与对象一起存储，并在下载对象时返回</li>
<li>S3不处理自定义元数据</li>
<li>自定义元数据必须以“x-amz-meta”开头，否则S3将不会处理其自定义设置</li>
</ul>
</li>
</ul>
</li>
<li>对象元数据上传之后不能修改，只能通过执行复制操作来设置元数据修改</li>
<li>属于bucket的对象保存在设定的Region范围内，不能离开此区域，除非使用块区域复制进行显式复制</li>
<li>对象作为整体或部分进行检索</li>
<li>启用版本控制之后，可以检索当前和之前的版本</li>
</ul>
</li>
</ul>
<h2 id="Bucket-amp-Object-操作"><a href="#Bucket-amp-Object-操作" class="headerlink" title="Bucket &amp; Object 操作"></a>Bucket &amp; Object 操作</h2><ul>
<li>Listing<ul>
<li>S 3 允许列出存储桶中所有key</li>
<li>一个list请求最多返回1000个对象，并且支持分页展示，在响应中使用指示器显示是否响应</li>
<li>可以使用前缀和分隔符列出key</li>
<li>Prefix将结果限制为仅以指定前缀开头的键(过滤)，分隔符list将包含公共前缀的所有key列出，形成一个摘要列表</li>
</ul>
</li>
<li>Retrival<ul>
<li>对象可以作为整体取回</li>
<li>可以使用Range HTTP标头一部分或部分特定字节检索对象</li>
<li>Range HTTP 标头非常有用<ul>
<li>如只需要部分对象，在多文件作为一个归档文件上传的时候</li>
<li>在网络环境较差的情况下，进行下载数据</li>
</ul>
</li>
<li>对象支持预签名 url访问</li>
<li>对象的元数据包含在响应标头中</li>
</ul>
</li>
<li>Object Uploads<ul>
<li>单次操作——单次put 操作最大对象5GB</li>
<li>分段上传——可用于上传大于5B大小的对象，最大5TB</li>
<li>支持预签名 URL上传对象</li>
<li>上传对象是否成功，可通过reponse值显示。此外，可以将返回的ETAG值与对象的MD5值进行比对</li>
</ul>
</li>
<li>Copying Objects<ul>
<li>单次操作最大5GB的对象，使用分段上传进行大于5GB的对象（最大5TB）</li>
<li>复制对象时<ul>
<li>用户自定义的元数据，如存储类和自定义的元数据都会被复制</li>
<li>系统元数据保留（如创建日期）</li>
</ul>
</li>
<li>其他复制情形<ul>
<li>复制多个对象副本</li>
<li>跨地点复制对象</li>
<li>重命名对象</li>
<li>更改对象元数据，例如存储分类，服务器端加密等</li>
<li>更新对象的任何元数据都需要再次指定的字段</li>
</ul>
</li>
</ul>
</li>
<li>Deleting Objects<ul>
<li>S3允许单次删除一个或最多100个对象</li>
<li>未开启版本控制bucket<ul>
<li>明确提供键名（key）则永久删除对象</li>
</ul>
</li>
<li>开启版本控制bucket<ul>
<li>删除对象键(key)，S3将插入一个删除标记，当前对象将变为非当前对象</li>
<li>删除对象键（key）和version ID,S3将永久删除对象</li>
<li>若version id作为删除标记，那么删除标记将被删除，previous版本将成为当前版本对象</li>
<li>启用MFA安全删除需要删除的对象</li>
</ul>
</li>
</ul>
</li>
<li>Restoring Objects from Glacier <ul>
<li>在访问存档对象之前，必须还原对象</li>
<li>对象的恢复可能需要大约3到5个小时进行标准检索。Glacier现在可以在几分钟内提供快速检索</li>
<li>恢复请求对象需要指定需要维护对象副本（Glacier数据临时放到S3上）的时间（天）</li>
<li>在此期间，存档和副本的存储费用都要收取</li>
</ul>
</li>
</ul>
<h2 id="Pre-Signed-URLs"><a href="#Pre-Signed-URLs" class="headerlink" title="Pre-Signed  URLs"></a>Pre-Signed  URLs</h2><ul>
<li>默认情况下，所有存储桶和对象都是私有的</li>
<li>预签名URL允许用户无需AWS安全凭据或权限即可下载或上载特定对象</li>
<li>预签名URL允许任何人访问URL中标识的对象，只要创建者游泳访问权限</li>
<li>预签名url需要创建者提供其安全凭证、指定bucket名称、对象密钥、HTTP方法(GET PUT)以及过期日期和时间</li>
<li>预签名url有时间期限</li>
</ul>
<h2 id="Multipart-upload"><a href="#Multipart-upload" class="headerlink" title="Multipart upload"></a>Multipart upload</h2><ul>
<li>分段上传允许分批次上传，每一次操作都是数据的一部分（子集）</li>
<li>Multipart uploads支持将数据拆分成1~10000部分，每部分数据从5MB到5GB，最后一次上传的数据允许小于5MB</li>
<li>每一部分数据可以独立上传，并且可以任意顺序上传。如果任何部分的传输失败，不影响其他部分的情况下重新上传</li>
<li>上传对象的所有部分并完成初始化之后，S3组装这些数据并创建对</li>
<li>使用分段上传的优势<ul>
<li>提高吞吐量——并行</li>
<li>避免网络故障的影响范围——最大减小网络故障带来上传数据失败（但也只影响部分数据，而不是全部）</li>
<li>暂停和恢复上传-对象部分可以随时间上传。一旦多部分上传启动，需要指定其完成或者中断时间，要不然会持续占有进程。就</li>
<li>对象可以在创建时上传，即便未知其大小</li>
</ul>
</li>
<li>操作步骤<ul>
<li>分段上传初始化<ul>
<li>分段上传请求初始化时会为每个分段上传分配唯一ID</li>
<li>每个部分上传，在完成或中止请求以及分段调用使用供此ID</li>
<li>在初始化时需要用提供object的元数据</li>
</ul>
</li>
<li>分段上传<ul>
<li>分段上传的数据使用唯一的上传ID标识</li>
<li>每一部分都有一个part number（1~1000）标识自己的分段在对象数据中位置</li>
<li>如果上传部分有相同的part number 则会覆盖前面的数据</li>
<li>上传成功之后，S3会返回Etag标头，标头需要与part number一起记录下来</li>
</ul>
</li>
<li>上传完成或暂停<ul>
<li>一旦上传请求完成，S3根据part number顺序组装数据，并将元数据与对象关联，创建对象</li>
<li>每一部分上传完成，应包含分段唯一上传UD、Etag</li>
<li>S3 response包括唯一地标识所述组合对象数据一个ETag</li>
<li>当分段上传abort时，则中止并删除所有上传的分段。但是，任何其他已经正在上传的部分，必须在完成上传之后才能发送abort</li>
<li>S3需要明确接收到上传完成或中止请求，不然不会删除上传部分并会收取相关存储费用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟主机-vs-url路径访问模式"><a href="#虚拟主机-vs-url路径访问模式" class="headerlink" title="虚拟主机 vs url路径访问模式"></a>虚拟主机 vs url路径访问模式</h2><p>S3允许以路径样式或虚拟主机样式的url引用桶和对象</p>
<ul>
<li>Path style <ul>
<li>Bucket name不是域名一部分（除非使用区域特定端点）</li>
<li>使用的endpoint必须与存储桶所在的区域匹配，例如，如果有一个名为mybucket的存储桶位于EU（爱尔兰）区域，其对象名为puppy.jpg，则正确的路径样式语法URI为http：//s3-eu-west-1.amazonaws.com/mybucket/puppy.jpg</li>
<li>收到带有HTTP响应代码301的“PermanentRedirect”错误，这条消息表达的意思是：如果在美国东部（弗吉尼亚北部）区域之外访问存储桶，正确的合规的资源URL请使用如下表达方式：<ul>
<li><a href="http://s3.amazonaws.com" target="_blank" rel="noopener">http://s3.amazonaws.com</a></li>
<li>与存储区所在区域不同的区域的endpoint。 例如，如果使用<a href="http://s3-eu-west-1.amazonaws.com获取在美国西部（加利福尼亚州北部）地区创建的存储桶" target="_blank" rel="noopener">http://s3-eu-west-1.amazonaws.com获取在美国西部（加利福尼亚州北部）地区创建的存储桶</a></li>
</ul>
</li>
</ul>
</li>
<li>Virtual Host style <ul>
<li>S3 支持在所有区域中的虚拟主机托管和路径访问模式</li>
<li>在虚拟主机托管方式中，bucket name是url中域名的一部分</li>
<li>如<a href="http://bucketname.s3.amazonaws.com/objectname" target="_blank" rel="noopener">http://bucketname.s3.amazonaws.com/objectname</a></li>
<li>S3虚拟主机可用于通过使用HTTP host 标头头来使用REST API调用存储桶</li>
<li>优势<ul>
<li>自定义访问路径</li>
<li>提供发布到bucket虚拟主机的“root directory”的功能。此功能非常重要，许多现有应用程序会在此标准位置搜索数据</li>
</ul>
</li>
<li>当在任何区域中创建存储桶时，S3会更新DNS以将请求重新路由到正确的位置，这可能需要一些时间。</li>
<li>如果使用美国东部（弗吉尼亚北部）端点s3.amazonaws.com，则S3会将任何虚拟托管样式请求路由到美国东部（N.Virginia）区域，而不是特定于区域的端点（例如 ，s3-eu-west-1.amazonaws.com）并且S3将其重定向到HTTP 307重定向到正确的区域。</li>
<li>使用带有SSL的虚拟托管样式存储桶时，SSL通配符证书仅匹配不包含句点的存储桶。要解决此问题，请使用HTTP或自行编写证书验证逻辑。</li>
<li>如果向<a href="http://bucket.s3.amazonaws.com端点发出请求，则DNS有足够的信息将请求直接路由到存储区所在的区域。" target="_blank" rel="noopener">http://bucket.s3.amazonaws.com端点发出请求，则DNS有足够的信息将请求直接路由到存储区所在的区域。</a></li>
</ul>
</li>
</ul>
<h1 id="S3-Conssistency-Model-一致性模型"><a href="#S3-Conssistency-Model-一致性模型" class="headerlink" title="S3 Conssistency Model 一致性模型"></a>S3 Conssistency Model 一致性模型</h1><ul>
<li>S3通过在亚马逊数据数据中心内的多个服务器上复制数据来实现高可用性</li>
<li>S3为新的对象put 提供写后读一致性（read-after-write）<ul>
<li>对于PUT请求，S3在返回SUCCESS之前完成在多个设施中数据同步</li>
<li>进程对新对象的写入，可以立即读取对象</li>
<li>进程将新对象的写入S3能立即在其存储桶中列出key。 在完全传播更改之前，对象可能不会出现在list中</li>
</ul>
</li>
<li>S3对覆盖puts&amp;deletes 对象提供最终一致性<ul>
<li>对象的更新和删除，更改最终会反映出来并且不会立即可用</li>
<li>若进程替换现有对象并立即尝试读取它。 在完全传播更改之前，S3可能会返回先前的数据</li>
<li>若进程删除现有对象并立即尝试读取它。 在完全传播删除之前，S3可能会返回已删除的数据</li>
<li>若进程删除现有对象并立即在其存储桶中列出key。 在删除完全传播之前，S3可能会列出已删除的对象。</li>
</ul>
</li>
<li>对于key的更改是原子的。 例如，如果PUT到现有key，后续读取可能会返回旧数据或更新数据，但它永远不会写入损坏或只有部分数据（不存在中间状态，要么成功要么失败）。</li>
<li>S3目前不支持对象数据锁定。例如，如果同时对同一个key发出两个PUT请求，则具有最新时间戳的请求获胜。如果要避免这个问题，将需要在应用程序中构建一个对象锁定机制</li>
<li>更新是基于key的; 没有办法跨key进行原子更新。 例如，除非在应用程序中设计此功能，否则无法更新一个key取决于另一个key的更新</li>
</ul>
<h1 id="S3-Subresources"><a href="#S3-Subresources" class="headerlink" title="S3 Subresources"></a>S3 Subresources</h1><ul>
<li>S3 Subresources提供存储和管理bucket配置</li>
<li>S3 subresources 存在于特定的存储桶或对象中</li>
<li>S3定义了一组与桶和对象相关联的subresources</li>
<li>S3 subresources是对象的子集; 也就是说，它们不是自己存在的，它们总是与某个其他实体相关联，例如对象或桶(如acl或bittorrent)</li>
<li>S3支持配置存储桶的各种选项，例如，可以配置存储桶用于网站托管，添加配置以管理存储桶中对象的生命周期，以及记录对存储桶的所有访问</li>
</ul>
<h2 id="静态网站托管"><a href="#静态网站托管" class="headerlink" title="静态网站托管"></a>静态网站托管</h2><ul>
<li>S3可用于静态网站托管（client 处理脚本）</li>
<li>S3不支持服务端处理脚本</li>
<li>S3与Route 53结合使用，支持根域托管网站，直接指向指向S3网站端点</li>
<li>S3 网站端点不支持Https</li>
<li>对于S3网站托管，内容应该是公开可读的，可以使用桶策略或对象上的ACL来设置</li>
<li>用户可以自定义索引，错误页面以及指向对象名称的条件路由</li>
<li>存储桶策略仅适用于存储桶拥有者拥有的对象。如果存储桶包含不属于存储桶拥有者的对象，则应使用对象ACL授予对这些对象的公共READ权限</li>
<li>请求者支付费用或DevPay存储桶不允许通过网站端点进行访问。对此类存储桶的任何请求都将收到403 -拒绝响应</li>
</ul>
<h2 id="跨源资源共享-CORS"><a href="#跨源资源共享-CORS" class="headerlink" title="跨源资源共享 (CORS)"></a>跨源资源共享 (CORS)</h2><ul>
<li>所有浏览器都实现了同源策略，出于安全考虑，其中来自域网页只能从同一个域请求资源。</li>
<li>CORS允许装在一个域中访问受限的资源上的客户端Web应用程序从另一个域要求</li>
<li>在S3中使用CORS支持允许跨源访问S3资源</li>
<li>CORS配置规则标识允许访问存储桶的起源，每个源支持的操作（HTTP 方法）以及其他特定操作的信息</li>
</ul>
<h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><ul>
<li>默认情况下禁用日志记录，开启追踪可以记录S3访问记录</li>
<li>每单个访问请求的详细日志记录信息，包含请求者，存储桶名称，请求时间，请求操作，响应状态和错误代码（如果有）。</li>
<li>访问日志信息在安全性和访问审核中非常有用，还有助于了解客户和S3账单</li>
<li>S3定期收集访问日志记录，合并日志文件中的记录，然后将日志文件作为日志对象上载到目标存储桶。</li>
<li>如果在具有相同目标bucket的多个源存储桶上启用了日志记录，则目标存储桶将具有所有这些源存储桶的访问日志，但每个日志对象将报告指定其源存储桶的访问日志记录。<br>标签</li>
<li>S3提供标记子资源以存储和管理存储桶上的标记</li>
<li>可以将成本分配标签添加到存储桶以对AWS成本进行分类和跟踪</li>
<li>AWS可以产生与使用和添加到bucket中的标签汇总费用成本分配报告</li>
</ul>
<h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><ul>
<li>创建存储桶时，需要明确指定在将要创建S3存储桶的AWS区域</li>
<li>S3将此信息存储在subresource(子资源)中，并提供用于检索此信息的API</li>
</ul>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><ul>
<li>通过 Amazon S3 通知功能，可以在存储桶中发生某些事件时接收通知</li>
<li>通知级别是Bucket级</li>
<li>通知配置可以通过对象的key的前缀和后缀进行过滤，但是不能使用重叠定义过滤规则</li>
<li>S3支持的时间类型<ul>
<li>新对象创建<ul>
<li>PUT、POST、COPY操作</li>
<li>不会从失败的操作收到事件通知</li>
</ul>
</li>
<li>对象删除事件<ul>
<li>公共删除事件以删除对象，删除版本对象或删除标记的插入</li>
<li>不会收到来自生命周期策略或失败操作的自动删除的事件通知</li>
<li>RRS存储类别对象丢失事件</li>
<li>可用于重现/重新创建Object</li>
</ul>
</li>
</ul>
</li>
<li>S3支持将事件发布到一下目标<ul>
<li>SNS</li>
<li>SQS</li>
<li>AWS lambda</li>
<li>必须授予Amazon S3 权限以调用相应目标</li>
</ul>
</li>
</ul>
<h2 id="跨区域复制-CRR"><a href="#跨区域复制-CRR" class="headerlink" title="跨区域复制 (CRR)"></a>跨区域复制 (CRR)</h2><ul>
<li>跨区域复制是一项存储桶级别配置，该功能支持跨不同 AWS 区域中的存储桶自动异步复制对象</li>
<li>可以请求 Amazon S3 复制所有对象，也可以通过在配置中提供一个键名称前缀来请求复制部分对象</li>
<li>默认使用安全套接字层 (SSL) 跨 AWS 区域加密传输中的所有数据</li>
<li>除非复制配置中发出特定请求，否则目标存储桶中的对象副本与源存储桶中的对象完全相同</li>
<li>CRR可用于以下场景需求：<ul>
<li>合规性要求——跨区域备份</li>
<li>最大限度减少延迟 – 客户处于两个地理位置</li>
<li>操作原因 – 两个不同 AWS 区域中具有分析同一组对象的计算集群</li>
</ul>
</li>
<li>要求<ul>
<li>源存储桶和目标存储桶必须已启用版本控制</li>
<li>源存储桶和目标存储桶必须处于不同的 AWS 区域</li>
<li>对象只能从源存储桶复制到一个目标存储桶</li>
<li>S3 必须对象从源存储桶复制到目标存储桶的权限</li>
<li>源存储桶拥有者也是对象的拥有者，则其拥有复制对象的完全权限。如果不是，则对象拥有者必须通过对象 ACL 向存储桶拥有者授予 READ 和 READ_ACP 权限（s3:GetObjectVersion and s3:GetObjectVersionACL）</li>
<li>在跨账户方案 (其中，源存储桶和目标存储桶由不同的 AWS 账户拥有) 中设置复制配置，源存储区拥有者必须具有复制目标存储区中对象的权限。</li>
</ul>
</li>
<li>复制和不复制的内容<ul>
<li>复制的内容<ul>
<li>添加复制配置之后创建的任何新对象</li>
<li>S3 会复制使用 Amazon S3 托管密钥 (SSE-S3) </li>
<li>复制存储桶拥有者有权读取对象和访问控制列表 (ACL) 的源存储桶中的对象</li>
<li>虽然在Amazon S3可以使两者同步之前可能会有一些延迟，但会复制任何对象ACL更新。 这仅适用于将复制配置添加到存储桶后创建的对象。<ul>
<li>不复制的内容</li>
</ul>
</li>
<li>S3不会追溯复制添加复制配置之前存在的对象</li>
<li>S3不会复制存储桶拥有者没有权限的源存储桶中的对象</li>
<li>对存储桶级别子资源进行的更新不会进行复制</li>
<li>不会复制使用客户提供的加密密钥通过服务器端加密 (SSE-C) 创建的对象。</li>
<li>不会复制使用 AWS KMS 托管加密密钥通过服务器端加密 (SSE-KMS) 创建的对象</li>
<li>仅复制客户操作。不复制生命周期配置执行的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="S3-Storage-Tiers-存储分层"><a href="#S3-Storage-Tiers-存储分层" class="headerlink" title="S3 Storage Tiers 存储分层"></a>S3 Storage Tiers 存储分层</h1><ul>
<li>Amazon S3存储层旨在维持一个或两个设施中的并发数据丢失</li>
<li>S3存储层允许生命周期管理以自动迁移对象以节省成本</li>
<li>S3存储层支持传输中的数据和静态数据加密的SSL加密</li>
<li>S3还使用校验和定期验证数据的完整性，并提供自动修复功能</li>
</ul>
<h2 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h2><ul>
<li>针对性能敏感的场景和频繁访问数据的理想选择，能够在2个设施的故障情况下继续提供服务</li>
<li>默认的存储层</li>
<li>低延迟和高吞吐的性能</li>
<li>11个9的持久性设计方案</li>
<li>年可使用率达到99.99%</li>
<li>提供Amazon SLA服务等级保障协议</li>
</ul>
<h2 id="Standard-IA"><a href="#Standard-IA" class="headerlink" title="Standard-IA"></a>Standard-IA</h2><ul>
<li>S3 Standard-IA （infrequent Access）存储层旨在提供长周期保存和不长访问的数据，如备份和受限访问旧数据，但仍然在访问时需要提供Standard层的性能</li>
<li>STANDARD-IA旨在维持两个基础设施中的数据丢失</li>
<li>STANDARD_IA对象可用于实时访问</li>
<li>STANDARD_IA存储类适用于保留至少30天的大于128 KB的较大对象（较小的对象仅为128 KB）。</li>
<li>标准的低延迟和高吞吐量性能</li>
<li>专为99.999999999％的持久性设计</li>
<li>年可使用率达到99.99%</li>
<li>提供Amazon SLA服务等级保障协议</li>
</ul>
<h2 id="Reduced-Redundancy-Storage-–-RRS"><a href="#Reduced-Redundancy-Storage-–-RRS" class="headerlink" title="Reduced Redundancy Storage – RRS"></a>Reduced Redundancy Storage – RRS</h2><ul>
<li>RRS存储层设计用于以比STANDARD层别更低的冗余级别存储，存储非关键，可重现的数据，从而降低存储成本</li>
<li>专为99.99％的持久性设计</li>
<li>年可使用率达到99.99%</li>
<li>较低的冗余级别导致较低的耐用性和可用性</li>
<li>RRS将对象存储在多个设备的多个设备上，提供400倍于典型磁盘驱动器的耐用性，</li>
<li>RRS不会像S3标准存储一样多次复制对象，并且旨在维持单个设施中的数据丢失。</li>
<li>如果RRS对象丢失，则S3对该对象发出的请求返回405错误</li>
<li>S3可以发送在桶上配置的事件通知，以在检测到RRS对象丢失时用于警告用户或启动工作流，该RRS对象可用于替换丢失的对象</li>
</ul>
<h2 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h2><ul>
<li>GLACIER存储层特别适合用于存档数据，其中数据取回通常需要3-5小时罕</li>
<li>GLACIER存储层使用非常低成本的存储服务，但此存储类中的对象仍通过S3管理</li>
<li>专为99.999999999％的持久性设计</li>
<li>GLACIER不能在对象创建时指定为存储层，但必须使用生命周期管理从STANDARD，RRS或STANDARD_IA转换为GLACIER存储类。</li>
<li>访问Glacier 对象<ul>
<li>必须通过恢复对象，这可能需要3-5小时</li>
<li>对象仅适用于还原请求期间指定的时间段（天数）</li>
<li>对象的始终保存在Glacier</li>
<li>存档（GLACIER层费用）和临时恢复的副本（RRS层费用）均收取费用</li>
</ul>
</li>
<li>Vault Lock功能可锁定策略强制实施合规性</li>
</ul>
<h1 id="S3-Object-Lifecycle"><a href="#S3-Object-Lifecycle" class="headerlink" title="S3 Object Lifecycle"></a>S3 Object Lifecycle</h1><h2 id="S3-Object-Lifecycle-Overview"><a href="#S3-Object-Lifecycle-Overview" class="headerlink" title="S3 Object Lifecycle Overview"></a>S3 Object Lifecycle Overview</h2><ul>
<li>可以使用生命周期策略来管理S3对象生命周期，该生命周期策略定义S3在其生命周期中如何管理对象</li>
<li>生命周期策略简化对象的生命周期管理，例如移动访问频率较低的对象、备份或存档数年的数据或永久删除对象，所有操作都可以后台自动控制</li>
<li>每个bucket最多配置1000个生命周期规则</li>
<li>应用于存储桶的S3对象生命周期策略规则适用于存储桶中的现有对象以及将未来添加的对象</li>
<li>S3对象生命周期策略对数据管理支持两种操作：<ul>
<li>Transition(转换)，其对象可以更改存储层（class）</li>
<li>Expiration，到期时间永久删除</li>
</ul>
</li>
<li>生命周期策略可以与版本控制结合，允许一个当前对象版本和零级或多个非当前对象的版</li>
<li>生命周期策略适用于非版本控制和启用版本控制的存储桶</li>
<li>未开启版本控制bucket<ul>
<li>Transition周期从对象创建时算起</li>
</ul>
</li>
<li>开启版本控制bucket<ul>
<li>Transition周期从对象创建起开始</li>
<li>非当前对象的转换周期是为该对象成为非当前版本控制对象的日期计算的</li>
<li>S3使用自其后续对象创建以来的天数作为对象非当前的时间</li>
</ul>
</li>
<li>S3规则中指定的时间从对象创建时间开始算起，采用UTC记录。</li>
<li>不支持在bucket的生命周期策略使用MFA</li>
</ul>
<h2 id="S3-Object-Lifecycle-Management-Rules"><a href="#S3-Object-Lifecycle-Management-Rules" class="headerlink" title="S3 Object Lifecycle Management Rules"></a>S3 Object Lifecycle Management Rules</h2><ol>
<li>STANDARD或REDUCED_REDUNDANCY  - &gt;（128 KB和30天） - &gt; STANDARD_IA<ul>
<li>只能transition(转换)超过128kb的对象，因为只有较大的对象才能实现成本优势（转到Standard-ia）</li>
<li>在转换到STANDARD_IA之前，对象必须在当前存储层中至少30天，因为较新的对象被更频繁地访问或者比适合STANDARD_IA更早删除</li>
</ul>
</li>
<li>STANDARD_IA -&gt; X -&gt; STANDARD or REDUCED_REDUNDANCY<ul>
<li>无法从Standard-IA转换到Standard或reduced-redundancy</li>
</ul>
</li>
<li>STANDARD or REDUCED_REDUNDANCY or STANDARD_IA -&gt; GLACIER<ul>
<li>任何存储层数据都可以transition 到Glacier</li>
</ul>
</li>
<li>STANDARD or REDUCED_REDUNDANCY -&gt; (1 day) -&gt; GLACIER<ul>
<li>标准或RRS层转换到Glacier在一天内完成</li>
</ul>
</li>
<li>STANDARD_IA -&gt; (30 days) -&gt; GLACIER<ul>
<li>对象创建起或非当前版本日期，需要花费30~60天才能从Standard-IA转换到Glacier</li>
</ul>
</li>
<li>GLACIER-&gt; X -&gt; STANDARD or REDUCED_REDUNDANCY or STANDARD_IA<ul>
<li>对象转换到Glacier层时单向的</li>
<li>无法从Glacier层将数据转换到其他存储层</li>
</ul>
</li>
<li>GLACIER -&gt; (90 days) -&gt; Permanent Deletion<ul>
<li>归档到Glacier层的数据，已经存档3个月或更长，则删除归档对象是免费的</li>
<li>如果删除或覆盖存档3个月以内的对象，则会按比例收取相关费用</li>
</ul>
</li>
<li>STANDARD or STANDARD_IA or GLACIER -&gt; X-&gt; REDUCED_REDUNDANCY<ul>
<li>无法将数据从任何存储层转换到Reduced-redundancy</li>
</ul>
</li>
<li>使用对象生命周期策略将对象归档到Glacier是异步执行的，并且生命周期策略中的转换日期与物理转换的日期之间可能存在延迟。 但是，AWS会根据规则中指定的转换日期收取Glacier的价格。</li>
<li>开启版本控制的bucket<ul>
<li>Transition和Experition 都适合当前的版本</li>
<li>NoncurrentVersionTransition和NoncurrentVersionExpiration操作适用于非当前版本，其工作方式类似于未开启版本对象，但时间段是从对象变为非当前时间开始的</li>
</ul>
</li>
<li>过期规则<ul>
<li>未开启版本控制：对象永久删除</li>
<li>开启版本控制<ul>
<li>规则使用于current 对象，不影响任何非当前对象</li>
<li>S3将标记具有唯一ID的Delete Marker对象，并且先前的当前对象变为非当前版本</li>
<li>若当前对象已经有一个删除标记，将不会采取任何操作</li>
<li>如果bucket只有一个对象，并且已经标记删除（过期对象删除标记），S3移除删除标记</li>
</ul>
</li>
<li>版本控制suspend 桶<ul>
<li>S3将插入版本ID为null的Delete Marker标记，并覆盖版本ID为null的任何对象</li>
</ul>
</li>
</ul>
</li>
<li>当对象到达其生命周期的末尾时， S3将排队以进行删除并异步操作。 在到期日期和S3删除对象的日期之间可能存在延迟。不需要为与已过期的对象关联的存储时间付费。</li>
<li>如果生命周期策略置于STANDARD_IA中的对象不到30天，或者GLACIER少于90天，则会有额外的成本费用产生。</li>
</ol>
<h1 id="S3-Object-Versioning"><a href="#S3-Object-Versioning" class="headerlink" title="S3 Object Versioning"></a>S3 Object Versioning</h1><ul>
<li>版本控制可用于防止意外覆盖和删除数据</li>
<li>版本控制将对象多个不同版本保留在bucket中，用于保存历史版本，检索和还原对象的不同版本</li>
<li>由于版本控制保留了整个相同对象的多个副本，因此要为多个版本产生费用。 对于带有5个副本的1GB文件，如果存在细微的差异，则会消耗5GB的S3存储空间，并且需要支付相同5GB空间费用</li>
<li>默认情况下不启用版本控制，存储桶使用时要明确启用</li>
<li>版本一旦启用，无法禁用，只能暂停</li>
<li>Bucket启用版本控制，适用于存储桶中所有对象</li>
<li>权限在版本级别设置。 每个版本都有自己的对象所有者; AWS账户是创建对象版本所有者。 因此，可以为同一对象的不同版本设置不同的权限</li>
<li>无论如何控制版本，桶中每个对象都有一个版本<ul>
<li>未开启版本控制存储桶，每个对象的版本ID为null</li>
<li>开启版本控制的存储桶，每个对象分配唯一的版本ID</li>
</ul>
</li>
<li>版本控制，版本ID与桶名和对象key(键)一起构成一个唯一的key元素，用于定义桶中对象的唯一性</li>
<li>对象检索<ul>
<li>未开启版本控制存储桶：检索始终返回唯一的可用对象</li>
<li>开启版本控制的存储桶，返回当前对象，可以通过指定版本ID返回非当前对象</li>
</ul>
</li>
<li>对象添加<ul>
<li>未开启版本控制：再次上传相同键的对象，则会覆盖该对象</li>
<li>开启版本控制：上传相同键的对象，则新上传的将会成为当前版本，之前的成为非当前版本</li>
<li>可以检索和恢复非当前版本化对象，从而防止意外覆盖</li>
</ul>
</li>
<li>删除对象<ul>
<li>未开启版本控制：对象永久删除，且无法恢复</li>
<li>开启版本控制：所有对象都保留，Amazon会插入一个删除标记，用于标记当前版本；可以检索和恢复非当前版本对象，从而防止意外删除和覆盖；如果指定删除版本ID的对象，则会永久删除且无法恢复</li>
</ul>
</li>
<li>删除标记<ul>
<li>删除标记对象没有任何与之关联的数据或acl，只有key和版本ID</li>
<li>对已经使用删除标记的对象检索将返回404</li>
<li>已经标记“delete marker”对象上只允许DELETE操作</li>
<li>指定其版本ID删除标记对象，则先前的版本对象将成为当前版本对象</li>
<li>如果将DELETE标记作为当前版本在桶上触发DELETE请求，则不会删除DELETE标记，而是再次添加一个DELETE标记</li>
</ul>
</li>
<li>恢复之前版本<ul>
<li>将先前版本对象复制到同一存储桶中。复制的对象将成为该对象当前的版本，并保留之前的对象版本。（建议保留所有版本）</li>
<li>永久删除当前版本时，世纪将之前的版本转换为当前版本</li>
</ul>
</li>
<li>暂停版本控制<ul>
<li>可以暂停版本控制功能，以停止存储桶后续对象的积累新的版本</li>
<li>已存在的对象不会更改，只对新添加对象有效</li>
<li>对于每个新添加的对象，对象添加版本ID为null</li>
<li>对于具有相同key的对象添加，对象和版本ID（null）都会被覆盖</li>
<li>存储桶上的DELETE请求将永久删除版本ID空对象并插入删除标记</li>
<li>如果存储桶没有版本ID为null的对象，则DELETE请求不会删除任何内容</li>
<li>对于存储了版本ID的任何先前对象，仍然可以使用指定版本ID触发DELETE请求</li>
</ul>
</li>
<li>启用 MFA 删除<ul>
<li>启用MFA删除，可以提高起安全性</li>
<li>在存储桶上启用MFA删除，以确保不会意外删除存储桶中的数据</li>
<li>存储桶拥有者，创建存储桶（root帐户）的AWS账户以及所有授权的IAM用户可以启用版本控制，但只有存储桶拥有者（root帐户）可以启用MFA删除</li>
</ul>
</li>
</ul>
<h1 id="S3-Permission-权限"><a href="#S3-Permission-权限" class="headerlink" title="S3 Permission 权限"></a>S3 Permission 权限</h1><ul>
<li>默认情况下，所有S3 存储桶，对象和相关子资源都时私有的</li>
<li>可以通过AWS 账户或IAM（有权限）访问资源</li>
<li>存储拥有者时创建存储桶的AWS账户</li>
<li>对象所有者是将对象上载到存储桶的AWS账户，而不是该账户所拥有的存储桶</li>
<li>只有资源所有者（创建资源的AWS账户）才能访问该资源</li>
<li>资源所有者<ul>
<li>创建存储桶或对象的AWS账户时这些资源拥有者</li>
<li>如果IAM用户创建存储桶或对象，则IAM用户的AWS账户拥有该资源</li>
<li>如果存储桶拥有者向其他AWS账户用户授予跨对象权限以将对象上载到存储桶，则对象由上载对象的用户的AWS账户拥有，而不是存储桶拥有者，但以下条件除外<ul>
<li>存储桶拥有者可以拒绝访问该对象，因为它是支付该对象的存储桶拥有者</li>
<li>存储桶拥有者可以删除或应用存档规则到对象并执行恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="S3-权限分类"><a href="#S3-权限分类" class="headerlink" title="S3 权限分类"></a>S3 权限分类</h2><ul>
<li>基于资源的策略和用户策略</li>
</ul>
<h3 id="用户策略"><a href="#用户策略" class="headerlink" title="用户策略"></a>用户策略</h3><ul>
<li>基于用户的策略使用IAM和S3来控制用户或用户组对AWS账户拥有的S3存储桶的访问类型</li>
<li>基于用户的策略始终附加到用户，组或角色，无法授予匿名权限</li>
<li>如果拥有存储桶的AWS账户想要向其帐户中的用户授予权限，则可以使用存储桶策略或用户策略</li>
</ul>
<h3 id="资源策略"><a href="#资源策略" class="headerlink" title="资源策略"></a>资源策略</h3><ul>
<li>存储桶策略和访问控制列表（ACL）是基于资源的，因为它们附加到Amazon S3资源</li>
</ul>
<p><img src="https://i.loli.net/2019/08/19/qv6ix2mDjR4XkUS.jpg" alt="001.jpg"></p>
<ul>
<li>存储桶策略&amp;访问控制列表</li>
</ul>
<h3 id="存储桶策略"><a href="#存储桶策略" class="headerlink" title="存储桶策略"></a>存储桶策略</h3><ul>
<li>存储桶策略用于向其他AWS账户或IAM用户授予对其中的存储桶和对象的跨账户访问权限</li>
<li>桶策略提供集中的，基于各种条件，包括S3的操作，请求者，资源和方面请求的访问控制区和物件（例如IP地址）</li>
<li>如果拥有存储桶的AWS账户想要向其帐户中的用户授予权限，则可以使用存储桶策略或用户策略</li>
<li>附加到存储桶的权限适用于存储桶所有者创建和拥有的该存储桶中的所有对象</li>
<li>策略可以在存储桶中的所有（或子集）对象上添加或拒绝权限</li>
<li>仅允许存储桶拥有者将策略与存储桶关联</li>
<li>仅允许存储桶拥有者将策略与存储桶关联</li>
</ul>
<h3 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h3><ul>
<li>存储桶和对象都可以有与之相关联的ACL</li>
<li>ACL是一个授权列表，用于标识被授予者和授予的权限</li>
<li>ACL向其他账户授予对资源的基本读/写权限</li>
<li>ACL是一系列的受限的权限集，<ul>
<li>不能授予条件权限，</li>
<li>也不能显式拒绝权限</li>
<li>不能用于授予bucket子资源的权限</li>
</ul>
</li>
<li>可以通过电子邮件地址或规范用户ID（模糊匹配的帐户ID）向AWS账户授予权限。 如果提供了电子邮件地址，S3仍会找到该用户的规范用户ID并将其添加到ACL</li>
<li>建议使用规范的用户ID，电子邮件地址将来不会被支持</li>
</ul>
<h3 id="Bucket-ACL"><a href="#Bucket-ACL" class="headerlink" title="Bucket ACL"></a>Bucket ACL</h3><ul>
<li>仅推荐用于 bucket ACL的用例是向S3 Log Delivery组授予写入权限，以将访问日志对象写入存储区</li>
<li>如果存储桶需要访问日志传送，则bucket ACL将有助于将存储桶的写入权限授予日志传送组</li>
<li>只有这样才能通过bucket ACL为日志传送组授予必要的权限</li>
</ul>
<h3 id="Object-ACL"><a href="#Object-ACL" class="headerlink" title="Object ACL"></a>Object ACL</h3><ul>
<li>对象ACL仅控制对象级权限</li>
<li>对象ACL是管理不属于存储桶拥有者的存储桶中对象的权限的唯一方法，即如果存储桶拥有者允许跨帐户对象上载，并且对象所有者与存储桶拥有者不同，则对象的所有者授予对象的权限是通过对象ACL</li>
<li>如果存储桶和对象由同一AWS账户拥有，则可以使用存储桶策略来管理权限</li>
<li>如果对象和用户归同一AWS账户所有，则可以使用用户策略来管理权限</li>
</ul>
<h3 id="Amazon-S3-请求授权"><a href="#Amazon-S3-请求授权" class="headerlink" title="Amazon S3 请求授权"></a>Amazon S3 请求授权</h3><pre><code>当Amazon S3收到请求时，它将评估所有用户策略，存储桶策略和确定是否授权或拒绝该请求。</code></pre><p>S3将在3个方面进行策略评估</p>
<ul>
<li><p>User context 是S3评估AWS父账户（上下文）附加到用户策略的基本策略</p>
</li>
<li><p>Bucket context是S3评估存储桶所有者拥有访问策略的上下文，以检查存储桶所有者是否显式拒绝访问资源</p>
</li>
<li><p>Object context是是S3评估对象所有者拥有的策略的上下文</p>
<h3 id="类比场景"><a href="#类比场景" class="headerlink" title="类比场景"></a>类比场景</h3></li>
<li><p>假设有三个AWS账户，A、B、C且其子用户（IAM user）分别为AA、BA、CA</p>
</li>
<li><p>A账户拥有Toy bucket,其中存储对象Toy AAA,允许对象被删掉和创建</p>
</li>
<li><p>A账户创建一个授权，AA可以访问Toy bucket和其中对象（user policy或Bucket policy或两者都包含）</p>
</li>
<li><p>A创建一个授权（bucket policy），允许B可以创建对象在Toy bucket中；那么B可以授权其BA在Toy bucket中创建对象(如BAA)的策略（user policy）</p>
</li>
<li><p>B可以授权A访问Toy bucket中BAA的权限策略（object acl）</p>
</li>
<li><p>A创建一个授权（bucket policy）访问Toy bucket中AAA（object）的策略，而C又可以授权CA访问AAA的权限策略（user policy）</p>
</li>
<li><p>A 可以授权C访问BAA（object）的权限(IAM role）,而C又可以授权CA访问BAA的权限（user policy）</p>
</li>
</ul>
<h3 id="Bucket-操作授权"><a href="#Bucket-操作授权" class="headerlink" title="Bucket 操作授权"></a>Bucket 操作授权</h3><p><img src="https://i.loli.net/2019/08/19/k6UAI5Cyf87sE1P.jpg" alt="002.jpg"></p>
<ol>
<li>如果请求者是 IAM 用户，则该用户必须拥有来自其所属的父 AWS 账户的权限。在此步骤中，Amazon S3 将评估由父账户 (也称为上下文机构) 拥有的一个策略子集。该策略子集包含父账户附加到该用户的用户策略。如果父级也拥有请求中的资源 (在本例中为存储桶)，则 Amazon S3 还会同时评估相应资源策略 (存储桶策略和存储桶 ACL)。</li>
<li>请求者必须拥有来自存储桶拥有者的权限才能执行特定存储桶操作。在此步骤中，Amazon S3 对由拥有该存储桶的 AWS 账户拥有的策略子集进行评估。</li>
<li>存储桶拥有者可通过使用存储桶策略或存储桶 ACL 来授予权限</li>
</ol>
<h3 id="Object操作授权"><a href="#Object操作授权" class="headerlink" title="Object操作授权"></a>Object操作授权</h3><p> <img src="https://i.loli.net/2019/08/19/skd6nRq1mWagxoB.jpg" alt="003.jpg"></p>
<ol>
<li>如果请求者是 IAM 用户，则该用户必须拥有来自其所属的父 AWS 账户的权限</li>
<li>Amazon S3 会评估由父账户 (也称为上下文机构) 拥有的一个策略子集。该策略子集包含父级附加到该用户的用户策略。如果父级也拥有请求中的资源 (存储桶、对象)，则 Amazon S3 还会同时评估相应资源策略 (存储桶策略、存储桶 ACL 和对象 ACL)</li>
<li>在此上下文中，Amazon S3 评估拥有该存储桶的 AWS 账户所拥有的策略。如果拥有请求中的对象的 AWS 账户与存储桶拥有者不同，则 Amazon S3 会在存储桶上下文中检查策略，查看存储桶拥有者是否已显式拒绝对该对象的访问。如果对该对象设置了显式拒绝，则 Amazon S3不对请求授权。</li>
<li>请求者必须拥有来自对象拥有者的权限才能执行特定对象操作。在此步骤中，Amazon S3将评估对象 ACL</li>
</ol>
<h3 id="权限委派"><a href="#权限委派" class="headerlink" title="权限委派"></a>权限委派</h3><ul>
<li>如果AWS账户拥有资源，则可以将这些权限授予另一个AWS账户。</li>
<li>该帐户可以将这些权限或其中一部分委派给帐户中的用户。 这称为权限委派。</li>
<li>但是，从其他帐户接收权限的帐户无法将权限跨帐户委派给其他AWS账户。</li>
<li>如果Bucket所有者想要将不属于它的Object的权限授予其他AWS账户，则无法通过跨账户权限执行该操作，并且需要定义IAM角色，AWS账户可以采用该角色来获取访问权限</li>
</ul>
<h1 id="S3-Data-Protection"><a href="#S3-Data-Protection" class="headerlink" title="S3 Data Protection"></a>S3 Data Protection</h1><ul>
<li>Amazon S3 为任务关键型和主数据存储提供了高度耐用的存储基础设施。在 Amazon S3 区域，对象以冗余方式存储在多个设施间的多个设备中。</li>
<li>对象冗余地存储在S3区域中的多个设施上的多个设备上</li>
<li>为帮助确保数据持久性，Amazon S3 PUT 和 PUT Object copy 操作会在多个设施间同步完成之后，然后才会返回 SUCCESS</li>
<li>存储对象后，Amazon S3 将通过快速检测和修复任何丢失的冗余数据，保持对象的持久性</li>
<li>S3 还会使用校验和定期验证所存储数据的完整性。如果 Amazon S3 检测到数据损坏，它将使用冗<br>余的数据进行修复</li>
<li>Amazon S3 还会在存储或检索数据时对所有网络流量计算校验和，以检测数据包是否损坏</li>
<li>S3还提供保护传输中的数据（当它往返S3时）和静止存放（当它存储在S3中时）的能力</li>
</ul>
<h2 id="传输中的数据"><a href="#传输中的数据" class="headerlink" title="传输中的数据"></a>传输中的数据</h2><ul>
<li>通过SSL或使用客户端加密进行通信来保护传输中的数据</li>
</ul>
<h2 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h2><ul>
<li>支持客户端加密和服务器端加密，以保护静态数据</li>
<li>服务器端加密关乎静态数据加密，即 Amazon S3 将数据写入数据中心内的磁盘时会在对象级别上加密这些数据，并在访问这些数据时解密这些数据</li>
<li>使用客户端加密，可以加密客户端数据并将加密数据上传到S3。 在这种情况下，自行管理加密过程，加密密钥和相关工具</li>
</ul>
<h2 id="Server-side-加密"><a href="#Server-side-加密" class="headerlink" title="Server-side 加密"></a>Server-side 加密</h2><ul>
<li>服务器端加密关于静态数据加密</li>
<li>服务器端加密仅加密对象数据,对象元数据是不加密的</li>
<li>S3处理数据对象的加密（写入磁盘时）和解密（访问对象时）</li>
<li>加密或未加密对象的访问机制没有区别，并由S3透明处理</li>
</ul>
<h2 id="Server-Side-Encryption-with-Amazon-S3-Managed-Keys-SSE-S3"><a href="#Server-Side-Encryption-with-Amazon-S3-Managed-Keys-SSE-S3" class="headerlink" title="Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)"></a>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)</h2><ul>
<li><p>Amazon S3 托管加密密钥的服务器端加密 (SSE-S3) 采用了多因素强加密。S3 使用唯一的密钥来加密每个对象。作为额外的保护，它将使用定期轮换的主密钥对密钥本身进行加密。</p>
</li>
<li><p>S3 服务器端加密使用可用的最强数据块密码之一 (即 256 位高级加密标准 (AES-256))来加密数据</p>
</li>
<li><p>当使用预签名url上传对象时，不能强制使用SSE-S3加密对象，因为指定服务器端加密的惟一方法是通过AWS管理控制台或HTTP请求头<br>Server-Side Encryption with AWS KMS-Managed Keys (SSE-KMS)<br><img src="https://i.loli.net/2019/08/19/3Ekn2RjTqsCFVUW.jpg" alt="004.jpg"></p>
</li>
<li><p>SSE-KMS类似于SSE-S3，但它使用AWS Key Management Services（KMS），它提供额外的优势和性价比</p>
<ul>
<li>AWS Key Management Service (AWS KMS) 是一项将安全、高度可用的硬件和软件结合起来，提供可扩展到云的密钥管理系统的服务</li>
<li>KMS 使用用户主密钥 (CMK) 加密Amazon S3 对象</li>
<li>主密钥（master key）从不使用</li>
<li>KMS集中创建加密密钥，定义控制密钥使用方式的策略</li>
<li>通过检查AWS CloudTrail中的日志，审计使用密钥用法是否正确使用</li>
<li>允许临时禁用和重新启用密钥</li>
<li>允许key进行定期轮换</li>
<li>AWS KMS中的安全控制有助于满足与加密相关的合规性要求</li>
</ul>
</li>
<li><p>SSE-KMS为使用信封密钥（即保护数据加密密钥的密钥）启用单独的权限，从而提供额外的保护，防止在S3中对对象进行未经授权的访问</p>
</li>
<li><p>SSE-KMS提供了创建和管理加密密钥的选项，或者默认使用客户主密钥(CMK)，该主密钥可用于当前服务，并且所工作的区域是惟一的</p>
</li>
<li><p>创建自定义的CMK可提供更大灵活性，包括创建、轮换、禁用和定义访问控制，以及审核用于保护数据的加密密钥的能力</p>
</li>
<li><p>用于加密数据的数据密钥也会加密并与它们保护的数据一起存储，并且对每个对象都是唯一的</p>
</li>
<li><p>处理流程</p>
<ul>
<li>应用程序或AWS服务客户端请求加密密钥来加密数据，并将引用传递给帐户下的主密钥</li>
<li>验证客户端请求是否有权使用主密钥进行加密</li>
<li>创建新的<table><tr><td bgcolor="orange">数据加密密钥</td></tr></table>，并在<table><tr><td bgcolor="red">主密钥（CMK）</td></tr></table>下加密<table><tr><td bgcolor="orange">数据加密密钥</td></tr></table>（经过授权）</li>
<li>数据密钥和加密数据密钥都返回给客户端</li>
<li>数据密钥用于加密客户数据，建议在实际使用完加密密钥之后尽快将其从内存中删除</li>
<li>保留<table><tr><td bgcolor="orange">加密数据密钥</td></tr></table>以供以后使用，并在需要解密数据时将其发送回AWS KMS进行解密获取数据密钥<br>Server-Side Encryption with Customer-Provided Keys (SSE-C)<br><img src="https://i.loli.net/2019/08/19/KT7oy4njN6IH9Fb.jpg" alt="005.jpg"></li>
</ul>
</li>
<li><p>使用客户提供的加密密钥的服务器端加密 (SSE-C) 允许设置自己的加密密钥。</p>
</li>
<li><p>S3在访问对象时管理加密，写入磁盘和解密载对象时，加密密钥作为请求的一部分提供，S3使用该加密密钥对数据应用AES-256加密，并从内存中删除加密密钥</p>
</li>
<li><p>在检索对象时，必须提供相同的加密密钥作为请求的一部分。Amazon S3 在将对象数据返回之前，会首先验证提供的加密密钥是否匹配，然后再解密对象</p>
</li>
<li><p>每个对象，每个对象的版本可以使用不同的密钥进行加密，但需要自行负责维护对象和所使用的加密密钥之间的映射。</p>
</li>
<li><p>SSE-C请求必须通过HTTPS完成，S3将拒绝使用SSE-C时通过http发出的任何请求</p>
</li>
<li><p>出于安全原因，错误地使用 http 发送的任何密钥都将存在被外泄的可能性。此时应丢弃该密钥，并根据需要轮换密钥</p>
</li>
<li><p>S3 不存储加密密钥，而是存储加密密钥添加了随机数据的 HMAC 值来验证请求。无法使用添加了随机数据的 HMAC 值来推导出加密密钥的值或解密加密对象的内容。这意味着，如果丢失加密密钥，则会失去该对象</p>
</li>
</ul>
<h2 id="客户端加密"><a href="#客户端加密" class="headerlink" title="客户端加密"></a>客户端加密</h2><p>客户端加密是指在将数据发送到Amazon S3之前加密数据并在下载之后解密数据。</p>
<h2 id="使用-AWS-KMS-托管客户主密钥-CMK"><a href="#使用-AWS-KMS-托管客户主密钥-CMK" class="headerlink" title="使用 AWS KMS 托管客户主密钥 (CMK)"></a>使用 AWS KMS 托管客户主密钥 (CMK)</h2><ul>
<li>客户可以使用 AWS KMS 托管客户主密钥用于客户端数据加密时，此时使 AWS KMS 客户主密钥 ID (CMK ID)</li>
<li>上传对象时<ul>
<li>客户端首先将请求发送到 AWS Key Management Service (AWS KMS)以获取可用于加密对象数据的密钥</li>
<li>AWS KMS 将返回一个随机生成的数据加密密钥，其中包含客户端用于<table><tr><td bgcolor="orange">加密对象数据的纯文本版本</td></tr></table>和客户端将作为对象元数据上传到 Amazon S3 的<table><tr><td bgcolor="orange">同一数据加密密钥的密码 blob</td></tr></table></li>
<li>客户端将为其上传的每个对象获取一个唯一的数据加密密钥</li>
<li>AWS S3加密的客户端上载与对象元数据的加密数据和加密BLOB</li>
</ul>
</li>
<li>下载对象时<ul>
<li>客户端首先从 Amazon S3 下载加密的对象以及作为对象元数据存储的数据加密密钥的密blob 版本</li>
<li>客户端将密码 blob 发送到 AWS KMS 以获取密钥的纯文本版本，以便让客户端解密对象数据<br>使用客户端主密钥</li>
</ul>
</li>
<li>加密主密钥完全在客户端维护</li>
<li>上传对象时<ol>
<li>Amazon S3 加密客户端在本地生成一个一次性对称密钥 (也称为“数据加密密钥”或“数据密钥”)。它使用数据密钥加密单个 Amazon S3 对象的数据。该客户端将为每个对象生成一个单独的数据密钥。</li>
<li>该客户端使用主密钥来加密数据加密密钥。客户端会将加密的数据密钥及其材料说明作为对象元数据的一部分上传。</li>
<li>该客户端将加密数据上传到 Amazon S3 并在 Amazon S3 中将加密数据密钥保存为对象元数据 (xamz-meta-x-amz-key)</li>
</ol>
</li>
<li>下载对象时<ul>
<li>该客户端从 Amazon S3 下载加密的对象。</li>
<li>通过对象元数据中的说明，该客户端将确定要用于解密数据密钥的主密钥</li>
<li>该客户端将使用该主密钥解密数据密钥，然后使用该数据密钥对对象进行解密</li>
</ul>
</li>
<li>客户端主密钥和未加密的数据从来不会发送到 AWS。务必安全地管理加密密钥</li>
<li>如果丢失了加密密钥，将无法解密数据</li>
</ul>
<h1 id="S3-最佳实践"><a href="#S3-最佳实践" class="headerlink" title="S3 最佳实践"></a>S3 最佳实践</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="并发PUTS-GETS"><a href="#并发PUTS-GETS" class="headerlink" title="并发PUTS/GETS"></a>并发PUTS/GETS</h3><ul>
<li>Amazon S3 可进行扩展，以支持非常高的请求速率。如果请求速率稳定增长，则 Amazon S3 会自动根据需要将存储桶进行分区，以支持更高的请求速率</li>
<li>如果典型工作负载仅涉及每秒100个请求的偶尔突发和每秒少于800个请求，则AWS会自动进行扩展和处理</li>
<li>如果预计存储桶的请求速率会快速提高到超过每秒 300 个 PUT/LIST/DELETE 请求或超过每秒 800 个 GET 请求，建议申请support,以便为工作负载做好准备，并且避免对请求速率的任何临时限制</li>
<li>仅当每秒定期处理100个或更多请求时，才能应用S3最佳实践指南</li>
<li>混合请求类型的工作负载<ul>
<li>如果请求一般为 GET、PUT、DELETE 或 GET Bucket (列出对象) 的组合，则为对象合理选择键名称可缩短访问 Amazon S3 索引的延迟，从而确保实现更高的性能</li>
<li>这种方式是由S3 存储key驱动的<ul>
<li>Amazon S3 在每个 AWS 区域维护对象键名称的索引</li>
<li>对象键以 UTF-8 二进制顺序保存在索引的多个分区中，键名称指示用于存储键的分区</li>
<li>对于大量键，使用顺序前缀 (如时间戳或字母顺序) 可增大 Amazon S3以特定分区为目标的可能性，从而耗尽该分区的 I/O 容量。</li>
</ul>
</li>
<li>如果在键名称前缀中引入某种随机性，则键名称 (以及 I/O 负载) 会在多个分区间分布</li>
<li>无论每秒发送的请求数量如何，它还可确保可扩展性</li>
</ul>
</li>
<li>GET 密集型工作负载<ul>
<li>建议使用 Amazon CloudFront 内容传输服务</li>
<li>向用户分发内容时同时实现低延迟和高数据传输速率。另外可以减少向 Amazon S3 发送直接请求，从而降低成本</li>
<li>支持Web分发或RTMP分发<h3 id="PUTs-GETs-for-Large-Objects"><a href="#PUTs-GETs-for-Large-Objects" class="headerlink" title="PUTs/GETs for Large Objects"></a>PUTs/GETs for Large Objects</h3></li>
</ul>
</li>
<li>AWS支持并行化PUT / GET请求以提高上载和下载性能以及在失败时恢复的能力</li>
<li>对于上传，分段上传可以帮助改善上传体验<ul>
<li>同时执行多个上载并最大化网络带宽利用率</li>
<li>从故障中快速恢复，因为只有一部分上传失败需要重新上传</li>
<li>暂停和恢复上传的能力</li>
<li>在已知对象大小之前开始上载</li>
</ul>
</li>
<li>对于GET，range http标头可以帮助提高下载<ul>
<li>允许在部分而不是整个对象中检索对象</li>
<li>从故障中快速恢复，因为只有无法下载的部分需要重试</li>
</ul>
</li>
</ul>
<h2 id="List-Operations"><a href="#List-Operations" class="headerlink" title="List Operations"></a>List Operations</h2><ul>
<li>对象键(key)以字典顺序存储在Amazon S3索引中，因此很难对LIST的内容进行排序和操作</li>
<li>S3维护单个按字典顺序排序的索引列表</li>
<li>在S3之外构建和维护二级索引，例如 DynamoDB或RDS用于存储，索引和查询对象元数据，而不是在S3上执行操作</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>开启版本控制<ul>
<li>防止意外的覆盖和删除</li>
<li>允许检索和恢复已删除对象或回滚到以前版本的功能</li>
</ul>
</li>
<li>启用MFA（多重身份验证）删除来启用安全性</li>
<li>版本控制不会阻止Bucket删除，必须进行备份，就像意外或恶意删除数据一样</li>
<li>使用跨区域复制功能将数据备份到其他区域</li>
<li>将VPC与S3一起使用时，建议使用VPC S3端点<ul>
<li>是水平缩放，冗余和高可用性的VPC组件</li>
<li>帮助在VPC和S3之间建立专用连接，流量永远不会离开AWS网络</li>
</ul>
</li>
</ul>
<h2 id="Traking"><a href="#Traking" class="headerlink" title="Traking"></a>Traking</h2><ul>
<li>使用事件通知来通知S3put或delete请求</li>
<li>使用CloudTrail，便于 AWS账户捕获特定的API调用，并提供日志文件到一个S3桶</li>
<li>使用CloudWatch监控Amazon S3存储桶，跟踪存储的对象计数和字节等指标，并配置相应的操作</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/18/思考心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/思考心得/" itemprop="url">思考心得</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T18:29:45+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/思考心得/" itemprop="url" rel="index">
                    <span itemprop="name">思考心得</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="思考心得"><a href="#思考心得" class="headerlink" title="思考心得"></a>思考心得</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>架构的本质并非时要解决领域内的具体问题，而是复杂度管理，用于将所面对的复杂度客观对象。问题和解决方案的复杂度进行有效的分解和管理，并尽量减轻内外变化所产生影响。</li>
<li>领域问题的解决方案靠的时相关的解决方案，同样的一个问题可以有不同的解决方案，虽然他们的目标时一致的，但由于各架构的不同，各个结局方案的灵活性、坚固性和扩展性不同，因而我们在为解决方案选择架构的时候关注的并不是其是否可以解决问题，更多的是对架构所带来的灵活性、坚固性和扩展性于相应的成本之间进行权衡。</li>
</ul>
<ol>
<li>根据要解决的问题，对目标系统的边界进行界定</li>
<li>并对目标系统按某个原则进行切分。切分的原则，要适于不同的角色，对切分出来的部分，并行或串行开展工作，一般并行才能减少时间</li>
<li>并对切分出来的部分，设立沟通机制</li>
<li>根据3，使得这些部分之间能够进行有机联系，合并组装成为一个整体，完成目标系统所有工作<br>核心：对问题的分析，以及解决问题方案<br>目标问题是<font color="red">谁</font>的问题    问题的主体（隐含边界）<br>问题不是解决方案</li>
</ol>
<h3 id="企业架构"><a href="#企业架构" class="headerlink" title="企业架构"></a>企业架构</h3><ul>
<li><strong>物理架构</strong>：包括IDC机房、机房之间访问关系、机房内机器物理部署图、机房与业务分布、网络架构、数据库架构、集群清单和域名清单</li>
<li><strong>应用架构</strong>：应用+架构，应用时系统的最小单元，应用分类和应用编排则构成了应用关系即应用架构</li>
<li><strong>企业商务模型</strong>：静态商务业务主体、组织架构、动态的商务运作模型、业务流程</li>
<li><strong>信息系统模型</strong>：功能架构、应用架构、数据设计和物理架构</li>
</ul>
<blockquote>
<p>应用架构从单一应用角度出发，其主要时从应用的功能触发，即从应用的数据、展现方式和业务逻辑等方面来制定应用的结构和构造方法</p>
</blockquote>
<blockquote>
<p>企业架构则从企业战略和整体业务触发，从技术上制定用以支持企业和战略的各种应用、数据和基础设施</p>
</blockquote>
<p> <em>软件本身并不能解决企业问题，只有配套的架构、流程、制度与意识才能发挥软件的功效</em></p>
<ul>
<li>运维要为应用服务，应用要为业务服务，业务为客户服务</li>
</ul>
<h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><ul>
<li><p>与当前的<strong>传统客户</strong>谈PaaS，其不可避免的要谈到应用的解构和重构，而这是当前国内非常难做的，并不像IaaS基础资源已经融入到用户的实际生产、测试环境中。</p>
</li>
<li><p>开源社区做的是项目，不是产品，尤其不是企业级产品</p>
</li>
<li><p>私有云严格来说不是云，至少缺乏云应有的规模和弹性</p>
</li>
<li><p>现有的企业私有云或公有云一资源为中心，而PaaS要以应用为中心</p>
</li>
<li><p>伤员不能只是资源上云，上云更应是一种理念。上云至少还包括开发上云（面向云开发、DevOps、CI/CD）、应用上云（面向云定制应用的云上架构）</p>
</li>
<li><p>面向业务运维，而不是面向资源运维</p>
</li>
<li><p>企业用户需求：</p>
<ul>
<li>关注稳定、数据安全、现有DC打通、迁移成本、是否要更改应用架构才能上云、现有运维整合</li>
</ul>
</li>
<li><p>2B和2C产品经理区别：前者关注企业用户需求，后者关注产品运营、用户体验</p>
</li>
</ul>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>国内的互联网巨头成就了体量和估值，却没有创造出来真正的商业文明和伦理。</li>
<li>后摇，将这份寄生在我们身上的痛苦，化为一面镜子，我们赤裸地站在面前，审视在镜中同样赤裸的自己，打破、流血、痛哭、沉默、颓唐、寂灭，我们被迫接受现实，寄生于身上的痛苦，不过是被生命的贪婪所灼伤。</li>
<li>骄傲是对自己拥有某一方面突出价值的确信，但虚荣则试图在别人那里唤起自己对此的确信。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/18/AWS-RDS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/AWS-RDS/" itemprop="url">AWS RDS </a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T10:39:26+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AWS-Relation-Database-Service"><a href="#AWS-Relation-Database-Service" class="headerlink" title="AWS Relation Database Service"></a>AWS Relation Database Service</h1><ul>
<li>Amazon Relational Database Service (Amazon RDS) 是一项 Web 服务，让用户能够在云中更轻松地设置、操作和扩展关系数据库。</li>
<li>它可以经济有效的为用户提供一个容量可调的行业标准的关系数据库，并承担常见的数据库管理任务。</li>
<li>RDS 功能及优势<ul>
<li>CPU，内存，存储和IOPS可以独立扩展</li>
<li>Amazon RDS 可以管理备份、软件修补、自动故障检测和恢复</li>
<li>可以在需要时执行自动备份，也可以手动创建备份快照。可以使用这些备份还原数据库。Amazon RDS 还原过程将可靠且高效地工作</li>
<li>通过主实例和在发生问题时可向其执行故障转移操作的同步辅助实例实现高可用性。还可以使用 MySQL、MariaDB 或 PostgreSQL 只读副本扩展读取, 从而提供弹性和可伸缩性。</li>
<li>支持MySQL，MariaDB，PostgreSQL，Oracle，Microsoft SQL Server以及与MySQL兼容的全新Amazon Aurora数据库引擎</li>
<li>除了数据库包中的安全性之外，IAM用户和权限还可以帮助控制谁有权访问RDS数据库服务</li>
<li>数据库可以通过将它们放在VPC中进行进一步保护，使用SSL传输数据并对其余数据进行加密</li>
<li>由于它是托管服务，因此不提供对数据库实例的shell（root ssh）访问，这限制了对需要高级权限的某些系统过程和表的访问</li>
</ul>
</li>
</ul>
<h2 id="RDS-Components"><a href="#RDS-Components" class="headerlink" title="RDS Components"></a>RDS Components</h2><h3 id="DB-Instance"><a href="#DB-Instance" class="headerlink" title="DB Instance"></a>DB Instance</h3><ul>
<li>数据库实例的基本构建块</li>
<li>数据库实例是在云中运行的独立数据库环境</li>
<li>每个数据库实例均运行一个数据库引擎。Amazon RDS 当前支持 MySQL、MariaDB、PostgreSQL、Oracle 和 Microsoft SQL Server 数据库引擎</li>
<li>AWS Command Line Interface、Amazon RDS、API 或 AWS 管理控制台 创建和修改数据库实例</li>
<li>数据库实例的计算和内存容量由数据库实例类决定。选择最能满足需求的数据库实例。</li>
<li>数据库实例存储有三种类型：磁性、通用型 (SSD) 和配置的 IOPS (PIOPS)</li>
<li><font color="red">对于每个数据库实例，可以选择5 GB到6 TB的关联存储容量（会时常更新，目前最大容量可达64TB）</font></li>
<li>每个数据库实例都有一个数据库实例标识符，该标识符是客户提供的名称，对于AWS区域中的该客户必须是唯一的。它在与Amazon RDS API和AWS CLI命令交互时唯一标识数据库实例</li>
<li>每个数据库实例可以托管多个数据库，也可以托管具有多个模式的单个Oracle数据库。</li>
<li>建议托管在AWS VPC环境中以获得更好的控制</li>
</ul>
<h3 id="区域和可用区"><a href="#区域和可用区" class="headerlink" title="区域和可用区"></a>区域和可用区</h3><ul>
<li>Amazon 云计算资源安置在世界不同地区 (例如：北美、欧洲或亚洲) 的高度可用的数据中心设施内。每个数据中心位置称为一个地区</li>
<li>每个地区包含很多称为可用区或 AZ 的不同位置。每个可用区都被设计成不受其他可用区故障的影响，并提供低价、低延迟的网络连接，以连接到同一地区其他可用区。</li>
<li>可以在多个可用区运行数据库实例，此选项称为多可用区部署。<ul>
<li>Amazon 会自动在不同的可用区预配置和维护辅助备用数据库实例</li>
<li>主数据库实例可以跨可用区同步复制到辅助实例，从而在系统备份期间提供数据冗余、故障转移支持、消除 I/O 冻结和最大程度地降低延迟峰值</li>
</ul>
</li>
<li>安全组<ul>
<li>安全组通过允许访问指定的IP地址范围或EC2实例来控制对数据库实例的访问</li>
</ul>
</li>
<li>DB 参数组<ul>
<li>包含可应用于同一实例类型的一个或多个数据库实例的引擎配置值</li>
</ul>
</li>
<li>DB选项组<ul>
<li>一些数据库引擎提供的工具可以简化数据库管理并为数据库提供更多安全保护。</li>
<li>亚马逊RDS通过选项组提供此类工具，例如 Oracle Application Express（APEX），SQL Server透明数据加密和MySQL memcached支持</li>
</ul>
</li>
<li>RDS  接口<ul>
<li>AWS RDS 控制台</li>
<li>CLI</li>
<li>SDK、RDS API</li>
</ul>
</li>
</ul>
<h1 id="RDS-Replication-–-Multi-AZ-amp-Read-Replica"><a href="#RDS-Replication-–-Multi-AZ-amp-Read-Replica" class="headerlink" title="RDS Replication – Multi-AZ &amp; Read Replica"></a>RDS Replication – Multi-AZ &amp; Read Replica</h1><ul>
<li>数据库实例副本可通过多可用区部署或只读副本方式创建</li>
<li>多可用区部署<ul>
<li>多可用区部署提供高可用性和故障转移支持</li>
<li>RDS自动在不同的AZ（物理上独立的位置中的独立基础架构）中配置和管理同步备用副本</li>
<li>RDS会自动故障转移到备用数据库，以便数据库操作可以在没有干预的情况下快速恢复<ol>
<li>计划数据库维护</li>
<li>软件修补</li>
<li>重新启动主实例</li>
<li>主数据库实例连接或主机故障，或</li>
<li>可用区失败</li>
</ol>
</li>
</ul>
</li>
<li>只读副本<ul>
<li>Amazon RDS 还使用 MariaDB、MySQL、Oracle 和 PostgreSQL 数据库引擎的内置复制功能来从源数据库实例创建一个特殊类型的数据库实例，称为只读副本</li>
<li>对源数据库实例的更新将异步复制到只读副本。可以将应用程序发出的读取查询路由到只读副本，以减轻源数据库实例上的负载。</li>
<li>利用只读副本，可针对进行大量读取操作的数据库负载灵活地进行扩展，突破单个数据库实例的容量限制。</li>
</ul>
</li>
</ul>
<h2 id="Multi-AZ-deployment"><a href="#Multi-AZ-deployment" class="headerlink" title="Multi-AZ deployment"></a>Multi-AZ deployment</h2><ul>
<li>Amazon RDS 使用多可用区部署为数据库实例提供高可用性和故障转移支持。Amazon RDS 使用几种不同的技术来提供故障转移支持。用于 Oracle、PostgreSQL、MySQL 和 MariaDB 数据库实例的多可用区部署使用 Amazon 的故障转移技术。SQL Server 数据库实例使用 SQL Server 数据库镜像 (DBM)</li>
<li>高可用性功能不是面向只读情况的扩展解决方案；不能使用备用副本处理读取流量。要处理只读流量，应当使用只读副本</li>
<li>Multi-AZ 部署<ul>
<li>在多可用区部署中，Amazon RDS 会自动在不同可用区中配置和维护一个同步备用副本</li>
<li>主数据库实例将跨可用区同步复制到备用副本，以提供数据冗余、消除 I/O 冻结并在系统备份期间将延迟峰值降至最小</li>
<li>与单可用区部署相比，使用多可用区部署的数据库实例由于执行同步数据复制，因此会增加写入和提交延迟</li>
<li>仅当主数据库和备用数据库上的提交都成功时，才会返回事务成功</li>
<li>尽管 AWS 设计用于处理可用区之间的低延迟网络连接，但如果、部署故障转移到备用副本，延迟可能会发生更改</li>
</ul>
</li>
<li>使用BYOL许可模型时，需要主实例和备用副本的许可证</li>
<li>对于生产工作负载，建议使用具有预配置IOPS和数据库实例类（m1.large和更大）的多可用区部署，针对预配置IOPS进行了优化，以实现快速，一致的性能</li>
<li>将单可用区部署修改为多可用区部署时（对于SQL Server或Amazon Aurora以外的引擎）<ol>
<li>Amazon RDS拍摄主数据库实例的快照，然后将该快照还原到另一个可用区。</li>
<li>Amazon RDS 在主数据库实例与新实例之间设置同步复制</li>
<li>避免在从单可用区转换到多可用区时出现停机，但会在首次转换到多可用区时体验明显的性能影响。对于大型写入密集型数据库实例来说，此影响更明显</li>
</ol>
</li>
</ul>
<h2 id="RDS-Multi-AZ-Failover-Process"><a href="#RDS-Multi-AZ-Failover-Process" class="headerlink" title="RDS Multi-AZ Failover Process"></a>RDS Multi-AZ Failover Process</h2><ul>
<li>数据库实例发生计划内或计划外的中断时，对已启用多可用区，则 Amazon RDS 会自动切换到另一个可用区中的备用副本</li>
<li>完成故障转移所用的时间取决于在主数据库实例变为不可用时的数据库活动和其他条件。故障转移时间通常为 60-120 秒</li>
<li>故障转移机制自动更改数据库实例的 DNS 记录，使其指向备用数据库实例</li>
<li>多可用区切换与应用程序无缝连接，因为端点URL没有变化，只需要重新建立与数据库实例的任何现有连接</li>
<li>Amazon RDS 会自动处理故障转移，因此，可以尽快恢复数据库操作而无需管理干预。如果出现以下任一情况，主数据库实例会自动切换到备用副本：<ul>
<li>可用区中断</li>
<li>主数据库实例故障</li>
<li>更改数据库实例服务器类型</li>
<li>数据库实例的操作系统在进行软件修补</li>
<li>数据库实例的手动故障转移是使用 Reboot with failover 启动的</li>
</ul>
</li>
<li>可通过多种方法确定多可用区数据库实例是否进行了故障转移：<ul>
<li>数据库事件订阅可设置为在故障转移启动时向发送电子邮件或 SMS 通知。</li>
<li>使用 Amazon RDS 控制台或 API 操作查看数据库事件。</li>
<li>使用 Amazon RDS 控制台 API 操作查看多可用区部署的当前状态</li>
</ul>
</li>
</ul>
<h2 id="Read-Replica"><a href="#Read-Replica" class="headerlink" title="Read Replica"></a>Read Replica</h2><ul>
<li>Amazon RDS 还使用 MariaDB、MySQL、Oracle 和 PostgreSQL 数据库引擎的内置复制功能来从源数据库实例创建一个特殊类型的数据库实例，称为只读副本</li>
<li>对源数据库实例的更新将异步复制到只读副本</li>
<li>将应用程序发出的读取查询路由到只读副本，以减轻源数据库实例上的负载</li>
<li>利用只读副本，可针对进行大量读取操作的数据库负载灵活地进行扩展，突破单个数据库实例的容量限制</li>
<li>只读副本作为允许只读连接的数据库实例运行; 应用程序可以像对任何数据库实例一样连接到只读副本</li>
</ul>
<h3 id="Read-Replica-creation"><a href="#Read-Replica-creation" class="headerlink" title="Read  Replica creation"></a>Read  Replica creation</h3><ul>
<li>一个源数据库实例最多可以创建五个只读副本</li>
<li>创建只读副本过程<ol>
<li>先通过将备份保留期设置为一个非零值来在源数据库实例上启用自动备份</li>
<li>需要将现有数据库实例指定为源</li>
<li>RDS获取源实例的快照，并从快照创建只读实例</li>
<li>然后，RDS使用数据库引擎的异步复制方法更新只读副本以获取对源数据库实例的任何更改</li>
</ol>
</li>
<li>RDS复制源数据库实例中的所有数据实例</li>
<li>如果只读副本位于与数据库实例不同的AWS区域中，则RDS会在源数据库实例与只读副本之间建立安全通信通道</li>
<li>RDS建立启用安全通道所需的任何AWS安全配置，例如添加安全组</li>
<li>在只读副本创建期间，可以在发生数据库快照时体验源数据库实例上的简短I / O挂起</li>
<li>I / O暂停通常持续大约一分钟，如果源数据库实例是多可用区部署，则可以避免（在多可用区部署的情况下，数据库快照是从备用数据库获取的）</li>
<li>长时间运行的活动事务会减慢创建只读副本的过程。建议等待长时间运行的事务完成，然后再创建只读副本。</li>
<li>如果从同一源数据库实例同时创建多个并行只读副本，则 Amazon RDS 仅在开始第一个创建操作时创建一张快照</li>
<li>可以将只读副本提升为新的独立源数据库，在这种情况下，只读副本和源数据库之间的复制链接会断开。 但是，使用原始源DB作为复制源继续复制其他副本</li>
</ul>
<h3 id="Read-Replica-Deletion-amp-DB-Failover"><a href="#Read-Replica-Deletion-amp-DB-Failover" class="headerlink" title="Read Replica Deletion&amp; DB Failover"></a>Read Replica Deletion&amp; DB Failover</h3><ul>
<li>只读副本删除，必须采用与数据库实例一样的显式删除方法</li>
<li>若删除源数据库而不删除副本，则会将每个副本提升为可用区内独立的数据库实例</li>
<li>若multi-az部署的源实例故障转移到备用数据库，则会切换源实例的关联副本到备用数据库上（作为新的源）</li>
</ul>
<h3 id="Read-Replica-Storage-amp-Compute-requirements"><a href="#Read-Replica-Storage-amp-Compute-requirements" class="headerlink" title="Read Replica Storage &amp; Compute requirements"></a>Read Replica Storage &amp; Compute requirements</h3><ul>
<li>默认情况下，使用与源数据库实例相同的存储类型创建只读副本</li>
<li>为使复制有效运行，每个只读副本应具有与源数据库实例相同数量的计算和存储资源</li>
<li>源数据库实例，如果缩放，则应相应地缩放只读副本</li>
</ul>
<h3 id="Read-Replica-Features-amp-Limitations"><a href="#Read-Replica-Features-amp-Limitations" class="headerlink" title="Read Replica Features &amp; Limitations"></a>Read Replica Features &amp; Limitations</h3><ul>
<li>RDS不支持循坏复制</li>
<li>只能从现有数据库实例创建新的只读副本，例如，如果MyDBInstance复制到ReadReplica1，则无法将ReadReplica1配置为复制回MyDBInstance。 从ReadReplica1，只能创建一个新的只读副本，例如ReadRep2</li>
<li>跨区域复制<ul>
<li>只有在使用 MariaDB、PostgreSQL (版本 9.4.7 和 9.5.2 和更高版本) 或 MySQL 5.6 和更高版本的 Amazon RDS 数据库实例时，才能在区域之间进行复制</li>
<li>灾难恢复功能（减少RTO和RPO）</li>
<li>将操作扩展到更接近最终用户的区域，</li>
<li>从一个地区的数据中心迁移到另一个地区</li>
</ul>
</li>
<li>也可以从其他只读副本创建只读副本。 但是，这些实例的副本滞后更高，并且复制链中涉及的实例不能超过四个。</li>
</ul>
<h3 id="RDS-不同引擎的只读副本区别"><a href="#RDS-不同引擎的只读副本区别" class="headerlink" title="RDS 不同引擎的只读副本区别"></a>RDS 不同引擎的只读副本区别</h3><table>
<thead>
<tr>
<th>操作</th>
<th>MySQL 和 MariaDB</th>
<th>Oracle</th>
<th>PostgreSQL</th>
</tr>
</thead>
<tbody><tr>
<td>复制方法是什么？</td>
<td>逻辑复制。</td>
<td>物理复制。</td>
<td>物理复制。</td>
</tr>
<tr>
<td>如何清除事务日志？</td>
<td>Amazon RDS MySQL 和 MariaDB 保留尚未应用的任何二进制日志。</td>
<td>Amazon RDS for Oracle 在源数据库实例中保留至少两个小时的事务日志。两小时之后或在传递 archivelog retention hours 设置之后从源中清除日志，以时间较长者为准。传递 archivelog retention hours 设置之后，仅当它们已成功应用到数据库时，才会从只读副本清除日志。有关设置 archivelog retention hours 的信息，请参阅 保留存档重做日志。</td>
<td>PostgreSQL 具有参数 wal_keep_segments，该参数指示保留多少个提前写入日志 (WAL) 文件以便为只读副本提供数据。该参数值指定要保留的日志的数量。</td>
</tr>
<tr>
<td>是否能将副本设置为可写？</td>
<td>是。 可将 MySQL 或 MariaDB 只读副本设置为可写。</td>
<td>否。Oracle 只读副本是物理副本，Oracle 不允许写入只读副本。可以提升只读副本以将它设置为可写。提升的只读副本拥有提出提升请求时的已复制数据。</td>
<td>否。PostgreSQL 只读副本是一个物理副本，PostgreSQL 不允许将只读副本设置为可写。</td>
</tr>
<tr>
<td>是否能在副本上执行备份？</td>
<td>是。可以对 MySQL 或 MariaDB 只读副本启用自动备份。</td>
<td>否。不能创建 Amazon RDS for Oracle 只读副本的手动快照或为它们启用自动备份。</td>
<td>是，可以创建 PostgreSQL 只读副本的手动快照，但无法启用自动备份。</td>
</tr>
<tr>
<td>是否能使用并行复制？</td>
<td>是。MySQL 5.6 版和更高版本和所有支持的 MariaDB 版本允许并行复制线程。</td>
<td>是。重做日志数据始终会从源数据库并行传输到其所有只读副本。</td>
<td>否。PostgreSQL 是一个处理复制的过程。</td>
</tr>
</tbody></table>
<h3 id="Read-Replica-Use-cases"><a href="#Read-Replica-Use-cases" class="headerlink" title="Read Replica Use cases"></a>Read Replica Use cases</h3><ul>
<li>为读取繁重的数据库工作负载扩展超出单个数据库实例的计算或I / O容量，将过多的读取流量引导到只读副本</li>
<li>在源数据库实例不可用时提供读取流量，例如 如果源数据库实例由于备份I / O挂起或计划维护而无法接收I / O请求，则可以将读取流量定向到只读副本。（此时 数据可能是陈旧的）</li>
<li>业务报告或数据仓库方案，可以对只读副本而不是主要生产数据库实例执行业务报告查询</li>
</ul>
<h1 id="RDS-Storage"><a href="#RDS-Storage" class="headerlink" title="RDS Storage"></a>RDS Storage</h1><ul>
<li>RDS使用EBS存储数据库数据和日志</li>
<li>RDS会自动对多个EBS卷进行条带化，以提高IOPS性能，具体取决于所请求的存储量</li>
</ul>
<h2 id="RDS-Storage-Types"><a href="#RDS-Storage-Types" class="headerlink" title="RDS Storage Types"></a>RDS Storage Types</h2><ul>
<li>RDS 提供三个存储类型：通用型 SSD（也称为 gp2）、预配置 IOPS SSD（也称为 io1）和磁性存储</li>
<li>它们的性能特性和价格不同，这意味着可以根据数据库工作负载需求定制存储性能和成本</li>
<li>以创建最多具有 64 TiB 存储的 MySQL、MariaDB 和 PostgreSQL RDS 数据库实例。最多可以创建具有 64 TiB 存储的 Oracle RDS 数据库实例。可以创建最多具有 16 TiB 存储的 SQL Server RDS 数据库实例。对于此存储量，请使用预配置 IOPS SSD 和通用型 (SSD) 存储类型</li>
</ul>
<h2 id="Magnetic-Standard"><a href="#Magnetic-Standard" class="headerlink" title="Magnetic (Standard)"></a>Magnetic (Standard)</h2><ul>
<li>磁存储，也称为标准存储，提供经济高效的存储，目前AWS建议使用SSD或预配IOPS类型</li>
<li>不允许使用 SQL Server 数据库引擎时扩展存储</li>
<li>不支持弹性卷。</li>
<li>限制为 3 TiB 的最大大小</li>
<li>限制为最大 1,000 IOPS</li>
</ul>
<h2 id="General-Purpose-SSD"><a href="#General-Purpose-SSD" class="headerlink" title="General Purpose (SSD)"></a>General Purpose (SSD)</h2><ul>
<li>通用型 SSD（也称作 gp2）卷提供了适用于各种工作负载的经济高效的存储。这些卷可以提供几毫秒的延迟，能够突增至 3000 IOPS 并维持一段较长的时间</li>
<li>MariaDB、MySQL 和 PostgreSQL 数据库实例：20 GiB–64 TiB</li>
<li>SQL Server for Enterprise、Standard、Web 和 Express 版本：20 GiB–16 TiB</li>
<li>Oracle 实例：20 GiB- 64 TiB</li>
<li>非常适合中小型数据库</li>
</ul>
<h2 id="Provisioned-IOPS"><a href="#Provisioned-IOPS" class="headerlink" title="Provisioned IOPS"></a>Provisioned IOPS</h2><ul>
<li>预配置 IOPS 存储符合 I/O 密集型工作负载（尤其是数据库工作负载）的需求，此类工作负载需要低 I/O 延迟和一致的 I/O 吞吐量</li>
<li>提供了可预测的性能以及一致的低延迟</li>
<li>需要快速且一致的I / O性能的任何生产应用程序，Amazon建议使用预配置IOPS存储类型</li>
<li>预配置的 IOPS 存储针对性能要求一致的联机事务处理 (OLTP) 工作负载进行了优化</li>
<li>下表显示每个数据库引擎的预配置 IOPS 的范围和存储大小范围</li>
</ul>
<table>
<thead>
<tr>
<th>数据库引擎</th>
<th>预配置的 IOPS 的范围</th>
<th>存储的范围</th>
</tr>
</thead>
<tbody><tr>
<td>MariaDB</td>
<td>1000–80000 IOPS</td>
<td>100 GiB–64 TiB</td>
</tr>
<tr>
<td>SQL Server、Enterprise 和 Standard 版本</td>
<td>1000–64000 IOPS*</td>
<td>20 GiB–16 TiB</td>
</tr>
<tr>
<td>SQL Server，Web 和 Express 版本</td>
<td>1000–64000 IOPS*</td>
<td>100 GiB–16 TiB</td>
</tr>
<tr>
<td>MySQL</td>
<td>1000–80000 IOPS</td>
<td>100 GiB–64 TiB</td>
</tr>
<tr>
<td>Oracle</td>
<td>1000–80000 IOPS</td>
<td>100 GiB– 64 TiB</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>1000–80000 IOPS</td>
<td>100 GiB–64 TiB</td>
</tr>
</tbody></table>
<blockquote>
<p>** 最大 IOPS 64000 仅在基于 Nitro 的实例（m5 实例类型）上是可保证的。其他实例系列可确保最高 32000 IOPS 的性能 ** </p>
<ul>
<li>创建数据库实例时，指定专用IOPS速率和存储空间分配。 RDS规定IOPS速率和存储在数据库实例的生命周期内或直到其更改。</li>
</ul>
</blockquote>
<h2 id="Adding-Storage-and-Changing-Storage-Type"><a href="#Adding-Storage-and-Changing-Storage-Type" class="headerlink" title="Adding Storage and Changing Storage Type"></a>Adding Storage and Changing Storage Type</h2><ul>
<li>可以修改数据库实例以使用其他存储并转换为不同的存储类型。但是，不能减少分配的存储空间（增大可以，缩小不可以）</li>
<li>MySQL，MariaDB，PostgreSQL和Oracle数据库实例可以扩展存储，这有助于提高I / O容量</li>
<li>由于附加到Windows Server环境的条带存储的可扩展性限制，可以更改SQL Server数据库实例的存储容量和存储类型</li>
<li>扩展过程中，数据库实例可用于读取和写入，但可能会出现性能下降</li>
<li>添加存储可能需要几个小时;过程的持续时间取决于几个因素，例如负载，存储大小，存储类型，配置的IOPS数量（如果有）以及先前规模存储操作的数量</li>
<li>在添加存储时，会暂停每夜备份，并且不会执行任何其他RDS操作，包括修改，重新引导，删除，创建只读副本和创建数据库快照</li>
</ul>
<h2 id="Performance-Metrics"><a href="#Performance-Metrics" class="headerlink" title="Performance Metrics"></a>Performance Metrics</h2><p>Amazon RDS提供了多个指标，可用于监控数据库的性能<br><strong>IOPS</strong></p>
<ul>
<li>每秒完成的I / O操作数</li>
<li>它被报告为给定时间间隔的平均IOPS</li>
<li>RDS每隔一分钟报告一次读写IOPS</li>
<li>总IOPS是读写IOPS的总和</li>
<li>IOPS的典型值范围为每秒零到几万<br><strong>Latency</strong></li>
<li>提交I / O请求到完成之间经过的时间</li>
<li>它被报告为给定时间间隔的平均延迟。</li>
<li>RDS以一分钟为单位分别报告读取和写入延迟，单位为秒</li>
<li>延迟的典型值以毫秒（ms）为单位<br><strong>Throughput</strong></li>
<li>传输到磁盘或从磁盘传输的每秒字节数</li>
<li>它被报告为给定时间间隔的平均吞吐量</li>
<li>RDS使用每秒兆字节（MB / s）的单位分别以一分钟的间隔报告读写吞吐量</li>
<li>吞吐量的典型值范围从零到I / O通道的最大带宽<br><strong>Queue Depth</strong></li>
<li>队列中等待服务的I / O请求数。</li>
<li>这些是由应用程序提交但尚未发送到设备的I / O请求，因为设备正在忙于处理其他I / O请求。</li>
<li>它被报告为给定时间间隔的平均队列深度。</li>
<li>RDS以一分钟为间隔报告队列深度。队列深度的典型值范围从零到几百。</li>
<li>在队列中等待的时间是Latency和服务时间（不作为指标）</li>
</ul>
<h2 id="Amazon-RDS-Storage-Facts"><a href="#Amazon-RDS-Storage-Facts" class="headerlink" title="Amazon RDS Storage Facts"></a>Amazon RDS Storage Facts</h2><ul>
<li>第一次启动数据库实例并首次访问磁盘区域时，该进程可能比对同一磁盘区域的所有后续访问花费的时间更长。这被称为“first touch penalty”。一旦磁盘区域产生了“first touch penalty”，即使数据库实例重新启动，重新启动或数据库实例类发生更改，该磁盘区域也不会在实例的生命周期内再次受到惩罚。请注意，从快照，时间点恢复或只读副本创建的数据库实例是新实例，并且会导致此“first touch penalty</li>
<li>RDS管理DB实例，并在实例上保留开销空间。如果预留的存储量随DB实例类和其他因素而变化，那么这个预留空间可能是总存储的1%或2%</li>
<li>预配置IOPS提供了一种通过指定IOPS来保留I / O容量的方法。与任何其他系统容量属性一样，负载下的最大吞吐量将受到首先消耗的资源的约束，这可能是IOPS，通道带宽，CPU，内存或数据库内部资源。</li>
<li>当前可用的最大信道带宽是4000兆比特每秒（Mbps）全双工。就读取和写入吞吐量度量而言，这相当于每个方向上大约210兆字节/秒（MB / s）。 50％读取和50％写入的完美平衡工作负载可以达到420 MB / s的最大组合吞吐量，其中包括协议开销，因此实际数据吞吐量可能更低。</li>
<li>预配置IOPS的I / O请求大小为32 KB。预配置IOPS消耗是I / O请求大小超过32 KB的线性函数。小于32 KB的I / O请求作为一个I / O处理;例如1000 16 KB I / O请求的处理方式与1000 32 KB请求相同。大于32 KB的I / O请求会消耗多个I / O请求;而48 KB I / O请求消耗1.5个I / O存储容量请求; 64 KB I / O请求消耗2个I / O请求</li>
</ul>
<h2 id="Factors-That-Impact-Storage-Performance"><a href="#Factors-That-Impact-Storage-Performance" class="headerlink" title="Factors That Impact Storage Performance"></a>Factors That Impact Storage Performance</h2><ul>
<li>系统活动和数据库工作负载均可能影响存储性能</li>
<li>系统活动，以下系统相关活动圴使用 I/O 容量，并且可能会在执行这些活动时降低数据库实例性能：<ul>
<li>多可用区备用创建</li>
<li>创建只读副本</li>
<li>创建存储类型</li>
</ul>
</li>
<li>数据库工作负载，数据库或应用程序设计导致并发问题、锁定或其他形式的数据库争用。在这类情况下，可能无法直接使用所有预配置的带宽<ul>
<li>已到达基础实例类型的吞吐量限制。</li>
<li>因为应用程序没有驱动足够的 I/O 操作，所以少于队列深度始终小于 1</li>
<li>在数据库中遇到查询争用，即使部分 I/O 容量未使用也是如此</li>
</ul>
</li>
</ul>
<h1 id="RDS-Snapshots-Backup-amp-Restore"><a href="#RDS-Snapshots-Backup-amp-Restore" class="headerlink" title="RDS Snapshots, Backup &amp; Restore"></a>RDS Snapshots, Backup &amp; Restore</h1><ul>
<li>RDS创建数据库实例的存储卷快照，备份整个数据库实例，而不仅仅是单个数据库。</li>
<li>RDS提供了两种不同的自动和手动方法来备份数据库实例：</li>
</ul>
<h2 id="Automated-backups"><a href="#Automated-backups" class="headerlink" title="Automated backups"></a>Automated backups</h2><ul>
<li>将自动创建并保留数据库实例的备份</li>
<li>默认情况下，为新数据库实例启用自动备份</li>
<li>自动备份在每日用户可配置的时间段内发生，称为首选备份窗口<ul>
<li>如果在创建数据库实例时未指定首选备份窗口，则RDS会分配默认的30分钟备份窗口，该窗口是从每个区域的8小时时间块中随机选择的</li>
<li>对备份窗口的更改会立即生效</li>
<li>备份窗口不能与数据库实例的每周维护窗口重叠</li>
</ul>
</li>
<li>创建数据库实例时设置备份保留期。如果未设置备份保留期，则在使用 Amazon RDS API 或 AWS CLI 创建数据库实例时，默认备份保留期为一天。如果使用控制台创建数据库实例，默认备份保留期为七天。创建数据库实例后，可以修改备份保留期。可以将备份保留期设置为在 0 到 35 天之间。要禁用自动备份，请将备份保留期设置为 0</li>
<li>手动快照限制 (每个区域 100 个) 不适用于自动备份</li>
<li>如果更改备份保留期，则会立即发生中断</li>
<li>RDS将周期性数据备份与事务日志结合使用，以便在保留期内将数据库实例恢复到任何秒，直到LatestRestorableTime（通常直到最后几分钟）。</li>
<li>在备份窗口期间，<ul>
<li>对于单个AZ实例，可能会在备份过程初始化（通常在几秒钟内）时暂时暂停存储I / O，并且可能会遇到短暂的高延迟时间。</li>
<li>对于多可用区数据库部署，由于备份是从备用实例获取的，因此没有I / O暂停</li>
</ul>
</li>
<li>自动数据库快照删除<ul>
<li>保留期限到期</li>
<li>数据库实例的自动数据库快照已禁用</li>
<li>数据库实例已删除</li>
</ul>
</li>
<li>删除数据库实例时<ul>
<li>删除后可以创建最终的数据库快照; 可用于在以后恢复已删除的数据库实例</li>
<li>RDS保留最终用户创建的数据库快照以及所有其他手动创建的数据库快照</li>
</ul>
</li>
<li>所有自动备份都将被删除，无法恢复</li>
</ul>
<h2 id="Point-In-Time-Recovery"><a href="#Point-In-Time-Recovery" class="headerlink" title="Point-In-Time Recovery"></a>Point-In-Time Recovery</h2><ul>
<li>除了每日自动备份之外，RDS还存档数据库更改日志。 这样可以将数据库恢复到备份保留期间的任何时间点，直到数据库使用的最后五分钟。</li>
<li>禁用自动备份还会禁用时间点恢复</li>
<li>RDS存储数据的多个副本，但对于单可用区数据库实例，这些副本存储在单个可用区中</li>
<li>如果出于任何原因，单可用区数据库实例变得不可用，则可以使用时间点恢复来启动具有最新可恢复数据的新数据库实例</li>
</ul>
<h2 id="用户自定义数据库快照"><a href="#用户自定义数据库快照" class="headerlink" title="用户自定义数据库快照"></a>用户自定义数据库快照</h2><ul>
<li>手动数据库快照是用户启动的备份，可以将数据库实例备份到已知状态，并可以随时还原到该特定状态。</li>
<li>RDS会保留所有手动数据库快照，直到明确删除</li>
</ul>
<h2 id="创建数据库快照"><a href="#创建数据库快照" class="headerlink" title="创建数据库快照"></a>创建数据库快照</h2><ul>
<li>建数据库实例的存储卷快照，并备份整个数据库实例而不仅仅是单个数据库</li>
<li>数据库快照可以根据需要在已知状态下备份数据库实例，然后可以随时将其还原到该特定状态</li>
<li>保留数据库快照，直到明确删除</li>
<li>在单可用区数据库实例上创建数据库快照会导致短暂的I / O挂起，通常持续时间不会超过几分钟</li>
<li>由于备份是在备用实例上进行的，因此多可用区数据库实例不受此I / O挂起的影响</li>
</ul>
<h2 id="快照还原"><a href="#快照还原" class="headerlink" title="快照还原"></a>快照还原</h2><ul>
<li>数据库实例可以在此保留期内恢复到任何特定时间，从而创建新的数据库实例</li>
<li>从数据库快照还原来创建具有不同endpoint的新数据库实例</li>
<li>RDS将周期性数据备份与事务日志结合使用，以便在保留期内将数据库实例恢复到任何秒，直到LatestRestorableTime（通常直到最后几分钟）</li>
<li>在还原数据库实例时，默认安全组与还原的实例相关联。还原完成之后新数据库实例即变为可用状态，这时必须关联还原的源实例所用的所有自定义安全组</li>
<li>建议保留所创建的数据库快照的参数组，这样还原的数据库实例就可以与正确的参数组关联。可以在还原数据库实例时指定参数组</li>
<li>可以使用与源数据库快照不同的存储类型还原数据库实例。在这种情况下，由于将数据迁移到新存储类型所需的额外工作，恢复过程将变慢。从GP2到预配置IOPS</li>
<li>有当数据库快照具有为新版本分配的所需存储时，才能使用不同版本的数据库引擎还原数据库实例，例如，从SQL Server Web Edition更改为SQL Server标准版，数据库快照必须已经过从具有至少200 GB分配存储的SQL Server数据库实例创建，该实例是SQL Server标准版的最小分配存储</li>
</ul>
<h2 id="DB-Snapshot-Copy"><a href="#DB-Snapshot-Copy" class="headerlink" title="DB Snapshot Copy"></a>DB Snapshot Copy</h2><ul>
<li>可以复制自动或手动数据库快照</li>
<li>复制自动数据库快照以在同一AWS区域中创建手动数据库快照。手动数据库快照不会自动删除，可以无限期保留。</li>
<li>将自动或手动数据库快照从一个区域复制到另一个区域。通过将数据库快照复制到另一个区域，将创建一个保留在该区域中的手动数据库快照</li>
<li>手动数据库快照可以与其他AWS账户共享，并复制其他AWS账户共享数据库快照</li>
<li>快照加密<ul>
<li>可以复制已使用 AWS KMS 加密密钥加密的快照</li>
<li>复制加密的快照，则此快照的副本也必须加密。如果在相同 AWS 区域内复制加密的快照，可使用原始快照的 KMS 加密密钥来加密此副本，也可指定不同的 KMS 加密密钥。如果跨区域复制加密的快照，由于 KMS 密钥是区域特定的，所以不能使用与源快照相同的 KMS 加密密钥</li>
</ul>
</li>
</ul>
<h2 id="快照共享"><a href="#快照共享" class="headerlink" title="快照共享"></a>快照共享</h2><ul>
<li>手动数据库快照或数据库集群快照可与最多20个其他AWS账户共享</li>
<li>与其他AWS账户共享的手动快照可以复制快照，或从该快照还原数据库实例或数据库集群</li>
<li>手动快照也可以作为公共共享，这使快照可供所有AWS账户使用。将快照共享为公共时应小心，以便不包含任何私人信息</li>
<li>共享快照可以复制到另一个区域</li>
<li>与其他 AWS 账户共享手动快照时存在以下限制：<ul>
<li>当使用 AWS Command Line Interface (AWS CLI) 或 Amazon RDS API 从共享的快照还原数据库实例时，必须指定共享快照的 Amazon 资源名称 (ARN) 作为快照标识符</li>
<li>无法共享使用了包含永久或持续性选项的选项组的数据库快照</li>
<li>不能从选项组中移除永久选项。若为数据库实例指定了包含持续性选项的选项组，则不能从数据库实例中删除这些选项组</li>
</ul>
</li>
<li>可共享使用 AES-256 加密算法“静态”加密的数据库快照</li>
<li>用户可以访问用于加密数据库快照的AWS Key Management Service（AWS KMS）加密密钥，则用户只能复制加密的数据库快照</li>
<li>通过将其他帐户添加到KMS密钥策略，可以与其他AWS账户共享AWS KMS加密密钥</li>
<li>但是，在共享加密的数据库快照之前，必须首先通过添加任何帐户来共享KMS密钥策略以共享快照</li>
</ul>
<p>#RDS Security</p>
<ul>
<li>在基于 Amazon VPC 服务的 Virtual Private Cloud (VPC) 中运行数据库实例以获得可能最大的网络访问控制</li>
<li>使用 AWS Identity and Access Management (IAM) 策略分配决定谁可以管理 Amazon RDS 资源的权限</li>
<li>使用安全组可以控制可连接到数据库实例上的数据库的 IP 地址或 Amazon EC2 实例</li>
<li>使用数据库实例的安全套接字层 (SSL) 连接</li>
<li>使用 Amazon RDS 加密保护静态数据库实例和快照</li>
<li>对 Oracle 数据库实例使用网络加密和透明数据加密</li>
<li>使用数据库引擎的安全功能控制可以登录数据库实例上的数据库的人员</li>
</ul>
<h2 id="RDS-Authentication-and-Access-Control"><a href="#RDS-Authentication-and-Access-Control" class="headerlink" title="RDS Authentication and Access Control"></a>RDS Authentication and Access Control</h2><ul>
<li>IAM可用于控制每个用户有权调用的RDS操作</li>
</ul>
<h2 id="Encrypting-RDS-Resources"><a href="#Encrypting-RDS-Resources" class="headerlink" title="Encrypting RDS Resources"></a>Encrypting RDS Resources</h2><ul>
<li>使用行业标准AES-256加密算法来加密承载RDS实例的服务器上的数据</li>
<li>在加密数据后，Amazon RDS 将以透明方式处理访问的身份验证和数据的解密，并且对性能产生的影响最小。无需修改数据库客户端应用程序来使用加密</li>
<li>静态数据加密<ul>
<li>可以在RDS实例上启用以加密底层存储</li>
<li>加密密钥由KMS管理</li>
<li>只能在实例创建期间启用</li>
<li>启用后，无法更改加密密钥</li>
<li>如果密钥丢失，则只能从备份中恢复数据库</li>
</ul>
</li>
<li>为RDS实例启用加密后，<ul>
<li>日志已加密</li>
<li>快照已加密</li>
<li>自动备份已加密</li>
<li>只读副本是加密的</li>
</ul>
</li>
<li>跨区域副本和快照副本不起作用，因为密钥仅在单个区域中可用</li>
<li>快照注意事项<ul>
<li>可以复制使用KMS加密密钥加密的数据库快照</li>
<li>复制加密的数据库快照会生成数据库快照的加密副本</li>
<li>复制时，可以使用与原始数据库快照相同的KMS加密密钥加密数据库快照，也可以使用其他KMS加密密钥加密数据库快照的副本。</li>
<li>可以将未加密的数据库快照复制到加密快照，这是一种向以前未加密的数据库实例添加加密的快速方法。</li>
<li>加密快照只能还原到加密的数据库实例</li>
<li>如果从未加密的数据库集群快照还原时指定了KMS加密密钥，则使用指定的KMS加密密钥对还原的数据库集群进行加密</li>
<li>复制从另一个AWS账户共享的加密快照需要访问用于加密数据库快照的KMS加密密钥。</li>
<li>由于KMS加密密钥特定于创建它们的区域，因此无法将加密快照复制到其他区域</li>
</ul>
</li>
<li>透明数据加密<ul>
<li>在将数据写入底层存储设备之前自动加密数据，并在从存储设备读取数据时进行解密</li>
<li>Oracle和SQL Server支持</li>
<li>Oracle需要KMS外部的密钥存储，并与CloudHSM集成</li>
<li>SQL Server需要密钥，但由RDS管理</li>
</ul>
</li>
</ul>
<h2 id="使用-SSL-加密与数据库实例的连接"><a href="#使用-SSL-加密与数据库实例的连接" class="headerlink" title="使用 SSL 加密与数据库实例的连接"></a>使用 SSL 加密与数据库实例的连接</h2><ul>
<li>使用SSL加密连接，以便在应用程序和数据库实例之间传输数据</li>
<li>当RDS配置实例时，Amazon RDS会创建SSL证书并在数据库实例上安装证书</li>
<li>SSL证书由证书颁发机构签名。 SSL证书包括数据库实例端点作为SSL证书的公用名（CN）以防止欺骗攻击</li>
<li>虽然SSL提供了安全性优势，但请注意，SSL加密是一项计算密集型操作，会增加数据库连接的延迟。</li>
</ul>
<h2 id="RDS-安全组"><a href="#RDS-安全组" class="headerlink" title="RDS 安全组"></a>RDS 安全组</h2><ul>
<li>安全组控制流量进出数据库实例的访问权限</li>
<li>VPC安全组的作用类似于控制对数据库实例的网络访问的防火墙</li>
<li>可以配置VPC安全组并将其与数据库实例关联，以允许从IP地址范围，端口或EC2安全组进行访问</li>
<li>数据库安全组默认为“拒绝所有”访问模式，客户必须专门授权网络入口</li>
</ul>
<h2 id="主账户权限"><a href="#主账户权限" class="headerlink" title="主账户权限"></a>主账户权限</h2><ul>
<li>创建新数据库实例时，使用的默认主用户将获得该数据库实例的特定权限</li>
<li>随后，可以创建具有权限的其他用户</li>
</ul>
<h2 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h2><ul>
<li>可以为数据库实例上发生的重要事件配置事件通知</li>
<li>RDS实例上可能发生的各种重要事件的通知，例如实例是否已关闭，备份是否已启动，是否发生故障转移，安全组是否已更改，或者存储空间是否低</li>
</ul>
<h1 id="RDS-Maintenance-amp-Upgrades"><a href="#RDS-Maintenance-amp-Upgrades" class="headerlink" title="RDS Maintenance &amp; Upgrades"></a>RDS Maintenance &amp; Upgrades</h1><p>当手动修改数据库实例时，可能会发生对数据库实例的更改。 数据库引擎版本已升级，或者当Amazon RDS对实例执行维护时</p>
<h2 id="RDS-维护"><a href="#RDS-维护" class="headerlink" title="RDS 维护"></a>RDS 维护</h2><ul>
<li>RDS会定期对Amazon RDS资源（例如数据库实例）执行维护，并且通常涉及对数据库实例的操作系统（OS）的更新</li>
<li>维护项目也可以<ul>
<li>在方便时手动应用于数据库实例</li>
<li>或者等待Amazon RDS在定义的每周维护窗口期间启动的自动维护过程。</li>
</ul>
</li>
<li>维护窗口仅确定挂起操作何时开始，但不限制这些操作的总执行时间。 维护操作无法保证在维护窗口结束之前完成，并且可以继续超过指定的结束时间</li>
<li>可以在RDS控制台上和使用RDS API检查维护更新可用性。 如果有更新，可以<ul>
<li>推迟维护项目</li>
<li>立即应用维护项目</li>
<li>安排它们在下一个定义的维护窗口期间启动</li>
</ul>
</li>
<li>维护项目标记为<ul>
<li>如果延期AWS将在下次执行更新时发送通知，则无法无限期延期</li>
<li>可用且可以无限期延迟，更新不会应用于数据库实例</li>
</ul>
</li>
<li>必需的补丁自动只适用于相关的安全性和可靠性，例如补丁计划。 这种修补很少发生（通常每隔几个月一次），很少需要维护窗口的一小部分。</li>
<li>维护项目要求RDS的数据库实例在短时间内脱机。 需要数据库实例脱机的维护包括扩展计算操作，从开始到结束通常只需几分钟，并且需要操作系统或数据库修补。</li>
<li>数据库实例的多可用区部署通过以下步骤减少了维护事件的影响：<ul>
<li>在备用数据库上执行维护。</li>
<li>将备用数据库提升为主数据库。</li>
<li>对旧主服务器执行维护，这将成为新的主服务器。</li>
</ul>
</li>
<li>在多可用区部署中修改数据库实例的数据库引擎时，RDS会同时升级主数据库实例和辅助数据库实例。 在这种情况下，升级期间将关闭整个多可用区部署的数据库引擎</li>
</ul>
<h2 id="OS-升级"><a href="#OS-升级" class="headerlink" title="OS 升级"></a>OS 升级</h2><ul>
<li>升级到操作系统通常是出于安全问题，应该尽快完成。</li>
<li>数据库实例上的操作系统更新可以方便的时候应用，也可以等待RDS启动的维护过程在定义的维护时段应用更新</li>
<li>应用操作系统更新时，不会自动备份数据库实例，应在应用更新之前进行备份</li>
</ul>
<h2 id="DB-引擎升级"><a href="#DB-引擎升级" class="headerlink" title="DB 引擎升级"></a>DB 引擎升级</h2><ul>
<li>当RDS支持新的数据库引擎版本时，可以升级数据库实例引擎版本</li>
<li>数据库版本升级包括主要版本和次要版本升级</li>
</ul>
<h3 id="主要数据库版本升级"><a href="#主要数据库版本升级" class="headerlink" title="主要数据库版本升级"></a>主要数据库版本升级</h3><ul>
<li>可以包含不向后兼容的更改</li>
<li>RDS不会自动应用主要版本升级</li>
<li>在将数据库实例应用于生产实例之前，应手动修改并彻底测试数据库实例</li>
</ul>
<h3 id="次要版本升级"><a href="#次要版本升级" class="headerlink" title="次要版本升级"></a>次要版本升级</h3><ul>
<li>每个数据库引擎处理次要版本升级略有不同</li>
<li>例如 RDS会自动将次要版本升级应用于运行PostgreSQL的数据库实例，但必须手动应用于运行Oracle的数据库实例</li>
<li>AWS向论坛公告页面发布公告，并在升级数据库实例之前发送客户电子邮件通知</li>
<li>AWS计划在一年中的特定时间进行升级，以帮助计划周围的升级，因为升级数据库引擎版本需要停机时间，即使对于多可用区实例也是如此</li>
<li>RDS在升级过程中需要两个数据库快照。</li>
<li>在进行任何升级更改之前，第一个数据库快照属于数据库实例。 如果升级失败，可以从快照还原以创建运行旧版本的数据库实例。</li>
<li>升级完成后将执行第二个数据库快照。 升级完成后，无法将数据库引擎恢复为以前的版本。 要返回到先前版本，请还原用于创建新数据库实例的第一个数据库快照</li>
<li>如果数据库实例正在使用读取复制，则必须先升级所有只读副本，然后再升级源实例</li>
<li>如果数据库实例处于多可用区部署中，则主要副本和备用副本将同时升级并导致中断。 中断的时间因数据库引擎，版本和数据库实例的大小而异</li>
</ul>
<h2 id="RDS-维护窗口"><a href="#RDS-维护窗口" class="headerlink" title="RDS 维护窗口"></a>RDS 维护窗口</h2><ul>
<li>每个数据库实例都定义了一个每周维护窗口，在此期间应用任何系统更改</li>
<li>在请求或要求的情况下，维护窗口是控制何时发生数据库实例修改和软件修补的机会。</li>
<li>如果为某一周安排了维护事件，则将在定义的30分钟维护时段内启动该事件</li>
<li>维护事件大多在30分钟维护窗口期间完成，但较大的维护事件可能需要更多时间</li>
<li>从每个区域的8小时时间块中随机选择30分钟的维护窗口。如果在创建数据库实例时未指定首选维护时段，则Amazon RDS会在一周中随机选择的某一天分配30分钟的维护时段</li>
<li>在应用维护时，RDS将消耗数据库实例上的一些资源，从而最大限度地降低性能</li>
<li>对于某些维护事件，可能需要多可用区故障转移才能完成维护更新</li>
</ul>
<h1 id="RDS-Monitoring-amp-Notification"><a href="#RDS-Monitoring-amp-Notification" class="headerlink" title="RDS Monitoring &amp; Notification"></a>RDS Monitoring &amp; Notification</h1><ul>
<li>RDS与CloudWatch集成，并提供监控指标</li>
<li>可以在警报更改状态时发送SNS消息的单个度量标准上创建CloudWatch警报</li>
<li>每当发生任何RDS事件时，RDS也会提供SNS通知</li>
</ul>
<h2 id="CloudWatch-RDS-Monitoring"><a href="#CloudWatch-RDS-Monitoring" class="headerlink" title="CloudWatch RDS Monitoring"></a>CloudWatch RDS Monitoring</h2><ul>
<li>可以使用CloudWatch监视RDS数据库实例，CloudWatch可以将RDS中的原始数据收集并处理为可读的近实时指标。</li>
<li>统计信息记录为期两周，以便可以访问历史信息并更好地了解服务的执行情况。</li>
<li>默认情况下，RDS指标数据会在1分钟内自动发送到Amazon CloudWatch</li>
<li>CloudWatch RDS指标</li>
</ul>
<table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BinLogDiskUsage</td>
<td>主节点上的二进制日志所占的磁盘空间大小。适用于 MySQL 只读副本。单位：字节</td>
</tr>
<tr>
<td>BurstBalance</td>
<td>可用的通用型 SSD (GP2) 突增存储桶 I/O 点数的百分比。单位：百分比</td>
</tr>
<tr>
<td>CPUUtilization</td>
<td>CPU 使用百分率。单位：百分比</td>
</tr>
<tr>
<td>CPUCreditUsage</td>
<td>[T2 实例] 实例为保持 CPU 使用率而花费的 CPU 积分数。单位：积分 (vCPU 分钟)</td>
</tr>
<tr>
<td>CPUCreditBalance</td>
<td>[T2 实例] 实例自启动后已累积获得的 CPU 积分数。单位：积分 (vCPU 分钟)</td>
</tr>
<tr>
<td>DatabaseConnections</td>
<td>使用中的数据库连接数。单位：计数</td>
</tr>
<tr>
<td>DiskQueueDepth</td>
<td>等待访问磁盘的未完成 IO（读取/写入请求）的数量。单位：计数</td>
</tr>
<tr>
<td>FailedSQLServerAgentJobsCount</td>
<td>过去 1 分钟内失败的 SQL Server 代理作业的数量。单位：计数/分钟</td>
</tr>
<tr>
<td>FreeableMemory</td>
<td>随机存取内存的可用大小。单位：字节</td>
</tr>
<tr>
<td>FreeStorageSpace</td>
<td>可用存储空间的大小。单位：字节</td>
</tr>
<tr>
<td>MaximumUsedTransactionIDs</td>
<td>已使用的最大事务 ID。适用于 PostgreSQL。单位：计数</td>
</tr>
<tr>
<td>NetworkReceiveThroughput</td>
<td>数据库实例的传入（接收）网络流量，包括用于监控和复制的客户数据库流量和 Amazon RDS 流量。单位：字节/秒</td>
</tr>
<tr>
<td>NetworkTransmitThroughput</td>
<td>数据库实例的传出（传输）网络流量，包括用于监控和复制的客户数据库流量和 Amazon RDS 流量。单位：字节/秒</td>
</tr>
<tr>
<td>OldestReplicationSlotLag</td>
<td>在接收 WAL 数据方面最滞后的副本的滞后大小。适用于 PostgreSQL。单位：MB</td>
</tr>
<tr>
<td>ReadIOPS</td>
<td>每秒平均磁盘读取 I/O 操作数。单位：计数/秒</td>
</tr>
<tr>
<td>ReadLatency</td>
<td>每个磁盘 I/O 操作所需的平均时间。单位：秒</td>
</tr>
<tr>
<td>ReadThroughput</td>
<td>每秒从磁盘读取的平均字节数。单位：字节/秒</td>
</tr>
<tr>
<td>ReplicaLag</td>
<td>只读副本数据库实例滞后于源数据库实例的时间量。适用于 MySQL、MariaDB 和 PostgreSQL 只读副本。单位：秒</td>
</tr>
<tr>
<td>ReplicationSlotDiskUsage</td>
<td>复制插槽文件使用的磁盘空间。适用于 PostgreSQL。单位：MB</td>
</tr>
<tr>
<td>SwapUsage</td>
<td>数据库实例上使用的交换空间的大小。此指标对于 SQL Server 不可用。单位：字节</td>
</tr>
<tr>
<td>TransactionLogsDiskUsage</td>
<td>事务日志使用的磁盘空间。适用于 PostgreSQL。单位：MB</td>
</tr>
<tr>
<td>TransactionLogsGeneration</td>
<td>每秒生成的事务日志的大小。适用于 PostgreSQL。单位：字节/秒</td>
</tr>
<tr>
<td>WriteIOPS</td>
<td>每秒平均磁盘写入 I/O 操作数。单位：计数/秒</td>
</tr>
<tr>
<td>WriteLatency</td>
<td>每个磁盘 I/O 操作所需的平均时间。单位：秒</td>
</tr>
<tr>
<td>WriteThroughput</td>
<td>每秒写入磁盘的平均字节数。单位：字节/秒</td>
</tr>
</tbody></table>
<h2 id="RDS-Event-Notification"><a href="#RDS-Event-Notification" class="headerlink" title="RDS Event Notification"></a>RDS Event Notification</h2><ul>
<li>RDS使用SNS在发生RDS事件时提供通知</li>
<li>RDS将事件分组，可以订阅这些类别，以便在发生该类别中的事件时发送通知。</li>
<li>可以订阅数据库实例，数据库集群，数据库快照，数据库集群快照，数据库安全组或数据库参数组的事件类别</li>
<li>事件通知将发送到订阅创建期间提供的电子邮件地址</li>
<li>通过在RDS控制台中将Enabled单选按钮设置为No或使用CLI或RDS API将Enabled参数设置为false，可以轻松关闭订阅而不删除订阅</li>
</ul>
<h1 id="RDS-最佳实践"><a href="#RDS-最佳实践" class="headerlink" title="RDS 最佳实践"></a>RDS 最佳实践</h1><h2 id="Amazon-RDS-基本操作指导"><a href="#Amazon-RDS-基本操作指导" class="headerlink" title="Amazon RDS 基本操作指导"></a>Amazon RDS 基本操作指导</h2><ul>
<li>Monitoring<ul>
<li>监控内存、CPU 和存储空间使用情况。可以将 Amazon CloudWatch 设置为在使用模式发生变化或接近部署容量时向发送通知，以保持系统性能和可用性</li>
</ul>
</li>
<li>Scaling <ul>
<li>当接近存储容量限制时，可以向上扩展数据库实例</li>
<li>存储和内存中应含有一些缓冲区，以适应应用程序的意外增大需求</li>
</ul>
</li>
<li>Backup<ul>
<li>启用自动备份并设置备份时段，以在每天写入 IOPS 较低的时段进行</li>
</ul>
</li>
<li>在MySQL数据库实例上，<ul>
<li>不要创建使用自动配置的IOPS或1000个表使用标准存储超过10000个表。故障转移或数据库崩溃后，大量表将显着增加数据库恢复时间。 如果需要创建多于建议的表，请将innodb_file_per_table参数设置为0。</li>
<li>避免数据库中的表变得过大。 预配置存储限制将MySQL表文件的最大大小限制为6 TB。 而是对大表进行分区，以使文件大小远低于6 TB的限制。 这还可以提高性能和恢复时间。</li>
</ul>
</li>
<li>Performance</li>
<li>数据库工作负载需要的 I/O 超过配置，那么出现故障转移或数据库故障后，恢复的速度将会变缓<ul>
<li>迁移到具有高 I/O 容量的数据库实例类</li>
<li>从标准存储转换为通用存储或配置的 IOPS 存储，具体取决于需要增加的量</li>
<li>已在使用配置的 IOPS 存储，请额外配置吞吐量容量</li>
</ul>
</li>
<li>多可用区和故障转移<ul>
<li>在所有可用区中部署应用程序，如果AZ发生故障，其他AZ中的应用程序仍可用</li>
<li>使用Amazon RDS数据库事件来监控故障转移</li>
<li>如果客户端应用程序正在缓存数据库实例的DNS数据，则设置小于30秒的TTL。 由于数据库实例的基础IP地址可能在故障转移后发生更改，因此如果应用程序尝试连接到不再使用的IP地址，则将DNS数据缓存较长时间可能会导致连接失败</li>
<li>多可用区要求启用事务日志记录功能。 不要使用简单恢复模式，脱机模式或只读模式等功能来转换事务日志记录</li>
<li>缩短故障转移时间<ol>
<li>确保工作负载分配了足够的预配置IOPS。 I / O不足可能会延长故障转移时间。 数据库恢复需要I / O</li>
<li>使用较小的交易。 数据库恢复依赖于事务，因此将大型事务分解为多个较小的事务以缩短故障转移时间</li>
</ol>
</li>
<li>测试数据库实例的故障转移，以了解进程对用例的持续时间，并确保访问数据库实例的应用程序可以在故障转移后自动连接到新的数据库实例</li>
</ul>
</li>
</ul>
<h2 id="数据库实例-RAM-建议"><a href="#数据库实例-RAM-建议" class="headerlink" title="数据库实例 RAM 建议"></a>数据库实例 RAM 建议</h2><ul>
<li>RDS 性能最佳实践是分配足够的 RAM，以便工作集几乎完全驻留在内存中</li>
<li>ReadIOPS 的值应是一个较小且稳定的值</li>
<li>要确定工作集是否几乎完全位于内存中，请在数据库实例加载期间检查 ReadIOPS 指标 (使用 Amazon CloudWatch)</li>
<li>如果将数据库实例类向上扩展—到带更多 RAM 的类—则会导致 ReadIOPS 大幅降低，从而使工作集不能几乎完全位于内存中。继续向上扩展直至 ReadIOPS 不再在扩展操作后大幅降低，否则 ReadIOPS 将降低至非常小的数量</li>
</ul>
<h2 id="RDS安全实践"><a href="#RDS安全实践" class="headerlink" title="RDS安全实践"></a>RDS安全实践</h2><ul>
<li>不要使用AWS根凭据来管理Amazon RDS资源; 应该为每个人创建IAM用户</li>
<li>为每个用户授予执行其职责所需的最小权限集</li>
<li>使用IAM组有效管理多个用户的权限</li>
<li>定期轮换IAM凭据</li>
</ul>
<h2 id="使用增强监控操作系统"><a href="#使用增强监控操作系统" class="headerlink" title="使用增强监控操作系统"></a>使用增强监控操作系统</h2><ul>
<li>Amazon RDS为数据库实例运行的操作系统（OS）提供实时指标</li>
</ul>
<h2 id="使用指标确定性能问题"><a href="#使用指标确定性能问题" class="headerlink" title="使用指标确定性能问题"></a>使用指标确定性能问题</h2><ul>
<li>要确定资源不足和其他常见瓶颈导致的性能问题，可以监控可用于 Amazon RDS 数据库实例的指标</li>
<li>应定期监控性能指标以查看各种时间范围内的平均值、最大值和最小值</li>
<li>可以针对特定指标阈值设置 Amazon CloudWatch 警报，以便在达到这些阈值时发出警报</li>
<li>数据库实例具有许多不同类别的度量标准，包括CPU，内存，磁盘空间，IOPS，数据库连接和网络流量，以及如何确定可接受的值取决于度量标准。</li>
<li>提高数据库实例性能的最佳方法之一是调整最常用和最耗费资源的查询，以降低运行成本</li>
</ul>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>InnoDB是Amazon RDS上MySQL数据库实例的推荐和支持的存储引擎。</li>
<li>但是，如果需要强大的全文搜索功能，MyISAM的性能优于InnoDB。</li>
<li>Amazon RDS for MySQL的时间点恢复和快照恢复功能需要可崩溃恢复的存储引擎，并且仅支持InnoDB存储引擎。</li>
<li>尽管MySQL支持具有不同功能的多个存储引擎，但并非所有存储引擎都针对崩溃恢复和数据持久性进行了优化</li>
<li>MyISAM存储引擎不支持可靠的崩溃恢复，并且可能会阻止时间点还原或快照还原按预期工作，这可能会导致在崩溃后重新启动MySQL时丢失或损坏数据</li>
</ul>
<h3 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h3><ul>
<li>XtraDB是Amazon RDS上MariaDB数据库实例的推荐和支持的存储引擎</li>
<li>Amazon RDS for MariaDB的时间点恢复和快照恢复功能需要可崩溃恢复的存储引擎，并且仅支持XtraDB存储引擎</li>
<li>尽管 Aria 是 MyISAM 的崩溃安全替代，但它仍可能使时间点还原或快照还原无法按预期工作。这可能导致在崩溃后重新启动 MariaDB 时丢失或损坏数据</li>
</ul>
<h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h1><ul>
<li>Amazon Relational Database Service user guide</li>
<li><a href="http://jayendrapatil.com/aws-relational-database-service-rds/" target="_blank" rel="noopener">http://jayendrapatil.com/aws-relational-database-service-rds/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/17/CDN技术详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/CDN技术详解/" itemprop="url">CDN技术详解</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T19:56:45+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CDN/" itemprop="url" rel="index">
                    <span itemprop="name">CDN</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><em>摘自《CDN技术详解》</em></p>
</blockquote>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul>
<li>广义互联网，两层组成<ul>
<li>以TCP/IP为代表的网络层（狭义的互联网），网络的基础，一般说TCP/IP网络；将各种信息的数据报文以极低的成本进行进行传输，俗称“管道”，所有信息都在这一管道中传送</li>
<li>以万维网（WWW）为代表的应用层，是广义互联网的上层。包括各种类型的流量和应用，邮件、软件、在线影视、游戏、电子商务等</li>
</ul>
</li>
<li>“第一公里”是指万维网流量向用户传送的第一个出口，是网站服务器接入互联网的链路所能提供的带宽。这个带宽决定了一个 网站能为用户提供的访问速度和并发访问量。如果业务繁忙，用户的访问数越多，拥塞越严重，网站会在最需要向用户提供服务时失去用户。（还有“中间一公里” 和“最后一公里”分别代表互联网传输传输和万维网流量向用户传送的最后一段接入链路）</li>
<li>从互联网的架构来看，不同网络之间的互联互通带宽，对任何一个运营商网络的流量来说，占比都比较小，收敛比是非常高的，因此这里通常都是互联网传输中的拥堵点（运营商互联互通的问题）</li>
<li>其次是骨干网堵塞问题，由于互联网上的绝大部分流量都要通过骨干网络进行传输，这就要求骨干网络的承载能力必须与互联网 的应用同步发展，但实际上两者并不是同步的，当骨干网络的升级和扩容滞后于互联网之上的应用的发展时，就会阶段性地使得大型骨干网的承载能力成为影响互联 网性能的瓶颈（区域互联互通问题，骨干网带宽瓶颈）</li>
<li>服务响应时间由服务响应时间和网络时延组成。网站到用户之间要经过IDC、骨干网、用户所在的局域网、用户所在的接入网</li>
<li>在互联网领域有一个“8秒定律”，用户访问一个网站时，如果等待网页打开的时间超过8秒，会有超过30%的用户放弃等待</li>
<li>CDN技术在网络传输上利用缓存技术使得Web服务数据流能就近访问，是优化网络数据传输非常有效的技术，从而获得高速的体验和品质保证</li>
<li>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，解决用户访问网站的响应速度慢的根本原因</li>
<li>CDN工作原理<div align="center">
<a href="https://sm.ms/image/M7J4bgop89NzVOs" target="_blank"><img src="https://i.loli.net/2019/08/17/M7J4bgop89NzVOs.png" alt="ScreenShot_20190804144149.png"></a>
</div>
</li>
</ul>
<ol>
<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器</li>
<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户</li>
<li>用户向CDN的全局负载均衡设备发起内容URL访问请求</li>
<li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li>
<li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件综合分析之后，区域负载均衡设备返回一台缓存服务器的IP地址。</li>
<li>全局负载均衡设备把服务器的IP地址返回给用户</li>
<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器并没有用户想要的内容，而区域均衡设备依然将它分配给用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地</li>
</ol>
<ul>
<li>DNS服务器根据用户IP地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用CDN服务的网站，只需要将域名解析权交给CDN的GSLB设备，将需要分发的内容注入CDN，就可以实现内容加速了</li>
</ul>
<h1 id="CDN技术"><a href="#CDN技术" class="headerlink" title="CDN技术"></a>CDN技术</h1><ul>
<li>CDN提供一种机制，当用户请求内容时，该内容能够由以最快速度交付的Cache来向用户提供，这个挑选“最优”的过程就叫做负载均衡</li>
<li>CDN系统架构</li>
</ul>
<p><img src="https://i.loli.net/2019/08/17/Ns9kElYohHR8OxB.png" alt="ScreenShot_20190804145702.png"></p>
<ul>
<li><strong>分发服务系统</strong>：最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标</li>
<li><strong>负载均衡系统</strong>：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负 责节点内部的设备负载均衡</li>
<li><strong>运营管理系统</strong>：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。<h2 id="China-Cache-CDN-系统架构图"><a href="#China-Cache-CDN-系统架构图" class="headerlink" title="China Cache CDN 系统架构图"></a>China Cache CDN 系统架构图</h2><img src="https://i.loli.net/2019/08/17/vKr6QbXO5fjk8ZP.png" alt="ScreenShot_20190804150239.png"></li>
<li>部署架构<ul>
<li>节点是CDN系统中最基本的部署的单元，一个CDN系统由大量、地理位置分散的POP节点组成，为用户提供就近的内容访问服务。</li>
<li>CDN节点 网络主要包含CDN骨干节点和POP节点。</li>
<li>中心和区域节点一般称之为骨干姐点，主要作为内容分发和边缘未命中时的服务点；边缘节点被称之为POP（point-of-presence）节点，pop节点主要作为直接向用户提供服务的节点。</li>
<li>从节点构成来讲，无论是骨干节点还是pop节点，都有Cache设备和本地负载均衡设备构成</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/08/17/ew6baKtMBGnJCHO.png" alt="ScreenShot_20190804150754.png"></p>
<ul>
<li>基于承载内容类型<ul>
<li>网页加速：网页静态内容</li>
<li>流媒体加速：直播和点播</li>
<li>文件传输加速：软件下载、更新等</li>
<li>应用协议加速：企业应用加速主要是动态加速和SSL加速</li>
</ul>
</li>
</ul>
<ol>
<li>SSL应用加速：由于需要大量的加密解密运算，SSL应用对服务器端的资源消耗是非常巨大的。CDN提供SSL应用加速后，由CDN的专用SSL加速硬件来完成加密解密运算工作</li>
<li>网页压缩：HTTP1.1提出对网页压缩的支持。在服务器端可以先对网页数据进行压缩，然后将压缩后的文件提供给访问用户，最后在用户浏览器端解压显示（但要衡量加解压时间）（HTTP2.0支持压缩）</li>
</ol>
<ul>
<li>基于内容生成机制的分类和分层加速服务<ul>
<li>静态内容：网页HTML文件提供，任何人在任何时间浏览静态内容看到的都是一样的内容</li>
<li>动态内容：不同的访问者在不同时间访问同一个web页面时可能得到不同的页面内容，内容具有实时性，访问过程具有交互性；同时还需要采用数据管理系统和业务逻辑程序来使网站具有更多自动和高级功能</li>
</ul>
</li>
</ul>
<h1 id="内容缓存工作原理"><a href="#内容缓存工作原理" class="headerlink" title="内容缓存工作原理"></a>内容缓存工作原理</h1><ul>
<li>缓存技术（caching）：缓存代理缓存被访问过的内容，后续的相同内容访问直接通过缓存代理获得服务；CDN是缓存技术的基础上发展起来的，是缓存的分布式集群实现</li>
<li>Web架构的精华有三处：<ul>
<li>超文本技术HTML实现信息与信息的连接；</li>
<li>统一资源标志符URI实现全球信息的精确定位</li>
<li>应用层协议HTTP实现分布式的信息共享</li>
</ul>
</li>
<li>TCP连接在每一次HTTP（HTTP 1.0）请求和响应完成后就关闭，如果客户端还要请求其他对象，需要重新为每个对象建立TCP连接。当一个Web页面内包含多个对象并全部显示时，客户端需要与服务器建立的TCP连接数较多，对整个时延和网络流量造成了较大的影响</li>
<li>HTTP1.1采用了效率更高 的持续连接机制，即客户端和服务器端建立TCP连接后，后续相关联的HTTP请求可以重复利用已经建立起来的TCP连接，不仅整个Web页面（包括基本的 HTML文件和其他对象）可以使用这个持续的TCP连接来完成HTTP请求和响应，而且同一个服务器内的多个Web页面也可以通过同一个持续TCP连接来 请求和响应。通常情况下，这个持续的TCP连接会在空闲一段特定的时间后关闭，而这个最大空闲时间时可以设置的（连接复用）。</li>
<li>HTTP协议中的缓存技术：新 鲜度（时间值）和验证（验证信息如ETag或last-modified）时确定内容可否直接提供服务的最重要依据。如果缓存内容足够新鲜，缓存的内容就 能直接满足HTTP访问的需求了；如果内容过期，而经源服务器验证后发现内容没有发生变化，缓存服务器也会避免将内容从源服务器重新传输一遍</li>
<li>如果要通过META标签来控制页面不缓存，一般情况下会在Web页面的<head><meta name="generator" content="Hexo 3.9.0">区域中增加”pragma:no-cache”</head></li>
<li>验证的目的就是检验缓存内容是否可用。当中间缓存存在一个过期的缓存内容，并且对应的访问请求到达时，缓存应该首先向源服务器或者其他保存有未过期的缓存服务器请求验证来确定本地的缓存内容是否可用。（缓存内容过期，但源服务器没有更新内容，即缓存内容仍可用</li>
<li>HTTP1.1介绍了cache-control显示指令来让网站发布者可以更全面地控制他们的内容，并对过期时间进行限制（控制是否缓存，怎么缓存）</li>
<li>HTTP gzip压缩：大多数情况需要压缩的文件时网页中出现最频繁的HTML、CSS、javascript、XML等文件，这类本身是没有经过压缩的文本文件，可以取得较好的压缩效果</li>
<li>HTTP与TCP关系</li>
</ul>
<p><img src="https://i.loli.net/2019/08/17/EHS8wOft6PdhmZb.png" alt="ScreenShot_20190804162308.png"></p>
<ul>
<li>HTTP通常时架构在TCP传输协议之上，出于安全考虑，HTTP还需要经过TLS或SSL层封装</li>
<li>HTTP客户端（浏览器）首先发起建立于服务器的TCP连接，然后客户端于服务器的HTTP进程就可以通过各自的套接字（socket）来下层的TCP</li>
<li>HTTP协议是无状态协议，每次请求和响应都是独立的<ul>
<li>Web通过cookie和session 解决无状态带来的问题</li>
</ul>
</li>
<li>Cookie在客户端存放</li>
<li>Session，保持用户的状态访问，服务器侧（Http cookie机制或者URL重写）<ul>
<li>安全控制通过HTTPS协议实现</li>
<li>Web cache关键技术性能指标</li>
</ul>
</li>
<li>并发量</li>
<li>吞吐率</li>
<li>命中率</li>
<li>响应时间和丢包率（DNS解析、建立连接时间、重定向时间、收到第一个包时间、图片下载时间、页面下载总时间）<ul>
<li>内容更新机制</li>
</ul>
</li>
</ul>
<ol>
<li>若HTTP响应头信息告诉cache不需要缓存，那么cache就不会缓存相应内容</li>
<li>若对某内容的请求信息是需要认证或安全加密的，cache也不会缓存相应内容</li>
<li>若HTTP相应中没有Etag或者Last-modified头信息，cache会认为缺乏直接的更新信息，默认该内容不可缓存（last-modified 时间精度上有一定缺陷）</li>
<li>一个缓存的副本若含有一下信息，cache会认为它是足够新的，会直接从缓存中送出，不会向源服务器发送请求<br>含有完整的过期时间和寿命控制的头信息，并且内容仍在生存期内<br>浏览器已经使用过这个缓存副本，并且在同一个会话中已经检查过内容的新鲜度</li>
<li>若缓存的内容副本已经过时，cache将向源站服务器请求校验，用于确定是否可以继续使用当前版本继续服务。若经校验发现副本的原件没有变化，cache会避免从源站获取副本，通常来讲，HTML文件、图片、css、xml、js、音频、流媒体等静态资源会被缓存，而动态地址、asp、py、jsp、php等动态资源不被缓存<ul>
<li>Web cache优化</li>
</ul>
</li>
<li>HTTP链接聚合</li>
<li>HTTP Gzip压缩</li>
</ol>
<h1 id="集群服务与负载均衡"><a href="#集群服务与负载均衡" class="headerlink" title="集群服务与负载均衡"></a>集群服务与负载均衡</h1><ul>
<li>web集群是由多个同时运行同一个web应用的服务器组成，在外界看来就像一个服务器一样，这多台服务器共同来为客户提供更高性能的服务。集群更标准的定义是：一组相互独立的服务器在网络中表现为单一的系统，并以单一系统的模式加以管理，此单一系统为客户工作站提供高可靠性的服务。</li>
<li>而负载均衡的任务就是负责多个服务器之 间（集群内）实现合理的任务分配，使这些服务器（集群）不会出现因某一台超负荷、而其他的服务器却没有充分发挥处理能力的情况。负载均衡有两个方面的含 义：首先，把大量的并发访问或数据流量分担到多台节点上分别处理，减少用户等待响应的时间；其次，单个高负载的运算分担到多台节点上做并行处理，每个节点 设备处理结束后，将结果汇总，再返回给用户，使得信息系统处理能力可以得到大幅度提高</li>
<li>高可用性集群(HA Cluster)</li>
<li>指为了使群集的整体服务尽可能可用，减少服务宕机时间为目的的集群技术。如果高可用性集群中的某节点发生了故障，那么这段时间内将由其他节点代替它的工作。当然对于其他节点来讲，负载相应的就增加了。</li>
<li>为了提高整个系统的可用性，除了提高计算机各个部件的可靠性以外，一般情况下都会采用该集群的方案。</li>
<li>对于该集群方案，一般会有两种工作方式：</li>
</ul>
<ol>
<li>主-主(Active-Active)工作方式<ul>
<li>这是最常用的集群模型，它提供了高可用性，并且在只有一个节点时也能提供可以接受的性能，该模型允许最大程度的利用硬件资源。每个节点都通过网络对客户机 提供资源，每个节点的容量被定义好，使得性能达到最优，并且每个节点都可以在故障转移时临时接管另一个节点的工作。所有的服务在故障转移后仍保持可用，但 是性能通常都会下降。</li>
<li>这是目前运用最为广泛的双节点双应用的Active/Active模式。</li>
<li>支撑用户业务的应用程序在正常状态下分别在两台节点上运行，各自有自己的资源，比如IP地址、磁盘阵列上的卷或者文件系统。当某一方的系统或者资源出现故障时，就会将应用和相关资源切换到对方的节点上。</li>
<li>这种模式的最大优点是不会有服务器的“闲置”，两台服务器在正常情况下都在工作。但如果有故障发生导致切换，应用将放在同一台服务器上运行，由于服务器的处理能力有可能不能同时满足数据库和应用程序的峰值要求，这将会出现处理能力不够的情况，降低业务响应水平。</li>
</ul>
</li>
<li>主-从(Active-Standby)工作方式<ul>
<li>为了提供最大的可用性，以及对性能最小的影响，主-从工作方式需要一个在正常工作时处于备用状态的节点，主节点处理客户机的请求，而备用节点处于空闲状态，当主节点出现故障时，备用节点会接管主节点的工作，继续为客户机提供服务，并且不会有任何性能上影响。</li>
<li>两节点的Active/Standby模式是HA中最简单的一种，两台服务器通过双心跳线路组成一个集群。应用Application联合各个可选的系统组件如：外置共享的磁盘阵列、文件系统和浮动IP地址等组成业务运行环境。</li>
<li>此环境提供了完全冗余的服务器配置。这种模式的优缺点：</li>
<li>缺点：Node2在Node1正常工作时是处于“闲置”状态，造成服务器资源的浪费。</li>
<li>优点：当Node1发生故障时，Node2能完全接管应用，并且能保证应用运行时的对处理能力要求</li>
</ul>
</li>
</ol>
<ul>
<li>高可扩展性集群<ul>
<li>这里指带有负载均衡策略（算法）的服务器群集技术。带负载均衡集群为企业需求提供了更实用的方案，它使负载可以在计算机集群中尽可能平均地分摊处理。而需 要均衡的可能是应用程序处理负载或是网络流量负载。该方案非常适合于运行同一组应用程序的节点。每个节点都可以处理一部分负载，并且可以在节点之间动态分 配负载， 以实现平衡。对于网络流量也是如此。通常，单个节点对于太大的网络流量无法迅速处理，这就需要将流量发送给在其它节点。还可以根据每个节点上不同的可用资 源或网络的特殊环境来进行优化。</li>
<li>负载均衡集群在多节点之间按照一定的策略（算法）分发网络或计算处理负载。负载均衡建立在现有网络结构之上，它提供了一种廉价有效的方法来扩展服务器带宽，增加吞吐量，提高数据处理能力，同时又可以避免单点故障。</li>
</ul>
</li>
<li>web 负载均衡的作用就是把请求均匀的分配给各个节点，它是一种动态均衡，通过一些工具实时地分析数据包，掌握网络中的数据流量状况，把请求理分配出去。对于不 同的应用环境（如电子商务网站，它的计 算负荷大；再如网络数据库应用，读写频繁，服务器的存储子系统系统面临很大压力；再如视频服务应用，数据传输量大，网络接口负担重压。），使用的均衡策略 (算法)是不同的。 所以均衡策略（算法）也就有了多种多样的形式，广义上的负载均衡既可以设置专门的网关、负载均衡器，也可以通过一些专用软件与协议来实现。在OSI七层协 议模型中的第二（数据链路层）、第三（网络层）、第四（传输层）、第七层（应用层）都有相应的负载均衡策略（算法），在数据链路层上实现负载均衡的原理是 根据数据包的目的MAC地址选择不同的路径；在网络层上可利用基于IP地址的分配方式将数据流疏通到多个节点；而传输层和应用层的交换（Switch）， 本身便是一种基于访问流量的控制方式，能够实现负载均衡。</li>
<li>目前，基于负载均衡的算法主要有三种：轮循（Round-Robin）、最小连接数（Least Connections First），和快速响应优先（Faster Response Precedence）。<ol>
<li>轮循算法，就是将来自网络的请求依次分配给集群中的节点进行处理。</li>
<li>最小连接数算法，就是为集群中的每台服务器设置一个记数器，记录每个服务器当前的连接数，负载均衡系统总是选择当前连接数最少的服务器分配任务。 这要比”轮循算法”好很多，因为在有些场合中，简单的轮循不能判断哪个节点的负载更低，也许新的工作又被分配给了一个已经很忙的服务器了。</li>
<li>快速响应优先算法，是根据群集中的节点的状态（CPU、内存等主要处理部分）来分配任务。 这一点很难做到，事实上到目前为止，采用这个算法的负载均衡系统还很少。尤其对于硬件负载均衡设备来说，只能在TCP/IP协议方面做工作，几乎不可能深入到服务器的处理系统中进行监测。但是它是未来发展的方向。</li>
</ol>
</li>
<li>上面是负载均衡常用的算法，基于以上负载均衡算法的使用方式上，又分为如下几种：<ol>
<li>DNS轮询<br>最早的负载均衡技术是通过DNS来实现的，在DNS中为多个地址配置同一个名字，因而查询这个名字的客户机将得到其中一个地址，从而使得不同的客户访问不同的服务器，达到负载均衡的目的。<br>DNS负载均衡是一种简单而有效的方法，但是它不能区分服务器的差异，也不能反映服务器的当前运行状态。当使用DNS负载均衡的时候，必须尽量保证不同的 客户计算机能均匀获得不同的地址。由于DNS数据具备刷新时间标志，一旦超过这个时间限制，其他DNS服务器就需要和这个服务器交互，以重新获得地址数 据，就有可能获得不同IP地址。因此为了使地址能随机分配，就应使刷新时间尽量短，不同地方的DNS服务器能更新对应的地址，达到随机获得地址，然而将过 期时间设置得过短，将使DNS流量大增，而造成额外的网络问题。DNS负载均衡的另一个问题是，一旦某个服务器出现故障，即使及时修改了DNS设置，还是 要等待足够的时间（刷新时间）才能发挥作用，在此期间，保存了故障服务器地址的客户计算机将不能正常访问服务器</li>
<li>反向代理服务器<br>使用代理服务器，可以将请求转发给内部的服务器，使用这种加速模式显然可以提升静态网页的访问速度。然而，也可以考虑这样一种技术，使用代理服务器将请求均匀转发给多台服务器，从而达到负载均衡的目的。<br>　  这种代理方式与普通的代理方式有所不同，标准代理方式是客户使用代理访问多个外部服务器，而这种代理方式是代理多个客户访问内部服务器，因此也被称为反向代理模式。虽然实现这个任务并不算是特别复杂，然而由于要求特别高的效率，实现起来并不简单。<br>　使用反向代理的好处是，可以将负载均衡和代理服务器的高速缓存技术结合在一起，提供有益的性能。然而它本身也存在一些问题，首先就是必须为每一种服务都专门开发一个反向代理服务器，这就不是一个轻松的任务。<br>　代理服务器本身虽然可以达到很高效率，但是针对每一次代理，代理服务器就必须维护两个连接，一个对外的连接，一个对内的连接，因此对于特别高的连接请求， 代理服务器的负载也就非常之大。反向代理方式下能应用优化的负载均衡策略，每次访问最空闲的内部服务器来提供服务。但是随着并发连接数量的增加，代理服务 器本身的负载也变得非常大，最后反向代理服务器本身会成为服务的瓶颈。 <ol start="3">
<li>地址转换网关<br>支持负载均衡的地址转换网关，可以将一个外部IP地址映射为多个内部IP地址，对每次TCP连接请求动态使用其中一个内部地址，达到负载均衡的目的。很多 硬件厂商将这种技术集成在他们的交换机中，作为他们第四层交换的一种功能来实现，一般采用随机选择、根据服务器的连接数量或者响应时间进行选择的负载均衡 策略来分配负载。由于地址转换相对来讲比较接近网络的低层，因此就有可能将它集成在硬件设备中，通常这样的硬件设备是局域网交换机.</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="全局负载均衡"><a href="#全局负载均衡" class="headerlink" title="全局负载均衡"></a>全局负载均衡</h1><ul>
<li>全局负载均衡（GSLB）的负载均衡主要是在多个节点之间进行均衡，其结果可能直接终结负载均衡过程，也可能将用户访问交付下一层次的（区域或本地）负载均衡系统进行处理。GSLB最通用的是基于DNS解析方式，还有HTTP重定向、IP路由等方法</li>
<li>当需要访问abc.com这个站点时，实际上我们想要浏览的网页内容都存放在互联网中对应某个IP的服务器上，而浏览器的任务就是找到我们想要访问的这台服务器的IP地址，然后向它请求内容。</li>
<li>本地DNS服务器（local DNS server）是用户所在局域网或ISP网络中的域名服务器。当客户端在浏览器里请求abc.com时，浏览器会首先向本地DNS服务器请求将 abc.com解析成IP地址，本地DNS服务器再向整个DNS系统查询，直到找到解析结果。客户端可以配置DNS服务器或通过DHCP来分配</li>
<li>DNS给使用它的互联网应用带来额外的时延，有时时延还比较大，为了解决问题，需要引入“缓存”机制。缓存是指DNS查 询结果在主机（local DNS server）中缓存。在区内主机对某个域名发起第一次查询请求时，负责处理递归查询的DNS服务器要发送好几次查询（先查.root，再查.com之 类，再定位IP地址等）才能找到结果，不过在这过程中它也得到了许多信息，比如各区域权威DNS服务器（就是告诉你最终abc.com在哪里的DNS服务 器）和它们的地址、域名解析最终结果。他会把这些信息保存起来，当其他主机向它发起查询请求时，它就直接向主机返回缓存中能够找到的结果，直到数据过期</li>
<li>客户端浏览器也可以缓存DNS响应信息</li>
<li>Internet类资源记录分为<ul>
<li>A记录（address）：域名-&gt;多个IP的映射。对同一个域名，可以有多条A记录</li>
<li>NS记录（name server）：指定由哪台DNS服务器来解析</li>
<li>SOA记录（start of authority）：指定该区域的权威域名服务器</li>
<li>CNAME记录（canonical name）：多个域名-&gt;服务器的映射</li>
<li>PTR记录（pointer record）：IP-&gt;域名的映射</li>
</ul>
</li>
<li>DNS系统本身是具备简单负载分配能力的，这是基于DNS的轮询机制。如果有多台Web服务器（多源）同时为站点 abc.com提供服务，abc.com的权威服务器可能会解析出一个或多个IP地址。权威域名服务器还可以调整响应中IP地址的排列方式，即在每次响应 中将不同的IP地址置于首位（取决于可服务能力和服务质量），通过这种方式实现对这些Web服务器的负载均衡</li>
<li>通过CNAME方式实现负载均衡：域名服务器获得CNAME记录后，就会用记录中的别名来替换查找的域名或主机名（实现多个域名-&gt;服务器映射）。后面会查询这个别名的A记录来获取相应的IP地址。</li>
<li>具体操作为：先将GSLB的主机名定义为所查询域名的权威DNS服务器的别名，然后将GSLB主机名添加多条A记录，分别对应多个服务器的IP地址。这样，本地DNS服务器会向客户端返回多个IP地址作为域名的查询结果，并且这些IP地址的排列顺序是轮换的。客户端一般会选择首个IP地址进行访问</li>
<li>负载均衡器作为权威DNS服务器：负载均衡器就会接收所有对这个域名的DNS请求，从而能够根据预先设置的一些策略来提 供对域名的智能DNS解析。F5的DNS具有完整的DNS功能以及增强的GSLB特性，Foundry、Nortel、Cisco和Radware的产品 能实现部分DNS功能</li>
<li>负载均衡作为代理DNS服务器：负载均衡器被注册为一个域名空间的权威DNS服务器，而真正的权威域名服务器则部署在负 载均衡器后面。所有的DNS请求都会先到达负载均衡器，由负载均衡器转发到真正的权威DNS服务器，然后修改权威DNS服务器返回的响应信息。真正的权威 DNS服务器正常响应浏览器的DNS请求，返回域名解析结果列表，这个响应会先发送到负载均衡器，而负载均衡器会根据自己的策略选择一个性能最好的服务器 IP并修改需要实现GSLB的域名的DNS查询响应，对其他请求透明转发，这样就不会影响整个域名空间的解析性能。</li>
<li>在基于DNS方式下无论采用何 种工作方式，都会有一些请求不会到达GSLB，这是DNS系统本身的缓存机制在起作用。当用户请求的域名在本地DNS或本机（客户端浏览器）得到了解析结 果，这些请求就不会达到GSLB。Cache更新时间越短，用户请求达到GSLB的几率越大。由于DNS的缓存机制屏蔽掉相当一部分用户请求，从而大大减 轻了GSLB处理压力，使得系统抗流量冲击能力显著提升，这也是很多商业CDN选择DNS机制做全局负载均衡的原因之一。但弊端在于，如果在DNS缓存刷 新间隔之内系统发生影响用户服务的变化，比如某个节点故障，某个链路拥塞等，用户依然会被调度到故障部位去</li>
<li>智能DNS功能，它在向本地DNS返回应答之前会先根据一些静态或动态策略进行智能计算。<ul>
<li>服务器的“健康状况”</li>
<li>地理区域距离</li>
<li>会话保持</li>
<li>响应时间</li>
<li>IP地址权重</li>
<li>会话能力阈值</li>
<li>往返时间（TTL）</li>
<li>其他信息，包括服务器当前可用会话数、最少选择次数、轮询等</li>
</ul>
</li>
</ul>
<h2 id="关于GSLB的部署问题"><a href="#关于GSLB的部署问题" class="headerlink" title="关于GSLB的部署问题"></a>关于GSLB的部署问题</h2><ul>
<li>关于内容的缓存问题（如何智能调度最有效）和配置</li>
<li>在有些CDN中（用于视频网站加速的情况较多），网站需要加速的内容全部先缓存在OCS（内容中心），然后再将一部分 （通常是热门的内容）分发到个POP节点（Cache边缘集群），所以POP节点在某些时候会出现本地不命中而需要回OCS取内容或者从其他POP节点取 内容的情况</li>
<li>纯粹基于DNS方式的GSLB只能完成就近性判断。为实现智能调度，大多数解决方案需要在GSLB设备附近以旁路的方式 部署一台辅助设备（为方便描述，我们可称之为GRM——全局资源管理设备），用以实现和各POP节点的本地资源管理设备进行通信，完成CDN对各POP节 点的状态检查，并根据POP节点的状态和流量情况，重新制订用户调度策略，将策略实时发送到GSLB中去执行</li>
<li>因为DNS服务采用以UDP为基础的、默认无连接的访问方式，给分布式攻击（DDoS）带来了更大的便利。（有DNSSEC可以提供某程度的DDoS攻擊保護）</li>
<li>隐藏节点的存在很大程度上可以避免GSLB被攻击致瘫痪的机会，实际隐藏节点的实现方法就是在实际组网时除了部署正常工作的GSLB以外，再部署一台备份的GSLB设备，并将这一备份GSLB设备隐藏起来，不对外公布。</li>
<li>HTTP重定向（CDN GSLB用302重定向）：在HTTP协议中，有三类重定向状态吗：301永久性转移（permanently moved）、302暂时转移（temporarily moved）、meta fresh在特定时间后重定向到新的网页</li>
<li>HTTP重定向只适用于HTTP应用，不适用于任何其他应用。比如微软的MMS协议，RTSP协议，就不能使用这种方式 进行重定向。其次，由于HTTP重定向过程需要额外解析域名URL，还需要与URL建立TCP连接并且发送HTTP请求，使得响应时间加长。第三，不同于 DNS方式，没有任何用户请求能被外部系统终结（不能缓存），所有请求都必须进入GSLB系统，这将成为性能和可靠性的瓶颈。（流媒体用的比较多）</li>
<li>基于IP路由的GSLB</li>
<li>基于路由协议算法选择一条路由到达这两个本地均衡器中的一个。因为每次访问请求的终端IP地址不同，路由条件也不同，所以在多个路由器上优选的路由不同，从统计复用的角度来看基本是在负载均衡器1和2之间均匀分布的。</li>
<li>IP路由在多个POP点之间实现的负载均衡是一种概率上的均衡，而不是真正的均衡（没做智能调度）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>比较项</strong></th>
<th><strong>基于DNS解析方式</strong></th>
<th><strong>基于HTTP重定向方式</strong></th>
<th><strong>基于IP路由方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>本地DNS服务器和用户终端DNS缓存能力使GSLB的负载得到有效分担</td>
<td>GSLB处理压力大，容易成为系统性能的瓶颈</td>
<td>借助IP网络设备完成负载均衡，没有单点性能瓶颈</td>
</tr>
<tr>
<td>准确度</td>
<td>定位准确度取决于本地DNS覆盖范围，本地DNS设置错误会造成定位不准确</td>
<td>在对用户IP地址数据进行有效维护的前提下，定位准确且精度高</td>
<td>就近性调度准确，但对设备健康性等动态信息响应会有延迟</td>
</tr>
<tr>
<td>效率</td>
<td>效率约等于DNS系统本身处理效率</td>
<td>依靠服务器做处理，对硬件资源的要求高</td>
<td>效率约等于IP设备本身效率</td>
</tr>
<tr>
<td>扩展性</td>
<td>扩展性和通用性好</td>
<td>扩展性较差，需对各种应用协议进行定制开发</td>
<td>通用性好，但适用范围有限</td>
</tr>
<tr>
<td>商用性</td>
<td>在Web加速领域使用较多</td>
<td>国内流媒体CDN应用较多</td>
<td>尚无商用案例</td>
</tr>
</tbody></table>
<h1 id="流媒体CDN系统的组成"><a href="#流媒体CDN系统的组成" class="headerlink" title="流媒体CDN系统的组成"></a>流媒体CDN系统的组成</h1><ul>
<li>流媒体业务是一种对实时性、连续性、时序性要求非常高的业务，无论从带宽消耗上还是质量保障上来说，对best-effort的IP网络都是一个不小的冲击<ul>
<li>高带宽要求</li>
<li>高QoS要求</li>
<li>组播、广播要求（目前IP网络无法实现端到端的组播业务）</li>
</ul>
</li>
<li>播放一个视频分为以下四个步骤<ul>
<li>Access</li>
<li>Demux（音视频分离）</li>
<li>Decode（解码解压缩）</li>
<li>Output</li>
</ul>
</li>
<li>RTP、RTCP、RTSP、RTMP的关系：RTSP协议用来实现远程播放控制，RTP用来提供时间信息和实现流同步，RTCP协助RTP完成传输质量控制&lt;=（播放控制），</li>
<li>=&gt;（传输控制）RTMP和HTTP streaming则是将流同步、播放控制、质量控制集成起来的企业自有流媒体传送协议</li>
<li>RTMP是adobe的传输协议。RTMP的基本通信单元：消息块（chunk）和消息（message）</li>
<li>RTMP协议架构在TCP层之上，但RTMP消息并不是直接封装在TCP中，而是通过一个被称为消息块的封装单元进行传输。消息在网络上发送之前往往需要分割成多个较小的部分，这样较小的部分就是消息块，属于不同消息流的消息块可以在网络上交叉发送。</li>
<li>RTSP/RTP和HTTP streaming是目前应用最广泛的流化协议，目前电信运营商在IPTV（特殊通道的基于IP的流媒体播放）的流化上主要以RTSP/RTP技术为主，而互联网视频网站（点播/直播）则多倾向于使用HTTP streaming的流化技术。</li>
<li>HTTP streaming前身是progressive download（渐进式下载：边下载边播放，直到下载完）。HTTP streaming首先会将视频数据（包括直播的视频流和点播的视频文件）在服务器上进行编码，然后将编码后的数据进行更细粒度的分片，再把每个分片通过 HTTP协议传输到客户端。HTTP streaming的客户端需要对视频文件的每个分片都发出一个HTTP请求，这样，在视频播放速度低于下载速度的情况下，客户端可以灵活控制HTTP请 求的发出速度，从而保证用户在中途退出时不会出现下载浪费。另外，因为采用分片的特点，HTTP streaming还可以实现媒体播放过程中的码率切换（码率自适应），结合网络带宽资源，为用户提供更好的体验。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>HTTP streaming</strong></th>
<th><strong>Progressive download</strong></th>
</tr>
</thead>
<tbody><tr>
<td>支持点播、直播</td>
<td>仅支持点播</td>
</tr>
<tr>
<td>可对分片文件加密，保证数字版权</td>
<td>直接把媒体文件分割成多个小文件分片，无法保障版权所有</td>
</tr>
<tr>
<td>因为分片传输，故支持码率自适应</td>
<td>只支持固定码率</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>HTTP streaming</strong></th>
<th><strong>RTSP/RTP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>基于TCP，更高可靠性，也可以直接利用TCP的流控机制来适应带宽的变化</td>
<td>基于UDP</td>
</tr>
<tr>
<td>可将播放过的内容保存在客户端</td>
<td>不能保存在客户端</td>
</tr>
<tr>
<td>使用80端口，能穿越防火墙</td>
<td>使用特殊端口</td>
</tr>
<tr>
<td>采用标准的HTTP协议来传输，只需要标准的HTTP服务器支撑</td>
<td>需要特殊的流媒体服务器</td>
</tr>
</tbody></table>
<ul>
<li>HTTP streaming的几个主流阵营：<ul>
<li>3GPP adaptive HTTP Streaming</li>
<li>Microsoft IIS Smooth Streaming</li>
<li>Adobe HTTP Dynamic Streaming (HDS)</li>
<li>Apple HTTP Live Streaming (HLS)</li>
</ul>
</li>
<li>HLS流化技术主要分三个部分：服务器组件、分发组件和客户端软件<ul>
<li>服务器组件主要负责从原始的音视频设备捕捉相应的音视频流，并对这些输入的媒体流进行编码，然后进行封装和分片，最后交付给分发组件来进行传送；</li>
<li>分发组件主要负责接收客户端发送的请求，然后将封装的流媒体分片文件连同相关的索引文件一起发送给客户端。对于没有采用CDN服务的源服务器，标准的 Web服务器就是一个分发组件，而对于大型的视频网站或者类似的大规模应用平台，分发组件还应包括支持RTMP协议的CDN；</li>
<li>客户端软件负责确定应该请求的具体媒体流，下载相关资源，并在下载后通过拼接分片将流媒体重新展现给用户</li>
</ul>
</li>
<li>HLS音视频流或流媒体文件在经过编码、封装和分片后，变成多个以.ts结尾的分片文件。流分割器产生的索引文件是以.M3U8为后缀的，用户可以直接通过Web访问来获取</li>
<li>分发组件负责将分片文件和索引文件通过HTTP的方式发送给客户端，无须对现有的Web服务器和Cache设备进行额外的扩展、配置和升级</li>
<li>客户端组件根据URL来获取这个视频的索引文件。索引文件包含了可提供分片文件的具体位置、解密密钥以及可用的替换流。</li>
<li>HDS，点播内容是通过一个简单的预编码生成MP4片段以及Manifest清单文件；直播的内容准备工作流程相对复杂一点，在播放的过程中生成MP4.（直播推荐用RTMP，使用FMS推流器）</li>
<li>MPEG-2 TS是指TS格式封装的、MPEG-2编码格式的媒体流。大多数IPTV系统使用这种内容源。H.264这一层完成原始文件的压缩编码，TS这一层负责音 视频的复用以及同步，RTP这一层负责流的顺序传输，UDP这一层负责数据包的交付，IP层负责传输路由选择</li>
<li>流媒体加速的回源要求：因为流媒体文件传送带宽需求高，而且往往需要维持TCP长连接，所以一旦CDN回源比例过高，源 站服务器I/O将不堪负荷。CDN对内容采取分发方式分为pull和push两种。Pull是被动下拉的方式，push是主动推送的方式。对于流媒体内 容，系统一般会选择对热点内容采取push方式的预分发，而普通的网页内容几乎100%是pull方式的。</li>
<li>在流媒体CDN系统中，用户访问的调度会更多考虑内容命中，主要是因为流媒体内容文件体积大，业务质量要求高，如果从其 他节点拉内容再向用户提供服务会带来额外的延迟，影响用户体验。为进一步提高命中率，流媒体CDN系统普遍采用了对热点内容实施预先push的内容分发策 略</li>
<li>在流媒体服务系统中，主要关注的技术是对不同流媒体协议、不同编码格式、不同播放器、不同业务质量要求等的适应。</li>
<li>流媒体CDN与Web CDN的对比（业务差异）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>主要差异点</strong></th>
<th><strong>流媒体CDN</strong></th>
<th><strong>Web CDN</strong></th>
</tr>
</thead>
<tbody><tr>
<td>内容类型</td>
<td>大文件、实时流、QoS要求高</td>
<td>小文件、固定大小、QoS要求低</td>
</tr>
<tr>
<td>用户行为</td>
<td>拖曳、暂停等播放控制</td>
<td>下载后浏览</td>
</tr>
<tr>
<td>内容管理</td>
<td>内容冷热度差异明显（对命中率要求高），内容生命周期长</td>
<td>内容冷热度差异不明显，内容生命周期短</td>
</tr>
<tr>
<td>回源要求</td>
<td>回源比例小</td>
<td>回源比例大</td>
</tr>
</tbody></table>
<ul>
<li>现在已经投入商用的CDN系统，基本都是同时提供Web CDN能力和流媒体CDN能力的，而且这两种能力的实现在系统内部几乎都是互相隔离的，从调度系统到节点设备都没有交叉互用</li>
<li>流媒体CDN与Web CDN的设计差异（设计差异）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>主要差异点</strong></th>
<th><strong>流媒体CDN</strong></th>
<th><strong>Web CDN</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Cache</td>
<td>支持多种流化协议，硬件配置大存储、高I/O</td>
<td>支持多协议（HTTP、FTP等）硬件配置小存储、高性能CPU</td>
</tr>
<tr>
<td>负载均衡</td>
<td>DNS+HTTP重定向方式</td>
<td>DNS方式</td>
</tr>
<tr>
<td>内容分发方式</td>
<td>热片PUSH，冷片PULL</td>
<td>全PULL方式</td>
</tr>
<tr>
<td>组网</td>
<td>多级组网，可能要求组播、单播混合组网</td>
<td>两级组网</td>
</tr>
</tbody></table>
<ul>
<li>流媒体CDN的Cache设备与Web Cache无论在软件实现还是硬件要求上差异都很大，我们很少看到这两种业务共用同一台设备</li>
<li>当用户请求的内容在Cache上命中时，Cache直接向用户提供流服务，此时Cache设备充当流媒体服务器的角色； 当用户请求内容未能在Cache上命中时，Cache会从上一级Cache（二级缓存设备或中间缓存设备）或者源站服务器获取内容，再提供给用户。 Cache在用户与另一个流媒体服务器之间扮演代理的角色</li>
<li>分布式存储技术因其大容量、低成本的特点，目前也被业界关注和研究作为流媒体CDN系统的存储解决方案之一。常用的分布 式存储技术包括分布式文件系统和分布式数据库，由于采用了数据副本冗余（每份数据复制2~3份）、磁盘冗余（Raid1、Raid10、Raid5）等技 术，通常可以提供良好的数据容错机制，当单台存储设备断电或者单个存储磁盘失效时，整个存储系统仍能正常工作</li>
<li>负载均衡设备在进行用户访问调度时，会综合考虑很多静态的、动态的参数，包括IP就近性、连接保持、内容命中、响应速 度、连接数等。但没有哪个CDN会考虑所有参数，而是会根据业务特点进行一些取舍，否则均衡系统就太复杂了。而流媒体CDN在进行用户访问调度时，会更多 考虑内容命中这一参数</li>
<li>有两种GSLB实现方式，一种是基于DNS的，一种是基于应用层重定向的</li>
<li>PUSH方式适合内容访问比较集中的情况，如热点的影视流媒体内容，PULL方式比较适合内容访问分散的情况</li>
<li>对使用CDN服务的SP来说，CDN的作用在于尽量就近为用户提供服务，帮助SP解决长距离IP传输和跨域传输带来的种 种业务质量问题（通过空间换取时间）。因此，为用户提供服务的Cache设备一定部署在离用户比较近的地方。另一方面，CDN的建设者从成本角度考虑，又 不能把所有内容都存放在这些离用户最近的节点中，这会消耗大量存储成本，所以这些提供服务的Cache设备会根据需要从源站服务器或者其他Cache获取 内容。这样就形成了CDN网络分层部署的概念。</li>
<li>从网络分层上看，Web CDN通常是两级架构（也有三级架构以减少回源），即中心-边缘。而流媒体CDN通常有三级以上架构，即中心-区域-边缘。产生这种区别的原因在于流媒体 回源成本比较高，源站服务器响应一次流媒体内容回源请求，要比Web内容回源消耗更多资源。尤其对于流媒体直播业务来说，只要直播节目没结束，服务器就需 要长时间持续吐流，如果没有第二层节点作为中继，那么中心节点的压力将是不可想象的。</li>
<li>分层部署的方式，对点播业务而言的主要意义是节省存储成本，对直播业务而言在于减少带宽成本。在点播业务中，边缘Cache只需存储用户访问量大的内容或者内容片断，其余内容存储在区域Cache中。</li>
<li>在直播业务中，边缘Cache从区域中心获取直播流，而不需要直接向中心节点（源站）获取，从而节省了区域中心到中心节点这一段的大部分带宽。因为直播流在各个Cache中都不需要占用很大的存储空间，只需少量缓存空间即可，所以直播业务方面并不用注重考虑存储成本</li>
<li>考虑到电信运营商的IP拓扑和流量模型，区域中心Cache通常部署在重点城市的城域网出口的位置，以保障向各个边缘 Cache的链路通畅。边缘Cache的位置选择则以整个节点能够提供的并发能力为主要依据，依据业务并发数收敛比，计算出单个Cache需要覆盖的用户 规模，从而选择一个合适的部署位置。当然，边缘Cache离用户越近，服务质量越好，但覆盖的用户数越少，部署成本越高。</li>
<li>内容文件预处理</li>
<li>是指视频内容进入CDN以后，进入内容分发流程之前，CDN系统对内容进行的一系列处理过程。这个预处理过程的目的有几个：<ul>
<li>为全网内容管理提供依据，比如对内容进行全网唯一标识，对内容基础信息进行记录等</li>
<li>为提高CDN服务效率或降低系统成本提供手段，比如内容切片</li>
<li>为满足业务要求提供能力，比如对同一内容进行多种码率的转换以满足动态带宽自适应或三屏互动业务要求</li>
</ul>
</li>
<li>视频转码(video transcoding)</li>
<li>码率转换<ul>
<li>空间分辨率转换</li>
<li>时间分辨率转换</li>
<li>编码格式转换。编码格式主要包括H.264、MPEG-4、MPEG-2、VC-1、REAL、H.263、WMV。通常是把其他编码格式转换成H.264</li>
</ul>
</li>
<li>文件切片<ul>
<li>是指按照一定的规则把一个完整的文件切成大小一致的若干个小文件；由于流媒体CDN需要提供的内容体积越来越大，传统整片存储带来的成本消耗超出了CDN服务商的承受范围；切片的另一个目的是，使边缘Cache能够支持自适应码率业务</li>
</ul>
</li>
<li>防盗链机制和实现<ul>
<li>基于IP的黑白名单</li>
<li>利用HTTP header的referer字段</li>
<li>使用动态密钥（随机生成的key通过算法生成新的url）</li>
<li>在内容中插入数据（对有版权内容进行加密（DRM），如Microsoft的playready，Google的Widevine）</li>
<li>打包下载：在原文件的基础上进一步封装，使得资源的hash 值改变</li>
</ul>
</li>
</ul>
<h1 id="动态内容加速服务的实现"><a href="#动态内容加速服务的实现" class="headerlink" title="动态内容加速服务的实现"></a>动态内容加速服务的实现</h1><ul>
<li>随着Web2.0的兴起，产生了动态网页、个性化内容、电子交易数据等内容的加速，这些就涉及了动态内容加速技术。</li>
<li>静态内容的加速，都是对于表现层的加速，对于动态页面等内容的加速，则要涉及逻辑层和数据访问层的加速技术</li>
<li>动态内容的提供不仅仅是HTML页面的设计及编辑，它还需要有后台数据库、应用逻辑程序的支持，以实现与用户的动态交互。</li>
<li>Web系统由表现层、业务逻辑层、数据访问层+用户数据层</li>
<li>表现层是Web系统与外部系统的交互界面，这一层通常由HTTP服务器组成，负责接收用户端的HTTP内容访问请求，从文件系统中读取静态文件</li>
<li>业务逻辑层负责处理所有业务逻辑和动态内容的生成</li>
<li>数据访问层位于系统的后端，负责管理Web系统的主要信息和数据存储，通常由数据库服务器和存储设备组成</li>
<li>用户数据层负责存储用户信息数据和关联关系，内容来自用户提供和用户行为分析结果</li>
<li>Web网站借助CDN技术能够获得更好的扩展性和高性能，核心在于CDN采用的缓存（caching）和复制（replication）机制，其中缓存是将最近经常被访问的源服务器拥有的内容复制到边缘服务器上，可被视为具有特定策略的复制。</li>
<li>CDN的复制机制是指将源Web系统逻辑架构的各个层次的相应功用复制到边缘服务器上实现，以缓解源系统的处理压力。<ul>
<li>Web系统表现层的复制，就是静态内容的复制。边缘服务器又被称为代理服务器，通过反向代理加速静态文件的交付</li>
<li>Web系统业务逻辑层的复制。CDN被用于改进动态生成内容的交付性能。即将应用程序和业务组件直接在CDN的边缘服务器中计算，从而直接在靠近用户的地方生成动态Web内容</li>
<li>– Akamai边缘计算部署模型，包括用户（使用浏览器）、企业J2EE应用系统（运行业务逻辑、原有系统、数据库等）、分布式网络服务器（Edge computing平台）运行支持J2EE应用编程模型的WebSphere或者Tomcat应用服务器</li>
<li>Web系统数据访问层复制。CDN边缘服务器能够具备生成动态内容和掌管内容生成数据的能力</li>
<li>– 利用边缘服务器代替源钻Web系统的后台数据访问层中的数据库系统，及时响应业务逻辑层提出的数据查询需求。</li>
<li>Web系统用户文件的复制。</li>
</ul>
</li>
<li>应用加速技术实际上是传统的网络负载均衡的升级和扩展，综合使用了负载均衡（智能调度）、TCP优化管理（TCP keep-alive connection，更激进的TCP窗口策略，基于HTTP1.1），链接管理（routing）、SSL VPN、压缩优化（代码压缩，图片压缩）、智能网络地址（NAT-公私网IP转换）、高级路由、智能端口镜像等技术。）</li>
<li>TCP的问题<ul>
<li>TCP窗口大小的限制（TCP窗口大小随传输成功而变大，而一旦发生传输失败，其窗口大小会立即缩小）</li>
<li>TCP协议慢启动（三握手）和拥塞控制</li>
</ul>
</li>
<li>广域网加速关键技术</li>
</ul>
<table>
<thead>
<tr>
<th><strong>针对层次</strong></th>
<th><strong>优化技术</strong></th>
<th><strong>优化原理</strong></th>
</tr>
</thead>
<tbody><tr>
<td>传输发起端</td>
<td>原始数据优化</td>
<td>通过压缩、重复数据删除和字典等技术，可节省绝大多数传输数据量，节约带宽，提高服务器性能</td>
</tr>
<tr>
<td>数据缓存技术</td>
<td>将类HTTP的业务、图片、文字等缓存在本地，只传输动态内容，减少带宽占用</td>
<td></td>
</tr>
<tr>
<td>物理层（硬件）</td>
<td>提升设备性能</td>
<td>基于现有TCP/IP，通过硬件方式提高性能，提高大量TCP并发连接和会话重组等处理能力</td>
</tr>
<tr>
<td>网络层（IP）</td>
<td>QoS和流量控制</td>
<td>通过协议识别，实现在同一端口中不同应用的真正区分，进而通过分流实现时延敏感应用的带宽保障</td>
</tr>
<tr>
<td>传输层（TCP）</td>
<td>代理设备</td>
<td>在传输两端各架设代理设备，所有的响应报文都在本地完成，只有真正发起请求时才通过链路，相当于同时在服务器和客户端进行协议欺骗</td>
</tr>
<tr>
<td></td>
<td>TCP协议优化</td>
<td>通过在广域网两端部署专用设备，在不影响基本传输情况下，通过各种手段对TCP窗口、响应、启动等机制进行改进，从而提高协议机制的效率</td>
</tr>
<tr>
<td>应用层</td>
<td>应用代理（缓存）</td>
<td>将常用的应用程序缓存在本地并配置好，用户可不用在本地等待类似于认证等会话过程，而是直接开始下一个应用，实现流水作业</td>
</tr>
</tbody></table>
<ul>
<li>数据碎片化，就是在应用层将数据分成一个个小的数据块，便于后续的数据比对使用。广域网加速设备在传输数据前会将缓存中的数据与数据切块进行对比，从而找出那些数据是重复数据，不再发送，哪些数据是新鲜的、需要传输的数据。</li>
<li>数据压缩和指针技术一般是放在一起使用的，在对数据分段后，会对每一段数据生成一个数据指针，对于重复内容，只传输指针。在压缩算法设计上，要求同时兼顾数据压缩比和压缩/解压缩时间。</li>
<li>高速TCP传输技术<ul>
<li>自适应拥塞窗口</li>
<li>有限制地快速重传</li>
<li>连接池：通过维护一个预先建立好的TCP连接池，当有数据传输需求时，从连接池中挑选一条可用连接传输。</li>
</ul>
</li>
<li>SSL加速技术<ul>
<li>SSL加密是一种处理器密集型加密算法，如果用服务器软件处理会消耗大量CPU资源，一般会在提供业务能力的服务器外围部署专门的SSL加速设备，采用硬解密方式实现</li>
<li>SSL加密分对称秘钥和非对称秘钥（计算资源消耗更大）</li>
</ul>
</li>
<li>SSL的基本原理和实现<ul>
<li>可认证性（authentication）</li>
<li>隐私性（privacy）</li>
<li>完整性（integrity）</li>
<li>不可抵赖性（undeniability）：发送者不能自称没有发出过接受者从他那里收到的内容</li>
</ul>
</li>
<li>SSL加速<ul>
<li>通常是基于硬件的SSL加速</li>
<li>通过在服务器上安装一块SSL加速板卡，可有效分担服务器CPU处理SSL事务的压力</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/12/Kubernetes-架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/Kubernetes-架构/" itemprop="url">Kubernetes 架构</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T18:51:51+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/K8S/" itemprop="url" rel="index">
                    <span itemprop="name">K8S</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h1><p> Kubernetes借鉴了Brog的设计理念，比如Pod、Service、Lables和单Pod单IP等。整体架构如下所示</p>
<p><img src="https://i.loli.net/2019/08/12/Wcv4PLCFgJ26imV.png" alt="assets_-LDAOok5ngY4pc1lEDes_-La8Wy3SQAP-8onLZ7uT_-La8X6lf7UjRFyBsrhpw_components.png"></p>
<ul>
<li><p>etcd保存了集群的状态信息</p>
</li>
<li><p>kube-apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现机制</p>
</li>
<li><p>kube-controller-manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等</p>
</li>
<li><p>kube-scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</p>
</li>
<li><p>kubelet 负责维持容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理</p>
</li>
<li><p>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI），默认的容器运行时为 Docker；</p>
</li>
<li><p>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/08/12/WyA6Jpo52BINwm8.png" alt="assets_-LDAOok5ngY4pc1lEDes_-La8Wy3SQAP-8onLZ7uT_-La8X6ljrf3pM1bbtQ_0_core-packages.png"></p>
<p>除了核心组件，还有一些推荐的 Add-ons：</p>
<ul>
<li><p>kube-dns 负责为整个集群提供 DNS 服务</p>
</li>
<li><p>Ingress Controller 为服务提供外网入口</p>
</li>
<li><p>Heapster 提供资源监控</p>
</li>
<li><p>Dashboard 提供 GUI</p>
</li>
<li><p>Federation 提供跨可用区的集群</p>
</li>
<li><p>Fluentd-elasticsearch 提供集群日志采集、存储与查询</p>
</li>
</ul>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p><img src="https://i.loli.net/2019/08/12/xEBCcQ1YHAhqgP3.png" alt="assets_-LDAOok5ngY4pc1lEDes_-La8Wy3SQAP-8onLZ7uT_-La8X6lnG-e8vfXmSbwl_core-ecosystem.png"></p>
<ul>
<li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境</li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）</li>
<li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）</li>
<li>接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦</li>
<li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴<ul>
<li>Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、ChatOps 等</li>
<li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等</li>
</ul>
</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><img src="https://i.loli.net/2019/08/12/vmC7XRnEJpOoHzb.png" alt="assets_-LDAOok5ngY4pc1lEDes_-La8Wy3SQAP-8onLZ7uT_-La8X6llZfuE65sGzUkc_core-apis.png"></p>
<h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p><img src="https://i.loli.net/2019/08/12/BXUHhx5ofuyJsL2.jpg" alt="assets_-LDAOok5ngY4pc1lEDes_-La8Wy3SQAP-8onLZ7uT_-La8X6lhezSJ3ufUcmlH_14937095836427.jpg"></p>
<h2 id="生态系统"><a href="#生态系统" class="headerlink" title="生态系统"></a>生态系统</h2><p><img src="https://i.loli.net/2019/08/12/PO76KHBXYpUveaW.png" alt="assets_-LDAOok5ngY4pc1lEDes_-La8Wy3SQAP-8onLZ7uT_-La8X6ldNQWZNfl3OJ9M_architecture.png"></p>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><h2 id="API设计原则"><a href="#API设计原则" class="headerlink" title="API设计原则"></a>API设计原则</h2><ol>
<li><p>所有API都是声明式</p>
</li>
<li><p>API对象比西湖不而且可组合</p>
</li>
<li><p>高层API以操作意图为基础设计</p>
</li>
<li><p>底层API更具高层API的控制需要设计</p>
</li>
<li><p>尽量避免简单封装，不要有外部API无法显式知道内部隐藏的机制</p>
</li>
<li><p>API操作复杂度与对象数量成正比</p>
</li>
<li><p>API对象状态不能依赖于网络连接状态</p>
</li>
<li><p>尽量避免让操作机制依赖于全局状态，分布式系统中要保证全局状态的同步是非常困难的</p>
<h2 id="控制设计原则"><a href="#控制设计原则" class="headerlink" title="控制设计原则"></a>控制设计原则</h2></li>
</ol>
<ul>
<li>控制逻辑只依赖于当前状态</li>
<li>假设任何错误的可能，并做容错助理</li>
<li>尽量避免复杂状态机制，控制逻辑不要依赖无法监控的内部状态</li>
<li>假设任何操作都可能被任何操作对象拒绝，甚至错误解析</li>
<li>每个模块都可以在出错之后自动恢复</li>
<li>每个模块都可以在必要时优雅地降级服务<h2 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h2></li>
<li>只有apiserver可以直接访问etcd存储，其他服务必须通过KubernetesAPI来访问集群状态</li>
<li>单点故障不影响集群状态</li>
<li>在没有新请求的情况下，所有组件应该在故障恢复后继续执行上次最后收到的请求（比如网络分区或服务重启等）</li>
<li>所有组件都应该在内存中保持所需要的状态，apiserver将状态写入etcd存储，而其他组件则通过apiserver更新并监听所有的变化</li>
<li>优先使用事件监听而不是轮询<h1 id="核心技术概念和API对象"><a href="#核心技术概念和API对象" class="headerlink" title="核心技术概念和API对象"></a>核心技术概念和API对象</h1></li>
</ul>
<p>API对象是K8s集群中的管理操作单元。K8s集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica Set对应的API对象是RS。</p>
<p>每个API对象都有3大类属性：<font color="red"><strong>元数据metadata、规范spec和状态status</strong></font>。元数据是用来标识API对象的，每个对象都至少有3个元数据：namespace，name和uid；除此以外还有各种各样的标签labels用来标识和匹配不同的对象，例如用户可以用标签env来标识区分不同的服务部署环境，分别用env=dev、env=testing、env=production来标识开发、测试、生产的不同服务。规范描述了用户期望K8s集群中的分布式系统达到的理想状态（Desired State），例如用户可以通过复制控制器Replication Controller设置期望的Pod副本数为3；status描述了系统实际当前达到的状态（Status），例如系统当前实际的Pod副本数为2；那么复本控制器当前的程序逻辑就是自动启动新的Pod，争取达到副本数为3。</p>
<p>K8s中所有的配置都是通过API对象的spec去设置的，也就是用户通过配置系统的理想状态来改变系统，这是k8s重要设计理念之一，即所有的操作都是声明式（Declarative）的而不是命令式（Imperative）的。声明式操作在分布式系统中的好处是稳定，不怕丢操作或运行多次，例如设置副本数为3的操作运行多次也还是一个结果，而给副本数加1的操作就不是声明式的，运行多次结果就错了。</p>
<h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><ul>
<li>Master是集群控制节点，每个K8S集群里需要Master负责整个集群的管理和控制，K8S所有控制命令都是发给它，由其负责具体执行和调度。</li>
<li>Master上运行的关键进程<ul>
<li>Kubernetes API Server（Kube-apiserver）,提供哦你了HTTP Rest接口的关键服务进程，是K8S里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程</li>
<li>Kubernetes Controller Manager（kube-controller-manager）,K8S里所有资源对象的自动化控制中心，资源对象的“大总管”</li>
<li>Kubernetes Scheduler（kube-scheduler）,负责资源调度（Pod调度）的进程，相当于“调度室；</li>
<li>etcd Server进程，K8S集群资源对象的数据全部保存在etcd中<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2></li>
</ul>
</li>
<li>Node节点是K8S集群中工作负载节点，每个Node都会被Master分配相应的工作负载</li>
<li>Node节点上运行的关键进程<ul>
<li>kubelet:负责Pod对应的容器创建、启停等任务，同时与Master节点密切协作，实现集群管理的基本功能</li>
<li>kube-proxy:实现K8S Service的通信与负载均衡机制的重要组件</li>
<li>Docker Engine: Docker引擎，负责容器的创建和管理工作<h2 id="POD"><a href="#POD" class="headerlink" title="POD"></a>POD</h2></li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/08/12/3TdApJyxroRDPg9.png" alt="assets_-LDAOok5ngY4pc1lEDes_-LM_rqip-tinVoiFZE0I_-LM_sIwx4E3-69Ml-jNW_pod.png"></p>
<ul>
<li>Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8s最基础的设计理念。</li>
<li>Pod是K8s集群中所有业务类型的基础，可以看作运行在K8s集群中的小机器人，不同类型的业务就需要不同类型的小机器人去执行。</li>
<li>目前K8s中的业务主要可以分为长期伺服型（long-running）、批处理型（batch）、节点后台支撑型（node-daemon）和有状态应用型（stateful application）；分别对应的小机器人控制器为Deployment、Job、DaemonSet和StatefulSet。<h2 id="Replication-controller（RC）"><a href="#Replication-controller（RC）" class="headerlink" title="Replication controller（RC）"></a>Replication controller（RC）</h2></li>
<li>RC是K8S系统中核心概念之一，定义了一个期望的场景，即生命某种Pod的副本数量在任意时刻都符合某个预期值。通过监控运行中的Pod来保证集群中运行指定数目的Pod副本。</li>
<li>RC的都能够以包括如下<ul>
<li>Pod期待的副本数（replicas）</li>
<li>用于筛选目标Pod的Label Selector</li>
<li>当Pod的副本书两小于预期数量的时候，用于创建新Pod的Pod模板（template）</li>
</ul>
</li>
<li>RC是K8s较早期的技术概念，<font color="green"><strong>只适用于长期伺服型的业务类型</strong></font>，比如控制小机器人提供高可用的Web服务。<h2 id="Replica-Set（RS）"><a href="#Replica-Set（RS）" class="headerlink" title="Replica Set（RS）"></a>Replica Set（RS）</h2></li>
<li>RS 是新一代RC，提供同样的高可用能力，能够支持更多种类的匹配模式。RS对象一般不单独使用，而是作为Deployment的理想状态参数使用。<h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2></li>
<li>解决Pod的编排问题</li>
<li>部署是一个比RS应用模式更广的API对象，可以是创建一个服务，更新一个服务，或者滚动升级一个服务（滚动升级实际是创建新的RS，然后逐渐在新的RS中副本增加到理想状态，然后逐步将旧的RS中的副本减少到0）</li>
</ul>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p> <img src="https://i.loli.net/2019/08/12/wlO8dfNvkq3r9sy.png" alt="assets_-LDAOok5ngY4pc1lEDes_-LM_rqip-tinVoiFZE0I_-LM_sIx5Qc9S275Z49_6_14731220608865.png"></p>
<ul>
<li>RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这些服务的问题。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。</li>
<li>要稳定地提供服务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对应的后端服务实例。在K8S集群中，客户端需要访问的服务就是Service对象。</li>
<li><strong>每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务</strong></li>
<li>*<em>在K8S集中微服务的负载均衡是由Kube-proxy实现的 *</em></li>
<li>Kube-proxy是K8s集群内部的负载均衡器。它是一个分布式代理服务器，在K8s的每个节点上都有一个；这一设计体现了它的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用节点也随之增多<h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2></li>
<li>Job是K8s用来控制批处理型任务的API对象。批处理业务与长期伺服业务的主要区别是批处理业务的运行有头有尾，而长期伺服业务在用户不停止的情况下永远运行。Job管理的Pod根据用户的设置把任务成功完成就自动退出了。成功完成的标志根据不同的spec.completions策略而不同：单Pod型任务有一个Pod成功就标志完成；定数成功型任务保证有N个任务全部成功；工作队列型任务根据应用确认的全局成功而标志成功。<h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2></li>
<li>后台支撑型服务的核心关注点在K8s集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能是通过nodeSelector选定的一些特定节点。</li>
<li>典型的后台支撑型服务包括，存储，日志和监控等在每个节点上支撑K8s集群运行的服务<h2 id="StatefulSett"><a href="#StatefulSett" class="headerlink" title="StatefulSett"></a>StatefulSett</h2></li>
<li>RC和RS主要是控制提供无状态服务的，其所控制的Pod的名字是随机设置的，一个Pod出故障了就被丢弃掉，在另一个地方重启一个新的Pod，名字变了、名字和启动在哪儿都不重要，重要的只是Pod总数。</li>
<li>StatefulSet是用来控制有状态服务，StatefulSet中的每个Pod的名字都是事先确定的，不能更改</li>
<li>对于RC和RS中的Pod，一般不挂载存储或者挂载共享存储，保存的是所有Pod共享的状态，Pod像牲畜一样没有分别（这似乎也确实意味着失去了人性特征）</li>
<li>对于StatefulSet中的Pod，每个Pod挂载自己独立的存储，如果一个Pod出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来Pod的存储继续以它的状态提供服务</li>
<li>适合于StatefulSet的业务包括数据库服务MySQL和PostgreSQL，集群化管理服务Zookeeper、etcd等有状态服务</li>
</ul>
<h2 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h2><ul>
<li>Pod中能够被多个容器访问的共享目录，与Pod生命周期相同，与容器生命周期不相关</li>
<li>类型：<ol>
<li>emptyDir ：初始内容为空，无需指定宿主机上对应目录文件，临时空间</li>
<li>hostpath ：Pod上挂载宿主机上的文件或目录</li>
<li>gcePersistentDisk:Pod上的内容会被永久保存，即使Pod删除（node节点在GCE环境）</li>
<li>awsElasticBlockStore:同上，AWS云环境</li>
<li>NFS</li>
<li>其他类型：iscsi、glusterfs、rbd、gitRepo、flocker、secret(加密)</li>
</ol>
</li>
</ul>
<h2 id="Persistent-Volume"><a href="#Persistent-Volume" class="headerlink" title="Persistent Volume"></a>Persistent Volume</h2><ul>
<li>PV只能是网络存储，不属于任何Node，但可以在每个Node上访问</li>
<li>PV并不定义在Pod上，而是独立于Pod之外定义</li>
<li>PV目前只有几种类型：GCE Persistent Disks、NFS、RBD、iSCSI、AWSEBS、GlusterFS等</li>
</ul>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><ul>
<li>集群内部的资源对象”分配“到不同的Namespace中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源同时还能被分别管理</li>
</ul>
<h2 id="Label（标签）"><a href="#Label（标签）" class="headerlink" title="Label（标签）"></a>Label（标签）</h2><ul>
<li>Label是一个Key=value的键值对，key和value由用户自己定义。Label可以附加到各种资源对象上，例如Node、Pod、Service、RS等，一个资源对象可以定义任意数量的Label，同一label也可以被添加到任意数量的资源对象上，label可以在定义资源对象是创建，也可以创建后动态添加或删除</li>
<li>通过LabelSelector(标签选择器)查询和筛选，K8S通过这种方式实现类似SQL的简单又通用的对象查询机制</li>
</ul>
<h2 id="Horizontal-Pod-Autoscaler（HPA）"><a href="#Horizontal-Pod-Autoscaler（HPA）" class="headerlink" title="Horizontal Pod Autoscaler（HPA）"></a>Horizontal Pod Autoscaler（HPA）</h2><ul>
<li>Pod横向自动扩容，通过追踪分析RS控制的所有目标Pod的负载变化情况，确定是否需要针对性调整目标Pod的副本数</li>
<li>度量指标<ul>
<li>CPUUtilizationPercentage （需要部署安装Heapster）</li>
<li>应用程序自定义的度量指标，比如服务在每秒内的相应的请求数（TPS或QPS）</li>
</ul>
</li>
</ul>
<h2 id="RBAC访问授权"><a href="#RBAC访问授权" class="headerlink" title="RBAC访问授权"></a>RBAC访问授权</h2><ul>
<li>基于角色的访问控制（Role-based Access Control，RBAC）的授权模式</li>
</ul>
<h1 id="核心组件-1"><a href="#核心组件-1" class="headerlink" title="核心组件"></a>核心组件</h1><p> ##组件通信<br>   K8S多组件之间通信原理</p>
<p><img src="https://i.loli.net/2019/08/12/GzcCtOFyV7pnHBX.png" alt="assets_-LDAOok5ngY4pc1lEDes_-LM_rqip-tinVoiFZE0I_-LM_sEq_NuMALezRGMtG_workflow.png"></p>
<ul>
<li>apiserver 负责etcd存储的所有操作，且只有apiserver才直接操作etcd集群</li>
<li>apiserver 对内（集群中的其他组件）和对外（用户）提供统一的REST API，其他组件均通过apiserver进行通信<ul>
<li>controller manager、scheduler、kube-proxy和kubelet等均通过apiserver watch API检测资源变化情况，并对资源作相应的操作</li>
<li>所有需要更新资源状态的操作均通过apiserver的REST API进行</li>
</ul>
</li>
<li>apiserver也会直接调用kubelet API（如logs,exec,attach等），默认不校验kubelet证书，看可以通过–kubelet-certificate-autprity开启开启（GKE通过SSH隧道保护他们之间通信）<br>比如典型的创建Podcast的流程为</li>
</ul>
<p><img src="https://i.loli.net/2019/08/12/eg53NY8LvBa91q7.png" alt="assets_-LDAOok5ngY4pc1lEDes_-LM_rqip-tinVoiFZE0I_-LM_sEqUTx_-gUuaPyw1_components.png"></p>
<ol>
<li><p>用户通过REST API创建一个Pod </p>
</li>
<li><p>apiserver 将其写入etcd</p>
</li>
<li><p>scheduler检测到未绑定Node的Pod，开始调度并更新Pod的Node绑定</p>
</li>
<li><p>kubelet检测到有新的Podcast调度过来，通过container runtime运行该Pod</p>
</li>
<li><p>kubelet通过container runtime取到Pod状态，并更新到apiserver中</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2></li>
</ol>
<h3 id="Master-1"><a href="#Master-1" class="headerlink" title="Master"></a>Master</h3><table>
<thead>
<tr>
<th align="center"><strong>Protocol</strong></th>
<th align="center"><strong>Direction</strong></th>
<th align="center"><strong>PortRange</strong></th>
<th align="center"><strong>Purpose</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">6443*</td>
<td align="center">Kubernetes API server</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">8080</td>
<td align="center">Kubernetes API insecure server</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">2379-2380</td>
<td align="center">etcd server client API</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10250</td>
<td align="center">Kubelet API</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10251</td>
<td align="center">kube-scheduler healthz</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10252</td>
<td align="center">kube-controller-manager healthz</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10253</td>
<td align="center">cloud-controller-manager healthz</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10255</td>
<td align="center">Read-only Kubelet API</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10256</td>
<td align="center">kube-proxy healthz</td>
</tr>
</tbody></table>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><table>
<thead>
<tr>
<th align="center"><strong>Protocol</strong></th>
<th align="center"><strong>Direction</strong></th>
<th align="center"><strong>PortRange</strong></th>
<th align="center"><strong>Purpose</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">4194</td>
<td align="center">Kubelet cAdvisor</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10248</td>
<td align="center">Kubelethealthz</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10249</td>
<td align="center">kube-proxy metrics</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10250</td>
<td align="center">Kubelet API</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10255</td>
<td align="center">Read-only Kubelet API</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">10256</td>
<td align="center">kube-proxy healthz</td>
</tr>
<tr>
<td align="center">TCP</td>
<td align="center">Inbound</td>
<td align="center">30000-32767</td>
<td align="center">NodePort Services**</td>
</tr>
</tbody></table>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>Etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。</p>
<h2 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h2><p><img src="https://i.loli.net/2019/08/12/RyPTzkrf1qw5VKg.png" alt="assets_-LDAOok5ngY4pc1lEDes_-L_kZB_hPn0h_fskH43w_-L_kZGkSetdfkFl6OL6N_post-ccm-arch.png"></p>
<p>Controller Manager 由 kube-controller-manager 和 cloud-controller-manager 组成，是 Kubernetes 的大脑，它通过 apiserver 监控整个集群的状态，并确保集群处于预期的工作状态。<br>Kube-controller-manager 由一系列的控制器组成<br><img src="https://i.loli.net/2019/08/13/5GwXKSWfODuFaVt.png" alt="20170721232653797.png"></p>
<ul>
<li>Replication Controller</li>
<li>Node Controller</li>
<li>CronJob Controller</li>
<li>Daemon Controller</li>
<li>Deployment Controller</li>
<li>Endpoint Controller</li>
<li>Garbage Collector</li>
<li>Namespace Controller</li>
<li>Job Controller</li>
<li>Pod AutoScaler</li>
<li>RelicaSet</li>
<li>Service Controller</li>
<li>ServiceAccount Controller</li>
<li>StatefulSet Controller</li>
<li>Volume Controller</li>
<li>Resource quota Controller<br>cloud-controller-manager 在 Kubernetes 启用 Cloud Provider 的时候才需要，用来配合云服务提供商的控制，也包括一系列的控制器，如</li>
<li>Node Controller</li>
<li>Route Controller</li>
<li>Service Controller<h2 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h2>kube-scheduler 负责分配调度 Pod 到集群内的节点上，它监听 kube-apiserver，查询还未分配 Node 的 Pod，然后根据调度策略为这些 Pod 分配节点（更新 Pod 的 NodeName 字段）<br>调度器需要充分考虑诸多的因素：</li>
<li>公平调度</li>
<li>资源高效利用</li>
<li>QoS</li>
<li>affinity 和 anti-affinity</li>
<li>数据本地化（data locality）</li>
<li>内部负载干扰（inter-workload interference）</li>
<li>deadlines<br>有三种方式指定 Pod 只运行在指定的 Node 节点上</li>
<li>nodeSelector：只调度到匹配指定 label 的 Node 上</li>
<li>nodeAffinity：功能更丰富的 Node 选择器，比如支持集合操作</li>
<li>podAffinity：调度到满足条件的 Pod 所在的 Node 上<h2 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h2></li>
<li>提供集群管理的 REST API 接口，包括认证授权、数据校验以及集群状态变更等</li>
<li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）<h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2>每个节点上都运行一个 kubelet 服务进程，默认监听 10250 端口，接收并执行 master 发来的指令，管理 Pod 及 Pod 中的容器。每个 kubelet 进程会在 API Server 上注册节点自身信息，定期向 master 节点汇报节点的资源使用情况，并通过 cAdvisor 监控节点和容器的资源。<h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h3>节点管理主要是节点自注册和节点装填更新：<ul>
<li>Kubelet可以通过设置启动参数–register-node来确定是否向API Server注册</li>
<li>如果Kubelet没有选择自注册模式，则需要用户自己配置Node资源信息，同时需要告知Kubelet集群上的API Server的位置</li>
<li>Kubelet在启动时通过API Server注册节点信息，并定时向API Server发送节点新消息，API Server在接受到新消息后，将信息写入etcd<h3 id="Pod管理"><a href="#Pod管理" class="headerlink" title="Pod管理"></a>Pod管理</h3></li>
<li>Kubelet 以 PodSpec 的方式工作。PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。 kubelet 采用一组通过各种机制提供的 PodSpecs（主要通过 apiserver），并确保这些 PodSpecs 中描述的 Pod 正常健康运行<h3 id="Static-Pod"><a href="#Static-Pod" class="headerlink" title="Static Pod"></a>Static Pod</h3></li>
<li>静态Pod是由kubelet进行管理的仅存在于特定Node上的Pod。不能通过API Server进行管理，无法与RC、Deployment或者DaemonSet进行管理，并且kubelet无法对其进行健康检查。</li>
<li>静态Pod总是由kubelet进行创建，并且总是在kuelet所在的Node上运行</li>
<li>所有以非 API Server 方式创建的 Pod 都叫 Static Pod。Kubelet 将 Static Pod 的状态汇报给 API Server，API Server 为该 Static Pod 创建一个 Mirror Pod 和其相匹配。Mirror Pod 的状态将真实反映 Static Pod 的状态。当 Static Pod 被删除时，与之相对应的 Mirror Pod 也会被删除。</li>
<li><h3 id="容器健康检查"><a href="#容器健康检查" class="headerlink" title="容器健康检查"></a>容器健康检查</h3></li>
</ul>
</li>
</ul>
<ol>
<li>LivenessProbe 探针：用于判断容器是否健康，告诉 Kubelet 一个容器什么时候处于不健康的状态。如果 LivenessProbe 探针探测到容器不健康，则 Kubelet 将删除该容器，并根据容器的重启策略做相应的处理。如果一个容器不包含 LivenessProbe 探针，那么 Kubelet 认为该容器的 LivenessProbe 探针返回的值永远是 “Success”</li>
<li>ReadinessProbe：用于判断容器是否启动完成且准备接收请求。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 IP 地址的 Endpoint 条目。<br>livenessProbe 包含如下三种实现方式：</li>
</ol>
<ul>
<li><p>ExecAction：在容器内部执行一个命令，如果该命令的退出状态码为 0，则表明容器健康；</p>
</li>
<li><p>TCPSocketAction：通过容器的 IP 地址和端口号执行 TCP 检查，如果端口能被访问，则表明容器健康；</p>
</li>
<li><p>HTTPGetAction：通过容器的 IP 地址和端口号及路径调用 HTTP GET 方法，如果响应的状态码大于等于 200 且小于 400，则认为容器状态健康。</p>
<h3 id="cAdvisor-资源监控"><a href="#cAdvisor-资源监控" class="headerlink" title="cAdvisor 资源监控"></a>cAdvisor 资源监控</h3><p>Kubernetes集群中，应用程序的执行情况可以在不同的级别上检测到，包括：容器、Pod、Servvice和整个集群。Heapster项目为K8S提供了一个基本监控平台，它是集群级别的监控事件数据集成器（Aggregator）.Heapster以Pod的方式运行在集群中，Heapster通过Kubelet发现所有运行在集群中的节点，并查看这些节点的资源使用情况。Kubelet通过cAdvisor获取其所在节点及容器的数据。</p>
<ul>
<li>cAdvisor 是一个开源的分析容器资源使用率和性能特性的代理工具，已集成到 Kubernetes 代码中。</li>
<li>cAdvisor 自动查找所有在其所在节点上的容器，自动采集 CPU、内存、文件系统和网络使用的统计信息。</li>
<li>cAdvisor 通过它所在节点机的 Root 容器，采集并分析该节点机的全面使用情况。</li>
<li>cAdvisor 通过其所在节点机的 4194 端口暴露一个简单的 UI<h3 id="Container-Runtime"><a href="#Container-Runtime" class="headerlink" title="Container Runtime"></a>Container Runtime</h3>负责真正管理镜像和容器的生命周期。Kubelet通过Container Runtime Interface（CRI）与容器云形式交互，以管理镜像和容器。</li>
<li>拆分成Sandbox和Container的gPRC接口，并将镜像管理和容器管理分离到不同的服务</li>
</ul>
<p><img src="https://i.loli.net/2019/08/13/FDv8ZWuRi3X5SCg.png" alt="assets_-LDAOok5ngY4pc1lEDes_-LOmrfw3UHfIY1g0xnLo_-LOmroTRjl0FBixIYL5x_cri.png"></p>
<h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2></li>
</ul>
<ul>
<li>每台node上都运行一个kube-proxy服务，监听API server和endpoint的变化情况，并通过iptables等来为服务配置负载均衡（仅支持TCP和UDP）</li>
<li>kube-proxy可以直接运行在物理机上，也可以在static pod或者daemonset的方式运行</li>
<li>实现方式<ul>
<li>userspace:用户控件监听端口，所有服务通过iptables转发到这个端口，然后在其内部负载均衡到实际pod</li>
<li>iptables:完全以iptables规则的方式实现service负载均衡（服务多的时候，产生太多iptables规则）</li>
<li>ipvs：解决iptables模式性能问题，增量式更新，保证service更新期间连接不断开</li>
<li>应用层的转发机制通过services是无法实现的，需要借助Ingress将不同URL的访问请求转发到后端不同的service<h2 id="kube-dns"><a href="#kube-dns" class="headerlink" title="kube-dns"></a>kube-dns</h2></li>
</ul>
</li>
<li>目前推荐CoreDNS替代kube-dns(skydns)</li>
<li>DNS 格式<ul>
<li>Service <ul>
<li>A record (cluster IP 或Pod IP列表)</li>
<li>SRV record</li>
</ul>
</li>
<li>Pod<ul>
<li>A record:</li>
<li>指定hostname和subdomain</li>
</ul>
</li>
</ul>
</li>
<li>工作原理<ul>
<li>kube-dns：DNS 服务的核心组件，主要由 KubeDNS 和 SkyDNS 组成<ul>
<li>KubeDNS 负责监听 Service 和 Endpoint 的变化情况，并将相关的信息更新到 SkyDNS 中</li>
<li>SkyDNS 负责 DNS 解析，监听在 10053 端口 (tcp/udp)，同时也监听在 10055 端口提供 metrics</li>
<li>kube-dns 还监听了 8081 端口，以供健康检查使用</li>
</ul>
</li>
<li>dnsmasq-nanny：负责启动 dnsmasq，并在配置发生变化时重启 dnsmasq<ul>
<li>dnsmasq 的 upstream 为 SkyDNS，即集群内部的 DNS 解析由 SkyDNS 负责</li>
</ul>
</li>
<li>sidecar：负责健康检查和提供 DNS metrics（监听在 10054 端口）</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/08/13/kV82oOjNUX6dQzC.png" alt="assets_-LDAOok5ngY4pc1lEDes_-LM_tX5rWaCuzsx7xEcz_-LM_t_Oxw2Twn_BSf7GQ_kube-dns.png"></p>
<h1 id="资源管理对象"><a href="#资源管理对象" class="headerlink" title="资源管理对象"></a>资源管理对象</h1><h2 id="Node-1"><a href="#Node-1" class="headerlink" title="Node"></a>Node</h2><p>Node 是 Pod 真正运行的主机，可以是物理机，也可以是虚拟机。为了管理 Pod，每个 Node 节点上至少要运行 container runtime（比如 docker 或者 rkt）、kubelet 和 kube-proxy 服务。</p>
<h3 id="Node管理"><a href="#Node管理" class="headerlink" title="Node管理"></a>Node管理</h3><ul>
<li>不像其他的资源（如 Pod 和 Namespace），Node 本质上不是 Kubernetes 来创建的，Kubernetes 只是管理 Node 上的资源。虽然可以通过 Manifest 创建一个 Node 对象（如下 yaml 所示），但 Kubernetes 也只是去检查是否真的是有这么一个 Node，如果检查失败，也不会往上调度 Pod。</li>
<li>这个检查是由 Node Controller 来完成的。Node Controller 负责<ul>
<li>维护 Node 状态 </li>
<li>与 Cloud Provider 同步 Node</li>
<li>给 Node 分配容器 CIDR</li>
<li>删除带有 NoExecute taint 的 Node 上的 Pods<h3 id="Node状态"><a href="#Node状态" class="headerlink" title="Node状态"></a>Node状态</h3></li>
</ul>
</li>
<li>地址：包括 hostname、外网 IP 和内网 IP</li>
<li>条件（Condition）：包括 OutOfDisk、Ready、MemoryPressure 和 DiskPressure</li>
<li>容量（Capacity）：Node 上的可用资源，包括 CPU、内存和 Pod 总数</li>
<li>基本信息（Info）：包括内核版本、容器引擎版本、OS 类型等</li>
</ul>
<h2 id="PersistentVolume"><a href="#PersistentVolume" class="headerlink" title="PersistentVolume"></a>PersistentVolume</h2><p>PersistentVolume (PV) 和 PersistentVolumeClaim (PVC) 提供了方便的持久化卷：<strong>PV 提供网络存储资源，而 PVC 请求存储资源</strong>。这样，设置持久化的工作流包括配置底层文件系统或者云数据卷、创建持久性数据卷、最后创建 PVC 来将 Pod 跟数据卷关联起来。PV 和 PVC 可以将 pod 和数据卷解耦，pod 不需要知道确切的文件系统或者支持它的持久化引擎。</p>
<h3 id="Volume-生命周期"><a href="#Volume-生命周期" class="headerlink" title="Volume 生命周期"></a>Volume 生命周期</h3><p>Volume 的生命周期包括 5 个阶段</p>
<ol>
<li>Provisioning，即 PV 的创建，可以直接创建 PV（静态方式），也可以使用 StorageClass 动态创建</li>
<li>Binding，将 PV 分配给 PVC</li>
<li>Using，Pod 通过 PVC 使用该 Volume，并可以通过准入控制 StorageObjectInUseProtection（1.9 及以前版本为 PVCProtection）阻止删除正在使用的 PVC</li>
<li>Releasing，Pod 释放 Volume 并删除 PVC</li>
<li>Reclaiming，回收 PV，可以保留 PV 以便下次使用，也可以直接从云存储中删除</li>
<li>Deleting，删除 PV 并从云存储中删除后段存储<br>根据这 5 个阶段，Volume 的状态有以下 4 种</li>
</ol>
<ul>
<li>Available：可用</li>
<li>Bound：已经分配给 PVC</li>
<li>Released：PVC 解绑但还未执行回收策略</li>
<li>Failed：发生错误<h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3>PersistentVolume（PV）是集群之中的一块网络存储。跟 Node 一样，也是集群的资源。PV 跟 Volume (卷) 类似，不过会有独立于 Pod 的生命周期。比如一个 NFS 的 PV 可以定义为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv0003</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 5Gi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  persistentVolumeReclaimPolicy: Recycle</span><br><span class="line">  nfs:</span><br><span class="line">    path: /tmp</span><br><span class="line">    server: 172.17.0.2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>PV 的访问模式（accessModes）有三种：</p>
<ul>
<li>ReadWriteOnce（RWO）：是最基本的方式，可读可写，但只支持被单个节点挂载。</li>
<li>ReadOnlyMany（ROX）：可以以只读的方式被多个节点挂载。</li>
<li>ReadWriteMany（RWX）：这种存储可以以读写的方式被多个节点共享。不是每一种存储都支持这三种方式，像共享方式，目前支持的还比较少，比较常用的是 NFS。在 PVC 绑定 PV 时通常根据两个条件来绑定，一个是存储的大小，另一个就是访问模式。<br>PV 的回收策略（persistentVolumeReclaimPolicy，即 PVC 释放卷的时候 PV 该如何操作）也有三种</li>
<li>Retain，不清理, 保留 Volume（需要手动清理）</li>
<li>Recycle，删除数据，即 rm -rf /thevolume/*（只有 NFS 和 HostPath 支持）</li>
<li>Delete，删除存储资源，比如删除 AWS EBS 卷（只有 AWS EBS, GCE PD, Azure Disk 和 Cinder 支持）<h3 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h3>StorageClass 包括四个部分</li>
<li>provisioner：指定 Volume 插件的类型，包括内置插件（如 kubernetes.io/glusterfs）和外部插件（如 external-storage 提供的 ceph.com/cephfs）。</li>
<li>mountOptions：指定挂载选项，当 PV 不支持指定的选项时会直接失败。比如 NFS 支持 hard 和 nfsvers=4.1 等选项。</li>
<li>parameters：指定 provisioner 的选项，比如 kubernetes.io/aws-ebs 支持 type、zone、iopsPerGB 等参数。</li>
<li>reclaimPolicy：指定回收策略，同 PV 的回收策略。</li>
</ul>
<h3 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h3><p>PV 是存储资源，而 PersistentVolumeClaim (PVC) 是对 PV 的请求。PVC 跟 Pod 类似：Pod 消费 Node 资源，而 PVC 消费 PV 资源；Pod 能够请求 CPU 和内存资源，而 PVC 请求特定大小和访问模式的数据卷。</p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod 是一组紧密关联的容器集合，它们共享 IPC、Network 和 UTS namespace，是 Kubernetes 调度的基本单位。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p>
<p>Pod 的特征</p>
<ul>
<li>包含多个共享 IPC、Network 和 UTC namespace 的容器，可直接通过 localhost 通信</li>
<li>所有 Pod 内容器都可以访问共享的 Volume，可以访问共享数据</li>
<li>无容错性：直接创建的 Pod 一旦被调度后就跟 Node 绑定，即使 Node 挂掉也不会被重新调度（而是被自动删除），因此推荐使用 Deployment、Daemonset 等控制器来容错</li>
<li>优雅终止：Pod 删除的时候先给其内的进程发送 SIGTERM，等待一段时间（grace period）后才强制停止依然还在运行的进程</li>
<li>特权容器（通过 SecurityContext 配置）具有改变系统配置的权限（在网络插件中大量应用）<h3 id="Pod-定义"><a href="#Pod-定义" class="headerlink" title="Pod 定义"></a>Pod 定义</h3>Pod 生命周期<br>Kubernetes 以 PodStatus.Phase 抽象 Pod 的状态（但并不直接反映所有容器的状态）。可能的 Phase 包括</li>
<li>Pending: Pod 已经在 apiserver 中创建，但还没有调度到 Node 上面</li>
<li>Running: Pod 已经调度到 Node 上面，所有容器都已经创建，并且至少有一个容器还在运行或者正在启动</li>
<li>Succeeded: Pod 调度到 Node 上面后成功运行结束，并且不会重启</li>
<li>Failed: Pod 调度到 Node 上面后至少有一个容器运行失败（即退出码不为 0 或者被系统终止）</li>
<li>Unknonwn: 状态未知，通常是由于 apiserver 无法与 kubelet 通信导致</li>
</ul>
<p>PodSpec 中的 restartPolicy 可以用来设置是否对退出的 Pod 重启，可选项包括 Always、OnFailure、以及 Never。</p>
<ul>
<li>Always：只要退出就重启</li>
<li>OnFailure：失败退出（exit code 不等于 0）时重启</li>
<li>Never：只要退出就不再重启</li>
</ul>
<h3 id="容器生命周期钩子"><a href="#容器生命周期钩子" class="headerlink" title="容器生命周期钩子"></a>容器生命周期钩子</h3><p>容器生命周期钩子（Container Lifecycle Hooks）监听容器生命周期的特定事件，并在事件发生时执行已注册的回调函数。支持两种钩子：</p>
<ul>
<li>postStart： 容器创建后立即执行，注意由于是异步执行，它无法保证一定在 ENTRYPOINT 之前运行。如果失败，容器会被杀死，并根据 RestartPolicy 决定是否重启</li>
<li>preStop：容器终止前执行，常用于资源清理。如果失败，容器同样也会被杀死<br>而钩子的回调函数支持两种方式：</li>
<li>exec：在容器内执行命令，如果命令的退出状态码是 0 表示执行成功，否则表示失败</li>
<li>httpGet：向指定 URL 发起 GET 请求，如果返回的 HTTP 状态码在 [200, 400) 之间表示请求成功，否则表示失败</li>
</ul>
<h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><ul>
<li>ReplicationController（也简称为 rc）用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而异常多出来的容器也会自动回收。ReplicationController 的典型应用场景包括确保健康 Pod 的数量、弹性伸缩、滚动升级以及应用多版本发布跟踪等。</li>
<li><ul>
<li>在新版本的 Kubernetes 中建议使用 ReplicaSet（也简称为 rs）来取代 ReplicationController。ReplicaSet 跟 ReplicationController 没有本质的不同，只是名字不一样，并且 ReplicaSet 支持集合式的 selector（ReplicationController 仅支持等式）。</li>
</ul>
</li>
<li><ul>
<li>虽然也 ReplicaSet 可以独立使用，但建议使用 Deployment 来自动管理 ReplicaSet，这样就无需担心跟其他机制的不兼容问题（比如 ReplicaSet 不支持 rolling-update 但 Deployment 支持），并且还支持版本记录、回滚、暂停升级等高级特</li>
</ul>
</li>
</ul>
<h2 id="Resource-Quota"><a href="#Resource-Quota" class="headerlink" title="Resource Quota"></a>Resource Quota</h2><p>资源配额（Resource Quotas）是用来限制用户资源用量的一种机制。<br>它的工作原理为</p>
<ul>
<li><strong>资源配额应用在 Namespace 上，并且每个 Namespace 最多只能有一个 ResourceQuota 对象</strong></li>
<li>开启计算资源配额后，创建容器时必须配置计算资源请求或限制（也可以用 LimitRange 设置默认值）</li>
<li>用户超额后禁止创建新的资源<h3 id="资源配额的类型"><a href="#资源配额的类型" class="headerlink" title="资源配额的类型"></a>资源配额的类型</h3></li>
<li>计算资源，包括 cpu 和 memory<ul>
<li>cpu, limits.cpu, requests.cpu</li>
<li>memory, limits.memory, requests.memory</li>
</ul>
</li>
<li>存储资源，包括存储资源的总量以及指定 storage class 的总量<ul>
<li>requests.storage：存储资源总量，如 500Gi</li>
<li>persistentvolumeclaims：pvc 的个数</li>
<li>.storageclass.storage.k8s.io/requests.storage</li>
<li>.storageclass.storage.k8s.io/persistentvolumeclaims</li>
<li>requests.ephemeral-storage 和 limits.ephemeral-storage （需要 v1.8+）</li>
</ul>
</li>
<li>对象数，即可创建的对象的个数<ul>
<li>pods, replicationcontrollers, configmaps, secrets</li>
<li>resourcequotas, persistentvolumeclaims</li>
<li>services, services.loadbalancers, services.nodeports<h3 id="LimitRange"><a href="#LimitRange" class="headerlink" title="LimitRange"></a>LimitRange</h3>默认情况下，Kubernetes 中所有容器都没有任何 CPU 和内存限制。LimitRange 用来给 Namespace 增加一个资源限制，包括最小、最大和默认资源。</li>
</ul>
</li>
</ul>
<h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet是为了解决有状态服务的问题（对应Deployments和ReplicaSets是为了无状态服务设计），其应用场景包括</p>
<ul>
<li>稳定的持久化存储，即Pod重新调度后还是能访问到相同的持久化数据，基于PVC实现</li>
<li>稳定的网络标识，即Pod重新调度后期PodName和HostName不变，基于Headless Service（即没有Cluster IP的service）来实现</li>
<li>有序部署，有序扩展，即Pod是由顺序的，在部署或者扩展的时候要依据定义的顺序依次次序进行（即从 0 到 N-1，在下一个 Pod 运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于init containers来实现</li>
<li>有序收缩，有序删除（即从 N-1 到 0）</li>
</ul>
<p>从上面的应用场景可以发现，StatefulSet 由以下几个部分组成：</p>
<ul>
<li>用于定义网络标志（DNS domain）的 Headless Service</li>
<li>用于创建 PersistentVolumes 的 volumeClaimTemplates</li>
<li>定义具体应用的 StatefulSet</li>
</ul>
<h2 id="Volume-1"><a href="#Volume-1" class="headerlink" title="Volume"></a>Volume</h2><blockquote>
<ul>
<li>默认情况下容器的数据都是非持久化的，在容器消亡以后数据也跟着丢失，所以 Docker 提供了 Volume 机制以便将数据持久化存储。类似的，Kubernetes 提供了更强大的 Volume 机制和丰富的插件，解决了容器数据持久化和容器间共享数据的问题。</li>
</ul>
</blockquote>
<p>与 Docker 不同，<strong>Kubernetes Volume 的生命周期与 Pod 绑定</strong></p>
<ul>
<li>容器挂掉后 Kubelet 再次重启容器时，Volume 的数据依然还在</li>
<li>而 Pod 删除时，Volume 才会清理。数据是否丢失取决于具体的 Volume 类型，比如 emptyDir 的数据会丢失，而 PV 的数据则不会丢<h3 id="Volume-类型"><a href="#Volume-类型" class="headerlink" title="Volume 类型"></a>Volume 类型</h3></li>
</ul>
<h4 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h4><p>如果 Pod 设置了 emptyDir 类型 Volume， Pod 被分配到 Node 上时候，会创建 emptyDir，只要 Pod 运行在 Node 上，emptyDir 都会存在（容器挂掉不会导致 emptyDir 丢失数据），但是如果 Pod 从 Node 上被删除（Pod 被删除，或者 Pod 发生迁移），emptyDir 也会被删除，并且永久丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: gcr.io/google_containers/test-webserver</span><br><span class="line">    name: test-container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /cache</span><br><span class="line">      name: cache-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: cache-volume</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h4><p>hostPath 允许挂载 Node 上的文件系统到 Pod 里面去。如果 Pod 需要使用 Node 上的文件，可以使用 hostPath</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: gcr.io/google_containers/test-webserver</span><br><span class="line">    name: test-container</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /test-pd</span><br><span class="line">      name: test-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - name: test-volume</span><br><span class="line">    hostPath:</span><br><span class="line">      path: /data</span><br></pre></td></tr></table></figure>

<h4 id="gcePersistentDisk"><a href="#gcePersistentDisk" class="headerlink" title="gcePersistentDisk"></a>gcePersistentDisk</h4><p>gcePersistentDisk 可以挂载 GCE 上的永久磁盘到容器，需要 Kubernetes 运行在 GCE 的 VM 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - name: test-volume</span><br><span class="line">    # This GCE PD must already exist.</span><br><span class="line">    gcePersistentDisk:</span><br><span class="line">      pdName: my-data-disk</span><br><span class="line">      fsType: ext4</span><br></pre></td></tr></table></figure>

<h4 id="awsElasticBlockStore"><a href="#awsElasticBlockStore" class="headerlink" title="awsElasticBlockStore"></a>awsElasticBlockStore</h4><p>同gcePersistentDisk，环境为AWS</p>
<h4 id="nfs"><a href="#nfs" class="headerlink" title="nfs"></a>nfs</h4><p>NFS 是 Network File System 的缩写，即网络文件系统。Kubernetes 中通过简单地配置就可以挂载 NFS 到 Pod 中，而 NFS 中的数据是可以永久保存的，同时 NFS 支持同时写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">- name: nfs</span><br><span class="line">  nfs:</span><br><span class="line">    # FIXME: use the right hostname</span><br><span class="line">    server: 10.254.234.223</span><br><span class="line">    path: &quot;/&quot;</span><br></pre></td></tr></table></figure>

<h4 id="gitRepo"><a href="#gitRepo" class="headerlink" title="gitRepo"></a>gitRepo</h4><p>gitRepo volume 将 git 代码下拉到指定的容器路径中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">- name: git-volume</span><br><span class="line">  gitRepo:</span><br><span class="line">    repository: &quot;git@somewhere:me/my-git-repository.git&quot;</span><br><span class="line">    revision: &quot;22f1d8406d464b0c0874075539c1f2e96c253775&quot;</span><br></pre></td></tr></table></figure>

<h4 id="使用subPath"><a href="#使用subPath" class="headerlink" title="使用subPath"></a>使用subPath</h4><p>Pod 的多个容器使用同一个 Volume 时，subPath 非常有用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: my-lamp-site</span><br><span class="line">spec:</span><br><span class="line">    containers:</span><br><span class="line">    - name: mysql</span><br><span class="line">      image: mysql</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - mountPath: /var/lib/mysql</span><br><span class="line">        name: site-data</span><br><span class="line">        subPath: mysql</span><br><span class="line">    - name: php</span><br><span class="line">      image: php</span><br><span class="line">      volumeMounts:</span><br><span class="line">      - mountPath: /var/www/html</span><br><span class="line">        name: site-data</span><br><span class="line">        subPath: html</span><br><span class="line">    volumes:</span><br><span class="line">    - name: site-data</span><br><span class="line">      persistentVolumeClaim:</span><br><span class="line">        claimName: my-lamp-site-data</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/11/AWS-Direct-Connect-Overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/11/AWS-Direct-Connect-Overview/" itemprop="url">AWS Direct Connect Overview</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-11T13:45:05+08:00">
                2019-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Direct-Connect-Overview"><a href="#Direct-Connect-Overview" class="headerlink" title="Direct Connect Overview"></a>Direct Connect Overview</h2><ul>
<li>AWS Direct Connect是一种网络服务，它是一种替代Internet来利用AWS云服务的一种方案</li>
<li>通过标准的以太网光纤电缆将内部网络链接到 AWS Direct Connect 位置。电缆的一端接到用户侧路由器，另一端接到 AWS Direct Connect 路由器</li>
<li>可以使用1Gbps和10Gbps端口建立直接连接。可以从任何支持AWS Direct Connect的APN合作伙伴订购50Mbps，100Mbps，200Mbps，300Mbps，400Mbps和500Mbps的速度</li>
<li>有了此连接以后，可以创建直接连接到公共 AWS 服务（如 Amazon S3）或 Amazon VPC 的虚拟接口，从而绕过网络路径中的 Internet 服务提供商</li>
<li>AWS Direct Connect位置提供对与其关联的区域中的Amazon Web Services的访问，以及对其他美国区域的访问（如果是美国地区的Direct Connect）。例如，可以为美国的任何AWS Direct Connect位置配置单个连接，并使用它来访问所有美国区域和AWS GovCloud（美国）中的公共AWS服务。</li>
<li>每个AWS Direct Connect位置都可以连接到地理位置最近的AWS区域内的所有可用区</li>
<li>公有区域或AWS GovCloud (US)中的 AWS Direct Connect 位置可以访问任何其他公有区域（不包括中国(北京和宁夏)）中的公有服务<br><img src="https://i.loli.net/2019/08/11/ab2uJTrhVCylmHW.png" alt="direct_connect_overview.png"></li>
</ul>
<h2 id="Direct-Connect-Advantages"><a href="#Direct-Connect-Advantages" class="headerlink" title="Direct Connect Advantages"></a>Direct Connect Advantages</h2><ul>
<li>降低带宽成本<ul>
<li>所有通过专用连接传输的数据均按AWS直接连接数据传输速率(而不是Internet数据传输速率)的，从而节省成本</li>
<li>在AWS之间传输数据直接减少了Internet服务提供商的带宽承诺</li>
</ul>
</li>
<li>一致的网络性能<ul>
<li>与互联网的网络变化（抖动、延迟）相比，Direct Connect提供专用连接和更一致的网络性能体验</li>
</ul>
</li>
<li>AWS 服务兼容性<ul>
<li>Direct Connect是一种网络服务，可与S3，EC2和VPC等所有AWS服务配合使用</li>
</ul>
</li>
<li>VPC的专用连接<ul>
<li>使用直接连接专用虚拟接口（Private virtual interface）可以在网络和VPC之间建立专用的专用高带宽网络连接</li>
</ul>
</li>
<li>弹性<ul>
<li>使用更高带宽的连接或建立多个连接，可以轻松扩展直接连接以满足需求</li>
</ul>
</li>
</ul>
<h1 id="Direct-Connect-vs-IPSec-VPN-Connections"><a href="#Direct-Connect-vs-IPSec-VPN-Connections" class="headerlink" title="Direct Connect vs IPSec VPN Connections"></a>Direct Connect vs IPSec VPN Connections</h1><ul>
<li>VPC VPN连接通过IPSec在Internet上建立内部网和Amazon VPC之间的加密网络连接</li>
<li>VPN连接可以在几分钟内进行配置，而对于需要一个具有低到适度的带宽需求，并能容忍在基于互联网连接的内在变化</li>
<li>AWS Direct Connect不涉及Internet; 相反，它使用Intranet和Amazon VPC之间的专用专用网络连接</li>
<li>与Direct Connect连接相比，VPN连接非常便宜，因为它需要实际的硬件和基础设施，可能需要数千个</li>
</ul>
<h1 id="Direct-Connect-Anatomy"><a href="#Direct-Connect-Anatomy" class="headerlink" title="Direct Connect Anatomy"></a>Direct Connect Anatomy</h1><p><img src="https://i.loli.net/2019/08/11/GumT4j7R1sLoiHE.png" alt="screen-shot-2016-05-17-at-1-56-15-pm.png"></p>
<ul>
<li>亚马逊在不同地点维护AWS Direct Connect PoP（称为主机托管设施），这与AWS区域不同</li>
<li>AWS本身维护从AWS Direct Connect PoP到AWS区域的连接</li>
<li>消费者，既可以购买机架空间，也可以使用任何已在主机托管设施中拥有基础架构的AWS APN合作伙伴并配置客户网关</li>
<li>Direct Connect PoP与Colocation Facility内的Customer网关之间的连接称为Cross Connect</li>
<li>可以使用任何服务提供商网络建立从客户网关到客户数据中心的连接</li>
<li>使用AWS创建直接连接连接后，将收到LOA-CFA（授权书 - 连接设施分配）。</li>
<li>LOA-CFA可以切换到主机托管设施或APN合作伙伴以建立交叉连接</li>
<li>一旦建立了Cross Connect以及CGW和Customer DataCenter之间的连接，就可以创建虚拟接口</li>
<li>AWS Direct Connect需要VGW才能访问AWS VPC</li>
<li>虚拟接口<ul>
<li>每个AWS Direct Connect连接都需要一个虚拟接口</li>
<li>每个AWS Direct Connect连接都可以配置一个或多个虚拟接口。</li>
<li>可以创建公共虚拟接口（public virtual interface）以连接到例如公共资源。 SQS，S3，EC2，Glacier等只能公开到达</li>
<li>可以创建专用虚拟接口以连接到例如VPC私有IP地址的实例</li>
<li>每个虚拟接口都需要VLAN ID，接口IP地址，ASN和BGP密钥</li>
</ul>
</li>
<li>要将AWS Direct Connect连接与其他AWS账户一起使用，可以为该账户创建托管虚拟接口。 这些托管虚拟接口与标准虚拟接口的工作方式相同，可以连接到公共资源或VPC。</li>
</ul>
<h1 id="Direct-Connect-Redundancy"><a href="#Direct-Connect-Redundancy" class="headerlink" title="Direct Connect Redundancy"></a>Direct Connect Redundancy</h1><p><img src="https://i.loli.net/2019/08/11/WU7kjK2xcd3uslJ.png" alt="screen-shot-2016-05-17-at-1-57-22-pm.png"></p>
<ul>
<li>直接连接不提供冗余，并且有多个单点故障，因为每个连接都包含路由器端口和Amazon路由器之间的单个专用连接</li>
<li>冗余连接<ul>
<li>建立第二个DX，最好使用不同的路由器和AWS Direct Connect PoP在不同的主机托管设施中建立连接</li>
<li>客户DC与VGW之间的IPsec VPN连接</li>
</ul>
</li>
<li>对于在同一AWS Direct Connect位置中请求的多个端口，Amazon本身确保在冗余Amazon路由器上配置它们以防止硬件故障的影响</li>
</ul>
<h1 id="Direct-Connect-LAG"><a href="#Direct-Connect-LAG" class="headerlink" title="Direct Connect LAG"></a>Direct Connect LAG</h1><ul>
<li>链接聚合组 (LAG) 是一个逻辑接口，使用链接聚合控制协议 (LACP) 在一个 AWS Direct Connect 终端节点处聚合多个连接，从而允许将这些连接视为一个托管连接</li>
<li>可从现有连接创建 LAG，也可配置新连接</li>
<li>在创建 LAG 之后，可将现有连接 (无论是独立连接还是其他 LAG 的一部分) 与 LAG 关联</li>
<li>LAG遵循以下规则<ul>
<li>LAG 中的所有连接都必须使用相同的带宽</li>
<li>LAG 中最多可有 4 个连接。LAG 中的每个连接都会计入区域的整体连接限制</li>
<li>LAG 中的所有连接都必须终止于同一 AWS Direct Connect 终端节点<h4 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h4></li>
</ul>
</li>
</ul>
<ul>
<li>AWS Direct Connect user guide</li>
<li><a href="http://jayendrapatil.com/aws-direct-connect-dx" target="_blank" rel="noopener">http://jayendrapatil.com/aws-direct-connect-dx</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/11/AWS地理组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/11/AWS地理组件/" itemprop="url">AWS地理组件</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-11T10:11:31+08:00">
                2019-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font size="1">&gt; <em>前沿：本文主要描述AWS各种服务自身的作用范围（地理），AWS的各种服务所覆盖的地理区域包含全区域、Region、AZ等</em></font></p>
<h3 id="优先解释几个概念"><a href="#优先解释几个概念" class="headerlink" title="优先解释几个概念"></a>优先解释几个概念</h3><p><font color="red">AWS Regions &amp; Availability Zones</font></p>
<ul>
<li>Amazon服务托管在全球多个位置。Amazon提供将资源和数据放置在多个位置的能力，以提高性能、提供容错、高可用性和成本优化</li>
</ul>
<p><font color="red">Region</font></p>
<ul>
<li>AWS为客户提供了在多个地理区域(称为区域)中放置实例和存储数据的灵活性。每个区域都是一个定义地理位置上AWS资源的独立集合。</li>
<li>每个地区都是一个独立的地理区域，是完全独立的。</li>
<li>每个Amazon区域都被设计成与其他区域完全隔离，并帮助实现尽可能大的容错性和稳定性</li>
<li>区域间的通信是通过公共互联网进行的，应该采取适当的措施使用加密技术来保护数据</li>
<li>区域间的数据传输按Internet数据传输速率对发送和接收实例进行收费</li>
<li>除非显式复制，否则不会跨区域复制资源</li>
<li>一个地区的选择可以由许多因素驱动<ul>
<li>延迟—可以选择贴近目标用户群的区域，以减少数据延迟成本</li>
<li>AWS在所有地区提供相同的服务，但通常情况下，由于亚马逊的成本(由于土地、电力、带宽等)不同，服务的成本也会有所不同，因此在一个地区的服务成本可能会低于另一个地区</li>
</ul>
</li>
<li>法律遵从性——许多国家强制执行数据驻留在区域内的遵从性和法规要求（如欧盟的GDPR）</li>
<li>特性——由于并非所有区域都提供所有AWS特性和服务，因此区域选择可以依赖于该区域支持的服务</li>
</ul>
<p><font color="red"> Availability Zones</font></p>
<ul>
<li>每个区域由多个孤立的位置组成，这些位置称为可用性区域，每个可用性区域都运行在其物理上不同的、独立的基础设施上（风火水电完全独立），并且设计得非常可靠。</li>
<li>每个Region都有多个可用性区域。</li>
<li>每个AZ在物理上是相互隔离的（距离在KM以上），因此一个不常见的灾难，如火灾、地震，只会影响一个AZ</li>
<li>AZs在地理上相互分离，位于同一区域内，是一个独立的失效区。</li>
<li>AZ冗余地连接到多个运营商的链路。<br>区域中的AZ使用低延迟的私有链接连接，而不是通过公共internet。</li>
<li>多AZ，跨多个可用性区域的资源分布，特性可用于跨多个AZ分布实例，以提供高可用性。</li>
<li>AWS通过将每个帐户的可用性区域独立映射到标识符，确保资源分布在一个区域的可用性区域之间。例如，us-east-1区域的us-east-1a AZ可能与us-east-1a AZ位于不同的位置。无法协调帐户之间的可用性区域。</li>
</ul>
<p><font color="red">Edge Locations</font></p>
<ul>
<li>Edge location是AWS Cloud Front (CDN)面向全球提供数据加速访问的节点。</li>
<li>主要位于世界上大多数主要城市，CloudFront (CDN)使用这些位置向终端用户分发内容，以减少延迟。<h1 id="1-AWS-地理组件"><a href="#1-AWS-地理组件" class="headerlink" title="1. AWS 地理组件"></a>1. AWS 地理组件</h1></li>
</ul>
<ul>
<li>AWS 提供三种地理性组件：（<a href="https://infrastructure.aws/" target="_blank" rel="noopener">https://infrastructure.aws/</a> 获取最新信息，可查阅这个网站，具体网络连接，region内AZ数量，区域内的PoP节点都可以即时获得。）</li>
<li><strong>Regions</strong>：区域，即AWS提供云服务的一个区域，其目的是为了用户能就近接入，降低网络延迟。通常是一个城市的若干个AZ组成一个region。2016年，AWS 宣布在其全球region之间建设了100GbE 私有环网。</li>
<li><strong>Availability Zones</strong>：一个 region 内至少两个通常三个可用区，其用途是为了搭建高可用架构。一个比较常见的看法是一个AZ是一个数据中心。（其实这不尽然，有时候靠得非常近的几个数据中心也可以组成一个AZ。弗吉尼亚有6个AZ。部分AZ 超过30万台服务器。AZ拥有独立的包括电力和网络在内的基础设施等。）AZ 之间利用低延迟光纤网络互联，延迟控制在3ms以内，AZ内低于0.3ms。（目前所有新建区域的AZ都会保持3个及以上，北京区域属于特殊情况。）</li>
<li><strong>Edge Locations</strong>：指往往部署在大城市，以及主要人口汇聚区域的AWS 站点。它的主要作用是缓存数据，降低延迟。它们独立于region 和 AZ，数量比AZ多很多。它被多个AWS服务利用，比如AWS CloudFront 和 AWS Lambda@Edge。CloudFront 利用它来作为提供给用户分布在全球的接入点，通常称为Edge POP点。</li>
<li><strong>目前全球有21个区域，66个可用区，180个接入点（2019/07/23）</strong></li>
</ul>
<p><img src="https://i.loli.net/2019/08/11/PRfSLEvcx2Fe1h5.jpg" alt="001.jpg"><br><img src="https://i.loli.net/2019/08/11/vaZy2ekGKf37jiM.jpg" alt="003.jpg"></p>
<h1 id="2-AWS基础服务与地理组件关系"><a href="#2-AWS基础服务与地理组件关系" class="headerlink" title="2. AWS基础服务与地理组件关系"></a>2. AWS基础服务与地理组件关系</h1><p><img src="https://i.loli.net/2019/08/11/x1HuiApjYXPF6cR.jpg" alt="004.jpg"></p>
<p>例如：</p>
<ol>
<li>AWS 只有极少数全区域性的，不限于特定region，比如IAM、SES、S3 和 CloudFront（特殊区域除外，如AWS USA GOV、中国区域）</li>
<li>一些服务是覆盖区域的，其作用范围在某个特定区域内，比如经常使用的的S3、AMI</li>
<li>一些服务是覆盖可用区的，其作用范围在某可用区内，比如最常使用的 EC2和EBS</li>
</ol>
<p><img src="https://i.loli.net/2019/08/11/MxZpr82NsRJGl9O.jpg" alt="002.jpg"></p>
<h1 id="3-具体覆盖区域"><a href="#3-具体覆盖区域" class="headerlink" title="3. 具体覆盖区域"></a>3. 具体覆盖区域</h1> <style>
table {
    width: 100%; /*表格宽度*/
    max-width: 65em; /*表格最大宽度，避免表格过宽*/
    border: 1px solid #dedede; /*表格外边框设置*/
    margin: 15px auto; /*外边距*/
    border-collapse: collapse; /*使用单一线条的边框*/
    empty-cells: show; /*单元格无内容依旧绘制边框*/
}
table th,

table td {
  height: 35px; /*统一每一行的默认高度*/
  border: 1px solid #dedede; /*内部边框样式*/
  padding: 0 10px; /*内边距*/
          }
table tbody tr:nth-child(2n) {
    background: rgba(158,188,226,0.12); 
}

table tr:hover {
    background: #efefef; 
}




.table-area {
    overflow: auto;
}

  </style>






<table>
<thead>
<tr>
<th align="center">Service</th>
<th align="center">Global</th>
<th align="center">Region</th>
<th align="center">AZ</th>
<th align="center">subservices</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IAM</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Users, Groups, Roles, Accounts</td>
<td align="left">所有区域都可以使用相同的AWS帐户、用户、组和角色</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Key Pairs</td>
<td align="left">关键对-全球或地区</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Key Pairs</td>
<td align="left">IAM users 是与 AWS account 绑定的，不受限于某个region。</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Key Pairs</td>
<td align="left">注：中国/美国 GOV区域除外，其都有自己独立的IAM账户体系，不与全球共用。</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">Key Pairs</td>
<td align="left">Amazon EC2创建的密钥对是特定于该区域的</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">RSA key pair</td>
<td align="left">RSA密钥对可以创建和上传，可以在所有区域使用。</td>
</tr>
<tr>
<td align="center">KMS</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">存储在创建区域，并且仅在该区域使用。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">VPC</td>
<td align="left">VPC是在一个区域内创建的</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">VPC 位于一个reigon内，且分布在该region的所有AZ内。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">VPC不能迁移至其它region，而只能新建。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">Subnet</td>
<td align="left">子网只能率属于AZ。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">Security groups</td>
<td align="left">安全组绑定到一个区域，并且只能分配给同一区域中的实例。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">VPC Endpoints</td>
<td align="left">您不能在不同区域的VPC和AWS服务之间创建端点。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">VPC Peering</td>
<td align="left">支持region内和跨region</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">NAT gateway</td>
<td align="left">NAT网关运行在AZ中</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">Virtual private gateway (VGW)</td>
<td align="left">VGW在Region范围内自身实现冗余度设计。但是，VPN 服务和DX 需要用户自配置其高可用设计。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">Internet gateway</td>
<td align="left">IGW在Region范围内自身实现高可用、冗余度设计，等同于有多条链路到达IGW。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">Elastic IP Address</td>
<td align="left">在区域内创建的弹性IP地址只能分配给区域内的实例。</td>
</tr>
<tr>
<td align="center">VPC</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">每个region有它自己的地址池，EIP 从该池中分配。</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">Resource Identifiers</td>
<td align="left">资源标识符属于Region范围内，每个资源标识符(如AMI ID、实例ID、EBS卷ID或EBS快照ID)都绑定到其区域，并且只能在创建资源的区域中使用。</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">Instances</td>
<td align="left">实例绑定到启动它的可用性区域。但是，请注意它的实例ID绑定到该区域。</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">EBS Volumes</td>
<td align="left">Amazon EBS卷绑定到它的可用性区域，并且只能附加到同一可用性区域（AZ）中的实例。</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">EBS Snapshot</td>
<td align="left">EBS快照绑定到它的区域，并且只能用于在同一区域创建卷，如果需要，必须从一个区域复制到另一个区域，可利用 Snapshot Copy 功能将其拷贝至其它region</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">AMIs （Aamzon Machine Images）</td>
<td align="left">AMI提供了启动EC2实例的模板</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">AMI与Amazon S3中文件所在的区域绑定。对于在不同区域使用AMI，可以将AMI复制到其他区域</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">AWS 提供 AMI Copy 功能来将某AMI 拷贝至其它region。</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">Auto Scaling</td>
<td align="left">自动扩展跨越同一区域内的多个可用性区域，但不能跨区域</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">ELB(Elastic Load Balancer)</td>
<td align="left">弹性负载均衡器在同一区域的多个可用性区域的多个实例之间分配流量</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">无法将 ELB 迁移至其它region，你只能在其它region中新建ELB实例。</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">SSH Public Keys</td>
<td align="left">保存在region内，AWS不跨region复制或同步keys。</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">Placement Groups</td>
<td align="left">集群放置组部署在同一可用性区域内的实例组</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">S3 bucket  name是全球性，但数据是区域性的</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">S3桶是在选定的区域内创建的Bucket 中的数据物理地位于一个region内，但是可以从其它region上访问它，此时需要考虑到延时问题。</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">存储的对象跨可用性区域复制，以提供高持久性，但除非显式地进行跨区域复制，否则不会跨区域复制</td>
</tr>
<tr>
<td align="center">Glacier</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">要迁移 Glacier 中的数据的话，需要经过几个步骤：1. 将 Glacier 中的数据restore到 S3 中。2. 利用 S3 Copy 功能将数据拷贝至另一个region 3. 利用 S3 lifecycle policy 将 S3 中的数据转移到新的region的 Glacier 内 4. 将原region的 Glacier 中的数据删除。</td>
</tr>
<tr>
<td align="center">Glacier</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">注：目前S3可以向S3 Deep Archive 直接归档数据（如北京region到宁夏）</td>
</tr>
<tr>
<td align="center">EFS</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">有两种数据在region间的迁移途径。1. 将EFS中的数据拷贝至 EBS，然后利用 EBS Snapshot Copy 功能将数据拷贝至另一个region内，再将数据从 EBS 拷贝到 EFS 内。 2. 将 EFS 中的数据拷贝到 S3 中，然后将利用 S3 Cross-region Replication 功能将数据拷贝至另一个region，再从S3 拷贝到EFS。</td>
</tr>
<tr>
<td align="center">Route53</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">Route53服务是在AWS的边缘位置提供的，并且是全球性的</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="left">RDS 实例有单可用区的，也有跨多AZ 的</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">可利用 AWS Database Migration Serivce 进行跨区域迁移</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">跨区域的手工数据迁移步骤：1. 停止transactions 2. 在一个临时 EC2 将 DB 中的数据导出为文件 3. 利用工具将文件拷贝至远端region的EC2内 4. 创建RDS实例 5. 导入数据文件</td>
</tr>
<tr>
<td align="center">ElastiCache</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">支持 Redis 和 Memcached</td>
</tr>
<tr>
<td align="center">ElastiCache</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">Redis 迁移方法：1. 给集群手工创建一个 backup 2. 将backup 导入 S3. 4. S3 bucket 复制到另一个region。 5. 在新的region 内从 S3 restore 数据，其过程包括创建一个新的 Redis cluster 然后导入数据。</td>
</tr>
<tr>
<td align="center">ElastiCache</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">Memcached 数据跨region 迁移方法：在新的region 内创建一个 cluster，然后从应用层做数据复制。</td>
</tr>
<tr>
<td align="center">RedShift</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">集群迁移：利用 RedShift cross-region snapshot 功能创建snapshot 并将它拷贝到新的region内，然后将snapshot restore 到集群。</td>
</tr>
<tr>
<td align="center">RedShift</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">表迁移：利用 RedShift Upload 功能将数据导入 S3，再利用 S3 Cross-region Replication 功能将数据复制到另一个region，再在另一个region内创建 RedShift 集群并利用 COPY 功能从S3 中导入数据。</td>
</tr>
<tr>
<td align="center">EMR</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">跨region 迁移 EMR：在新的 region 内新建 EMR Cluster，然后导入数据</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">如果数据在 S3 中，则利用 S3 cross-region replication 功能将数据迁移到新的 region 内</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">如果数据在 HDFS 内，择利用 S3DistCp 命令将HDFS 内的数据拷贝到 S3， 然后再利用 S3DistCp 命令将S3 中的数据拷贝到目标 HDFS 内。</td>
</tr>
<tr>
<td align="center">Elasticsearch</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">为 ES domain 创建一个 snapshot，它会被保存到 S3 内。再利用 S3 做跨region 复制。再在新region内将数据从S3 恢复到 Elasticsearch 中。</td>
</tr>
<tr>
<td align="center">SQS</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">SQS queues 位于region内。需要利用应用，将消息从源region 的 queues 中导入目的 region的 queues 内。</td>
</tr>
<tr>
<td align="center">SNS</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">SNS topics 位于region 内</td>
</tr>
<tr>
<td align="center">Auroa</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">在另一个region 内创建一个 Aurora Cluster 作为 Read Replica。一旦创建后，Amazon RDS 对原 Aurora cluster 做snapshot，然后将 snapshot 发送只 Read Replica。</td>
</tr>
<tr>
<td align="center">DynamoDB</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">所有数据对象都存储在同一区域内，并跨同一区域中的多个可用性区域复制</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">可以使用跨区域复制显式地跨区域复制数据对象</td>
</tr>
<tr>
<td align="center">WAF</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">WAF服务保护Web应用程序免受常见Web攻击，它是在AWS边缘位置提供的，并且是全局的</td>
</tr>
<tr>
<td align="center">CloudFront</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">CloudFront是全球内容交付网络(CDN)服务，</td>
</tr>
<tr>
<td align="center">Storage Gateway</td>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">AWS存储网关适用范围在Region范围内，提供存储卷、快照和磁带数据的网关。</td>
</tr>
<tr>
<td align="center">SES</td>
<td align="center">Y</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="left">SES 有 regional endpoint。你的应用既可以使用与它相同region内的 SES服务，也可以利用其它region内的SES服务。当然了，这里面需</td>
</tr>
</tbody></table>
<h4 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h4><ul>
<li>《Using Amazon Web Services for Disaster Recovery》</li>
<li>《Migrating AWS Resources to a New AWS Region》</li>
<li>《Building Fault-Tolerant Application on AWS》</li>
<li>刘世民 云计算 博客</li>
<li><a href="http://jayendrapatil.com/aws-global-vs-regional-vs-az-resources/" target="_blank" rel="noopener">http://jayendrapatil.com/aws-global-vs-regional-vs-az-resources/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/10/AWS-VPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/10/AWS-VPC/" itemprop="url">AWS VPC</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-10T11:30:44+08:00">
                2019-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><font size="2"> &gt; <em>前言：在 Amazon Web Services (AWS) 云中预置一个逻辑隔离的部分，可以在自己定义的虚拟网络中启动 AWS 资源。完全掌控您的虚拟联网环境，包括选择自己的 IP 地址范围、创建子网以及配置路由表和网络网关。在 VPC 中可以使用 IPv4 和 IPv6，因此能够轻松安全地访问资源和应用程序。</em></font></p>
<h2 id="VPC-Overview-amp-Components"><a href="#VPC-Overview-amp-Components" class="headerlink" title="VPC Overview &amp; Components"></a>VPC Overview &amp; Components</h2><font face="微软雅黑">

<ul>
<li>虚拟私有云（VPC）是专用于AWS账户的虚拟网络， 它在逻辑上与AWS云中的其他虚拟网络隔离</li>
<li>VPC允许用户选择IP地址范围，创建子网，以及配置路由表，网络网关和安全设置</li>
<li>VPC sizing<ul>
<li>创建 VPC 时将单个无类别互联网域路由 (CIDR) IP 地址范围指定为主 CIDR 块，默认 VPC 分配有 172.31.0.0/16 的 CIDR 范围（允许2 ^ 16（65536）IP地址可用）</li>
<li>允许的CIDR块大小介于以下两者之间<ol>
<li>/ 28网络掩码（最小值为2 ^ 4  -  16个可用IP地址）</li>
<li>/ 16网络掩码（最大为2 ^ 16  -  65536 IP地址）</li>
</ol>
</li>
</ul>
</li>
<li>可以分配来自专用（非公共路由）IP地址的CIDR块<ol>
<li>10.0.0.0  -  10.255.255.255（10/8前缀）</li>
<li>172.16.0.0  -  172.31.255.255（172.16 /12前缀）</li>
<li>192.168.0.0  -  192.168.255.255（192.168/16前缀）<ul>
<li>可以指定一系列可公开路由的IP地址;然而，VPC中公开路由的CIDR块目前不支持直接访问Internet(public subnet)</li>
<li>现在可以调整VPC的size</li>
<li>每个VPC都与使用相同CIDR块创建的任何其他VPC分开，即使它位于同一AWS账户中</li>
</ul>
</li>
</ol>
</li>
<li>VPC允许VPC对等连接与相同或不同AWS账户中的其他VPC</li>
<li>可以建立VPC与公司或家庭办公网络之间的连接，但是CIDR块不应重叠，例如： 具有CIDR 10.0.0.0/16的VPC可以与10.1.0.0/16公司网络通信，但如果尝试连接到10.0.37.0/16公司网络导致重叠IP地址，则连接将被丢弃。</li>
<li>VPC允许其中启动的实例设置租期选项。 默认情况下，租赁选项是共享的。 如果选择了专用选项，则其中的所有实例都将在覆盖单个实例租用设置的专用硬件上启动</li>
<li>只有在终止VPC中的所有实例并删除具有VPC的所有组件之后，才可能删除VPC，包括子网，安全组，网络ACL，路由表，Internet网关，VPC对等连接和DHCP选项</li>
<li>AWS VPC组件<br><img src="https://i.loli.net/2019/08/10/fLeUIt8TSy6vD5Q.png" alt="AWS-VPC-Components.png"><h2 id="IP-Address"><a href="#IP-Address" class="headerlink" title="IP Address"></a>IP Address</h2>在VPC中启动的实例可以分配私有，公共和弹性IP地址，并且是ENI（弹性网络接口）的属性<h3 id="Private-IP-Addresses"><a href="#Private-IP-Addresses" class="headerlink" title="Private IP Addresses"></a>Private IP Addresses</h3></li>
<li>私有IP地址无法通过Internet访问，并且只能用于VPC内的实例之间的通信</li>
<li>所有实例都在子网的IP地址范围内分配给默认网络接口(eth0)的私有IP地址</li>
<li>主（Primary）IP地址在其生命周期内与网络接口相关联，即使实例已停止并重新启动，仅在实例终止时才释放</li>
<li>可以将其他私有IP地址（称为辅助专用IP地址）分配给实例，这些可以从一个网络接口重新分配给另一个网络接口（非eth0）<h3 id="Public-IP-Addresses"><a href="#Public-IP-Addresses" class="headerlink" title="Public IP Addresses"></a>Public IP Addresses</h3></li>
<li>公共IP地址可通过Internet访问，可用于实例与Internet之间的通信，也可用于具有公共端点的其他AWS服务</li>
<li>为实例分配公共IP地址取决于是否为子网启用了公共IP属性</li>
<li>通过在创建实例期间启用公共IP，也可以将公共IP分配给实例，从而覆盖子网的公共IP寻址属性</li>
<li>公共IP地址是从AWS IP地址池分配的，它与AWS账户无关，因此在实例停止并重新启动或终止时会释放<h3 id="Elastic-IP-Address"><a href="#Elastic-IP-Address" class="headerlink" title="Elastic IP Address"></a>Elastic IP Address</h3></li>
<li>弹性IP地址是静态的，持久的公共IP地址，可以根据需要与实例关联或解除关联</li>
<li>弹性IP地址在VPC上分配，并由帐户拥有，除非被释放</li>
<li>可以为网络接口分配公共IP或弹性IP。 如果分配已具有公共IP，分配弹性IP的实例时，则会释放公共IP</li>
<li>弹性IP地址可以从一个实例移动到另一个实例，该实例可以位于同一帐户中的相同或不同VPC内</li>
<li>弹性IP收取费用，即使其并未与相关实例绑定或ENI相关联<h2 id="Elastic-NetworkInterface（ENI）"><a href="#Elastic-NetworkInterface（ENI）" class="headerlink" title="Elastic NetworkInterface（ENI）"></a>Elastic NetworkInterface（ENI）</h2></li>
<li>每个实例都附带默认的弹性网络接口（主网络接口eth0），不能与实例分离</li>
<li>ENI包含以下属性<ul>
<li>Primary 私有IP</li>
<li>一个或多个辅助私有IP地址</li>
<li>每个privateIP地址一个弹性IP地址</li>
<li>一个公共IP地址，可以在启动实例时自动分配给eth0的网络接口，仅在为eth0创建网络接口而不是使用现有ENI</li>
<li>一个或多个安全组</li>
<li>一个MAC地址</li>
<li>源/目标检查标志</li>
<li>其他说明</li>
</ul>
</li>
<li>ENI的属性归属ENI，不属于实例，可以与实力连接或分离，并重新连接到另一个实例，属性仍然有效。 当ENI从一个实例移动到另一个实例时，网络流量将重定向到新实例。</li>
<li>实例可以附加多个ENI，有着一下好处<ul>
<li>独立管理网络</li>
<li>在VPC中使用网络和安全设施</li>
<li>使实例在不同子网上具有不同工作负载/角色</li>
<li>性价比、高可用的解决方案<h2 id="Route-Tables"><a href="#Route-Tables" class="headerlink" title="Route Tables"></a>Route Tables</h2></li>
</ul>
</li>
<li>路由表定义的规则，称为路由，确定在何处从子网的网络流量将被路由</li>
<li>每个VPC都有一个隐式路由器来路由网络流量</li>
<li>每个VPC都有一个主路由表，可以创建多个自定义路由表</li>
<li>VPC中的每个子网必须一次与一个路由表相关联，而路由表可以有多个与之关联的子网</li>
<li>如果未明确地与路由表关联，则子网与主路由表隐式关联</li>
<li>每个路由表都包含一个本地路由，该路由允许在VPC内进行无法修改或删除的通信</li>
<li>路由优先级通过匹配路由表中与流量匹配的最具体路由来确定</li>
<li>路由表需要更新，已经定义的好的网关设备如IGW，虚拟专用网关，VPC对等，VPC端点，NAT设备等<h2 id="Internet-Gateways-IGW"><a href="#Internet-Gateways-IGW" class="headerlink" title="Internet Gateways-IGW"></a>Internet Gateways-IGW</h2></li>
<li>IGW是一种水平扩展，冗余且高度可用的VPC组件，允许在VPC和Internet中的实例之间进行通信</li>
<li>IGW不对网络流量设置带宽限制或成为故障风险点（国内公有云有网络出口限制，同时这里的带宽不限制，是在不超过AWS自身网络限制）</li>
<li>IGW有两个用途：在VPC路由表中为可路由Internet的流量提供网关目标，以及实例（未分配公有IP地址）执行网络地址转换（NAT）</li>
<li>实例访问Internet需要满足一下要求<ul>
<li>将IGW关联到VPC</li>
<li>子网具有指向IGW网关的路由表</li>
<li>实例应分配公共IP或弹性IP</li>
<li>与实例关联的安全组和AACL应该允许其流量通过<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2></li>
</ul>
</li>
<li>NAT设备允许私有子网中的实例连接到Internet或其他AWS服务，但阻止Internet与实例的连接</li>
<li>NAT设备不支持IPv6流量，而应使用egress-only Internet gateway网关<h2 id="Egress-only-Internet-gateway"><a href="#Egress-only-Internet-gateway" class="headerlink" title="Egress-only Internet gateway"></a>Egress-only Internet gateway</h2></li>
<li>像NAT网关使用，并且仅支持IPv6</li>
<li>Egress Only Internet Gateway网关是一种水平扩展，冗余且高度可用的VPC组件，允许通过IPv6从VPC中的实例向Internet进行出站通信，并防止Internet实例的IPv6连接</li>
<li>仅用于IPv6,如果要启用IPv4请使用NGW<h2 id="VPC-amp-Subnet-Sizing"><a href="#VPC-amp-Subnet-Sizing" class="headerlink" title="VPC &amp; Subnet Sizing"></a>VPC &amp; Subnet Sizing</h2></li>
<li>VPC支持IPv4和IPv6寻址，并且每个都具有不同的CIDR块大小限制</li>
<li>VPC 可以同时有 IPv4 和 IPv6 CIDR 块与其关联</li>
<li>对于 IPv6，VPC 使用 /56 的固定大小</li>
<li>通过向现有 VPC 添加四 (4) 个辅助 IPv4 IP 范围 (CIDR) 来扩展 VPC。可通过删除已添加到 VPC 的辅助 CIDR 块来缩小 VPC；不能更改 VPC 的 IPv6 地址范围的大小</li>
<li>限制<ul>
<li>允许的块大小介于/ 28~ / 16网络掩码之间</li>
<li>CIDR块不得与任何与VPC关联的现有CIDR块重叠</li>
<li>CIDR块不能与任何VPC路由表中的路由的CIDR范围相同或更大，例如， 对于CIDR块10.0.0.0/24，只能关联较小的CIDR块，如10.0.0.0/25<h2 id="VPC-Security"><a href="#VPC-Security" class="headerlink" title="VPC Security"></a>VPC Security</h2>提供三种功能，以用来提高和监控 Virtual Private Cloud (VPC) 的安全性</li>
</ul>
</li>
<li>安全组 充当实例的虚拟防火墙以控制入站和出站流量</li>
<li>网络访问控制列表 (ACL) 是 VPC 的一个可选安全层，可用作防火墙来控制进出一个或多个子网的流量</li>
<li>VPC 流日志这项功能，捕获有关传入和传出VPC 中网络接口的 IP 流量的信息<br><img src="https://i.loli.net/2019/08/10/fQTSim9weNAOWLR.png" alt="security-diagram.png"><h3 id="Security-Groups"><a href="#Security-Groups" class="headerlink" title="Security Groups"></a>Security Groups</h3></li>
<li>在实例级别而不是在子网级别执行</li>
<li>可以为子网中的每个实例分配不同的安全组</li>
<li>可以为实例分配5个安全组，每个安全组具有50个规则</li>
<li>安全组允许为实例的入站（入口）和出站（出口）流量添加或删除规则（授权或撤消访问）<ul>
<li>默认安全组不允许外部入站流量，但允许来自具有相同安全组的实例的入站流量</li>
<li>默认安全组允许所有出站流量</li>
<li>新安全组仅以允许所有流量离开实例的出站规则开始</li>
</ul>
</li>
<li>安全组只能指定允许规则，但不包含拒绝规则</li>
<li>安全组可以授予对特定CIDR范围或VPC中的另一个安全组或对等VPC的访问权限（需要VPC对等连接）</li>
<li>安全组被评估为完整或累积规则，其中最宽松的规则优先。对于例如 如果有一个允许从IP地址203.0.113.1访问TCP端口22（SSH）的规则和允许从每个人访问TCP端口22的另一个规则，则每个人都可以访问TCP端口22</li>
<li>安全组是<font color="red">有状态的</font> - 无论出站规则如何，都允许对允许的入站流量的响应流出，反之亦然。 因此，不需要响应的出站规则</li>
<li>安全组与ENI（网络接口）相关联</li>
<li>可以更改与实例关联的安全组，这会更改与主网络接口（eth0）关联的安全组，并且更改将立即应用于与安全组关联的所有实例<h4 id="Connection-Tracking"><a href="#Connection-Tracking" class="headerlink" title="Connection Tracking"></a>Connection Tracking</h4></li>
<li>由于安全组是有状态的，基于流量的连接状态应用规则以确定允许还是拒绝流量</li>
<li>无论出站安全组规则如何，都允许对入站流量的响应流出实例，反之亦然。</li>
<li>仅当入站请求没有明确的出站规则时才会维护连接跟踪（响应流量基于允许响应流量的入站或出站规则流动，而不是基于跟踪信息流动）</li>
<li>但是，如果是入站请求一个明确的出站规则，响应流量被允许出站规则的基础上，而不是跟踪连接</li>
<li>跟踪流量</li>
</ul>
<ol>
<li>对于除 TCP、UDP 或 ICMP 以外的协议，仅跟踪 IP 地址和协议编号</li>
<li>实例将流量发送到另一个主机 (主机 B)，并且在原始请求或响应的 600 秒内，主机 B 在单独的请求中发起到实例的同一类型的流量，则无论入站安全组规则如何，实例都将接受该请求，因为该流量被视为响应流量</li>
</ol>
<ul>
<li>确保所有入站流量均遵循防火墙规则，可以使用网络 ACL — <font color="red">网络 ACL 是无状态的</font>，因此不会自动允许响应流量<h3 id="NACLs"><a href="#NACLs" class="headerlink" title="NACLs"></a>NACLs</h3></li>
<li>网络访问控制列表 (ACL) 是 VPC 的一个可选安全层，可用作防火墙来控制进出一个或多个子网的流量</li>
<li>NACL作用于子网级别控制，并且适用于该子网中的所有实例</li>
<li>网络ACL具有单独的入站和出站规则，每个规则可以允许或拒绝流量默认ACL允许所有入站和出站流量</li>
<li>新创建的ACL拒绝所有入站和出站流量</li>
<li>子网只能分配1个ACL，如果没有明确关联，则会与默认NACL隐式关联</li>
<li>网络ACL是按顺序评估的编号规则列表</li>
<li>从编号最小的规则开始，确定是否允许流量进出与网络ACL关联的任何子网</li>
<li>例如如果你有一个允许全部的规则100和一个全部拒绝的规则110，则允许全部优先，所有流量都将被允许</li>
<li>网络ACL是无状态的;对允许的入站流量的响应受出站流量规则的约束（反之亦然），例如：如果从特定IP地址启用端口22上的入站SSH，则还需要为响应添加出站规则<h4 id="安全组-vs-ACL"><a href="#安全组-vs-ACL" class="headerlink" title="安全组 vs ACL"></a>安全组 vs ACL</h4><table>
<thead>
<tr>
<th>安全组</th>
<th>ACL</th>
</tr>
</thead>
<tbody><tr>
<td>在实例级别运行</td>
<td>在子网级别运行</td>
</tr>
<tr>
<td>仅支持允许规则</td>
<td>支持允许规则和拒绝规则</td>
</tr>
<tr>
<td>有状态：返回数据流会被自动允许，不受任何规则的影响</td>
<td>无状态：返回数据流必须被规则明确允许</td>
</tr>
<tr>
<td>决定是否允许数据流前评估所有规则</td>
<td>决定是否允许数据流时按照数字顺序处理所有规则</td>
</tr>
<tr>
<td>只有在启动实例的同时指定安全组、或稍后将安全组与实例关联的情况下，操作才会被应用到实例</td>
<td>自动应用到关联子网内的所有实例（因此不需要依靠用户指定安全组）</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="VPC-Flow-logs"><a href="#VPC-Flow-logs" class="headerlink" title="VPC Flow logs"></a>VPC Flow logs</h2><ul>
<li>VPC 流日志这项功能，捕获有关传入和传出 VPC 中网络接口的 IP 流量的信息。流日志数据可以发布到 Amazon CloudWatch Logs 和 Amazon S3。创建流日志后，可以在选定目标中检索和查看其数据</li>
<li>可以为 VPC、子网或网络接口创建流日志。如果为子网或 VPC 创建流日志，则会监视 VPC 或子网中的每个网络接口</li>
<li>流日志不会为网络接口捕获实时日志流(通常需要几分钟开始收集数据并发布到指定目标)</li>
<li>可以为其他 AWS 创建的网络接口创建流日志，例如 Elastic Load Balancing、Amazon RDS、Amazon ElastiCache、Amazon Redshift 和 Amazon WorkSpaces<h2 id="Subnets"><a href="#Subnets" class="headerlink" title="Subnets"></a>Subnets</h2></li>
<li>子网跨越单个可用区，不同的位置设计为AZ级别故障隔离</li>
<li>子网可以配置IGW以启用Internet通信，或虚拟专用网关（VPN）连接以启用与公司网络的连通</li>
<li>子网可以是公共的或私有的，它取决于它是否具有因特网连接，即能够通过IGW将流量路由到因特网</li>
<li>应为公共子网中的实例分配公共IP或弹性IP地址，以便能够与Internet通信</li>
<li>对于未连接到Internet的子网，但通过虚拟专用网关路由的流量称为VPN专属子网</li>
<li>可以将子网配置为默认为子网内启动的所有实例分配公共IP地址</li>
<li>Subnet sizing <ul>
<li>分配给子网的CIDR块可以与VPC CIDR相同，在这种情况下，只能在VPC中启动一个子网</li>
<li>分配给子网的CIDR块可以是VPC CIDR的子集，允许在VPC中启动多个子网</li>
<li>分配给子网的CIDR块不应重叠</li>
<li>允许的CIDR块大小介于两者之间<ul>
<li>/28网络掩码（最小值为2 ^ 4  -  16个可用IP地址）</li>
<li>16网络掩码（最大为2 ^ 16  -  65536 IP地址）</li>
</ul>
</li>
<li>AWS在每个子网中保留5个IP地址（前4个和后1个IP地址），这些地址不可用，无法分配给实例。 例如 对于具有CIDR块10.0.0.0/24的子网，保留以下五个IP<ul>
<li>10.0.0.0：网络地址</li>
<li>10.0.0.1：AWS为VPC路由器保留</li>
<li>10.0.0.2：由AWS保留，用于映射到亚马逊提供的DNS</li>
<li>10.0.0.3：AWS保留供将来使用</li>
<li>10.0.0.255：网络广播地址。 AWS不支持VPC中的广播，因此保留地址</li>
</ul>
</li>
</ul>
</li>
<li>子网路由<ul>
<li>每个子网都与一个路由表相关联</li>
</ul>
</li>
<li>子网安全<ul>
<li>可以使用安全组和NACL配置子网安全性</li>
<li>安全组在实例级别工作，NACL在子网级别工作<h2 id="Shared-VPCs"><a href="#Shared-VPCs" class="headerlink" title="Shared VPCs"></a>Shared VPCs</h2></li>
</ul>
</li>
<li>VPC 共享允许多个 AWS 账户在共享的集中式管理的 Amazon Virtual Private Cloud (VPC) 中创建自己的应用程序资源，如 Amazon EC2、Amazon Relational Database Service (RDS)、Amazon Redshift 群集和 AWS Lambda</li>
<li>在此模型中，拥有 VPC 的账户（所有者）与属于 AWS Organizations 中同一组织的其他账户（参与者）共享一个或多个子网</li>
<li>共享子网之后，参与者可以查看、创建、修改和删除与他们共享的子网中的应用程序资源。参与者无法查看、修改或删除属于其他参与者或 VPC 拥有者的资源<h2 id="VPC-Endpoints"><a href="#VPC-Endpoints" class="headerlink" title="VPC Endpoints"></a>VPC Endpoints</h2></li>
<li>VPC 终端节点能够将 VPC 创建专有链接连接到支持的 AWS 服务和 VPC 终端节点服务（由 PrivateLink 提供支持），而无需 Internet 网关、NAT 设备、VPN 连接或 AWS Direct Connect 连接。VPC 中的实例无需公有 IP 地址便可与服务中的资源通信。VPC 和其他服务之间的通信不会离开 Amazon 网络。</li>
<li>终端节点是虚拟设备。这些是水平扩展、冗余且具备高可用性的 VPC 组件，通过使用这些组件，可以在 VPC 中的实例与服务之间进行通信，而不会对网络通信带来可用性风险或带宽限制</li>
<li>端点当前不支持跨区域请求，请确保在与服务相同相同的区域中创建端点</li>
<li>VPC 终端节点有两种类型：接口终端节点 和 网关终端节点</li>
<li>VPC 终端节点策略是一种 IAM 资源策略，在创建或修改终端节点时可将它附加到终端节点</li>
<li>默认策略来允许对服务进行完全访问。终端节点策略不会覆盖或取代 IAM 用户策略或服务特定策略 (如 S3 存储桶策略)<h3 id="网关-VPC-终端节点"><a href="#网关-VPC-终端节点" class="headerlink" title="网关 VPC 终端节点"></a>网关 VPC 终端节点</h3></li>
<li>网关终端节点是一个网关，作为路由表中的指定路由的目标（用于发送到受支持的 AWS 服务的流量）</li>
<li>支持Amazon S3&amp;DynamoDB<br><img src="https://i.loli.net/2019/08/10/oQuy8DG35PSltWF.png" alt="AWS-VPC-Endpoints.png"></li>
<li>Configuration<ol>
<li>指定要在其中创建终端节点的 VPC 以及要连接到的服务</li>
<li>端点需要与Route表关联，并且不能修改路由表以删除路由条目。只能通过删除与Route表的Endpoint关联来删除它</li>
<li>路由会自动添加到每个路由表中，同时会添加一个指定服务的前缀列表 ID 的目的地 (pl-xxxxxxxx) 以及一个具有终端节点 ID 的目标 (vpce-xxxxxxxx)；例如：</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th>目的地</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>10.0.0.0/16</td>
<td>本地</td>
</tr>
<tr>
<td>pl-1a2b3c4d</td>
<td>vpce-11bb22cc</td>
</tr>
</tbody></table>
<ol start="4">
<li>端点策略可以控制对其他服务中的资源的访问</li>
<li>需要修改安全组以允许从VPC到端点中指定的服务的出站流量。 使用服务前缀列表ID，例如 com.amazonaws.us-east-1.s3作为出站规则中的目的地<ol start="6">
<li>在一个路由表中拥有针对不同服务的多个终端节点路由，并且可以在不同的路由表中拥有针对同一服务的多个终端节点路由，但不能在一个路由表中拥有针对同一服务的多个终端节点路由。例如，如果 VPC 中有两个针对 Amazon S3 的终端节点，则不能同时对这两个终端节点使用相同的路由表</li>
</ol>
</li>
</ol>
<ul>
<li>限制<ul>
<li>仅在同一地区内支持终端节点。无法在 VPC 和其他区域内的服务之间创建终端节点</li>
<li>无法将终端节点从一个 VPC 转移到另一个 VPC，也无法将终端节点从一项服务转移到另一项服务</li>
<li>无法将终端节点连接扩展到 VPC 之外。VPC 中的 VPN 连接、VPC 对等连接、AWS Direct Connect 连接或 ClassicLink 连接的另一端的资源不能使用终端节点与终端节点服务中的资源进行通信<h3 id="接口终端节点"><a href="#接口终端节点" class="headerlink" title="接口终端节点"></a>接口终端节点</h3></li>
</ul>
</li>
<li>接口 VPC 终端节，可连接到由 AWS PrivateLink 提供支持的服务</li>
<li>服务包括一些AWS服务，例如： CloudTrail，CloudWatch等，由其他AWS客户和合作伙伴在其自己的VPC（称为端点服务）中托管的服务，以及受支持的AWS Marketplace合作伙伴服务<br><img src="https://i.loli.net/2019/08/10/7VcIfgrZWMyF4GT.png" alt="VPC-Interface-Endpoints.png"></li>
<li>配置</li>
</ul>
<ol>
<li>选择要在其中创建接口终端节点的 VPC，然后提供要连接到的 AWS 服务、终端节点服务或 AWS Marketplace 服务的名称。</li>
<li>在 VPC 中选择使用接口终端节点的子网。将在该子网中创建一个终端节点网络接口</li>
<li>指定要与终端节点网络接口关联的安全组</li>
<li>为终端节点启用私有 DNS 以使能够使用服务的默认 DNS 主机名对服务发出请求（可选）</li>
</ol>
<ul>
<li>限制</li>
</ul>
<ol>
<li>对于每个接口终端节点，每个可用区只能选择一个子网</li>
<li>默认情况下，每个可用区的每个接口终端节点可支持高达 10 Gbps 的带宽</li>
<li>子网的网络ACL可以限制流量，需要正确配置</li>
<li><font color="red">接口终端节点仅支持 TCP 流量</font></li>
<li>仅在同一地区内支持终端节点</li>
<li>仅支持 IPv4 流量</li>
<li>无法将终端节点从一个 VPC 转移到另一个 VPC，也无法将终端节点从一项服务转移到另一项服务<h2 id="VPC-Peering"><a href="#VPC-Peering" class="headerlink" title="VPC Peering"></a>VPC Peering</h2></li>
</ol>
<ul>
<li>VPC 对等连接是两个 VPC 之间的网络连接，可通过此连接不公开地在这两个 VPC 之间路由流量(Private IP address)</li>
<li>两个 VPC 中的实例可以彼此通信，就像它们在同一网络中一样</li>
<li>可以在自己的 VPC 之间、自己的 VPC 与另一个 AWS 账户中的 VPC 或与其他 AWS 区域中的 VPC 之间创建 VPC 对等连接</li>
<li>AWS 使用 VPC 的现有基础设施来创建 VPC 对等连接；该连接既非网关也非 AWS Site-to-Site VPN 连接，且不依赖某个单独的物理硬件。</li>
<li>没有单点通信故障也没有带宽瓶颈</li>
</ul>
<h3 id="VPC-对等连接规则和限制"><a href="#VPC-对等连接规则和限制" class="headerlink" title="VPC 对等连接规则和限制"></a>VPC 对等连接规则和限制</h3><ol>
<li><p>不能在重叠CIDR块的VPC之间创建VPC对等连接<br><img src="https://i.loli.net/2019/08/10/xHQWgin81pjRylO.png" alt="Screen-Shot-2016-06-15-at-12.33.07-PM.png"></p>
</li>
<li><p>每个 VPC 创建数量有限的活动和待定 VPC 对等连接</p>
<table>
<thead>
<tr>
<th>源</th>
<th>默认限制</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>每个 VPC 的活动 VPC 对等连接</td>
<td>50</td>
<td>每个 VPC 的最大限制为 125 个对等连接。应相应地增加每个路由表的条目数；但是，网络性能可能会受到影响</td>
</tr>
<tr>
<td>未完成的 VPC 对等连接请求</td>
<td>25</td>
<td>这是账户请求的未完成 VPC 对等连接请求数的限制</td>
</tr>
<tr>
<td>未接受的 VPC 对等连接请求的过期时间</td>
<td>1</td>
<td>周 (168 小时)</td>
</tr>
</tbody></table>
</li>
<li><p>VPC 对等不支持传递的对等关系。在 VPC 对等连接中， VPC 无权访问对等 VPC 可能与之对等的任何其他 VPC<br><img src="https://i.loli.net/2019/08/10/Z7nO2QzRpqYMtld.png" alt="Screen-Shot-2016-06-15-at-12.33.00-PM.png"></p>
</li>
<li><p>VPC对等不支持通过网关或专用连接进行边缘到边缘路由</p>
</li>
<li><p>在VPC对等连接中，VPC无法访问对等VPC可能具有的任何其他连接， </p>
<ul>
<li>与企业网络之间的 VPN 连接或 AWS Direct Connect 连接</li>
<li>通过 Internet 网关建立的 Internet 连接</li>
<li>在私有子网中通过 NAT 设备建立的 Internet 连接</li>
<li>AWS 服务的 VPC 终端节点；例如，Amazon S3 的终端节点<br><img src="https://i.loli.net/2019/08/10/kciwbLvoAMqHDYj.png" alt="Screen-Shot-2016-06-15-at-12.35.38-PM.png"></li>
</ul>
</li>
<li><p>在同一个两个VPC之间只能建立一个VPC对等连接</p>
</li>
<li><p>VPC对等连接上的最大传输单元（MTU）为1500字节</p>
</li>
<li><p>置放组（place group）可在同一区域内建立对等连接，但在对等连接中无法获得全部带宽</p>
</li>
<li><p>VPC 对等连接创建的任何标签仅在创建它们的账户或区域中应用</p>
</li>
<li><p>不支持在 VPC 对等连接中进行单一地址反向传输路径转发</p>
</li>
<li><p><font color="red">必须为 VPC 对等连接启用 DNS 解析支持才能将对等 VPC 的私有 DNS 主机名解析为私有IP地址</font></p>
<h3 id="VPC-Peering-Architecture"><a href="#VPC-Peering-Architecture" class="headerlink" title="VPC Peering Architecture"></a>VPC Peering Architecture</h3><p><img src="https://i.loli.net/2019/08/10/H19WGByM87D6log.png" alt="Screen-Shot-2016-11-12-at-3.20.55-PM.png"></p>
</li>
</ol>
<ul>
<li>可以应用VPC对等来创建共享服务或使用本地实例执行身份验证</li>
<li>这将有助于创建单个联系，并将VPN连接限制到单个帐户或VPC<h2 id="VPC-VPN-Connections-amp-CloudHub"><a href="#VPC-VPN-Connections-amp-CloudHub" class="headerlink" title="VPC VPN Connections &amp; CloudHub"></a>VPC VPN Connections &amp; CloudHub</h2></li>
<li>VPC  VPN 连接用于将本地数据中心扩展到AWS云中</li>
<li>通过IPSec技术实现安全连接</li>
<li>硬件VPN<ul>
<li>VPC和远程网络之间创建IPSec隧道，硬件VPN连接来建立连接</li>
<li>在VPN连接的AWS端，虚拟专用网关（VGW）提供两个VPN端点以进行自动故障转移</li>
<li>在客户端需要配置客户网关（CGW），这是VPN连接远程端的物理设备或软件应用程序</li>
</ul>
</li>
<li>AWS Direct Connect<ul>
<li>AWS Direct Connect提供从远程网络到VPC的专用专用连接</li>
<li>Direct Connect可与AWS硬件VPN连接结合使用，以创建IPsec加密连接</li>
</ul>
</li>
<li>AWS VPN CloudHub<ul>
<li>有多个远程网络（例如，多个分公司），则可以通过虚拟专用网关创建多个 AWS Site-to-Site VPN 连接，来启用这些网络之间的通信</li>
</ul>
</li>
<li>Software VPN<ul>
<li>通过在 VPC 中使用正在运行软件 VPN 设备的 Amazon EC2 实例来创建与远程网络的 VPN 连接</li>
<li>AWS 不提供或维护第三方软件 VPN 设备；但是，可以选择合作伙伴和开源社区提供的一系列产品<h3 id="Hardware-VPN"><a href="#Hardware-VPN" class="headerlink" title="Hardware VPN"></a>Hardware VPN</h3><img src="https://i.loli.net/2019/08/10/1DJ9cQhp4KTznjE.png" alt="VPN-Connection.png"><h4 id="VPN-组件"><a href="#VPN-组件" class="headerlink" title="VPN 组件"></a>VPN 组件</h4></li>
</ul>
</li>
<li>虚拟专有网关—VGW<ul>
<li>VPN连接的AWS侧的VPN集中器</li>
</ul>
</li>
<li>客户网关——CGW<ul>
<li>客户网关是连接中用户侧使用的定位标记。它可以是物理或软件设备</li>
<li>VPN连接时，会在创建两端创建VPN隧道</li>
<li>VGW不是发起者，需要CGW启动VPN连接</li>
<li>若VPN链接建立之后超过10秒的空闲连接（具体看配置属性），隧道会自动关闭。为了避免这种情况，建议用网络监控工具保持周期性的ping，例如使用IP SLA。<h4 id="VPN-配置"><a href="#VPN-配置" class="headerlink" title="VPN 配置"></a>VPN 配置</h4></li>
</ul>
</li>
</ul>
<ul>
<li>VPC包含的VGW，并且远程网络部署客户网关，必须将两者配置为启用</li>
<li>配置路由，以便来自绑定到远程网络的VPC的任何流量都路由到虚拟专用网关（VGW）</li>
<li>每个VPN都有两个与之关联的隧道，可以在客户路由器上配置，因为不是单点故障</li>
<li>可以创建到单个VPC的多个VPN连接，并且可以配置第二个CGW以创建到同一外部位置的冗余连接或创建到多个地理位置的VPN连接<h4 id="VPN-路由"><a href="#VPN-路由" class="headerlink" title="VPN 路由"></a>VPN 路由</h4></li>
</ul>
<ul>
<li>对于VPN连接，应使用的路由类型（动态或静态）更新子网的路由表</li>
<li>路由表确定网络流量的定向。 发往VPN连接的流量必须经过到虚拟专用网关</li>
<li>路由的类型（VPN的设备和型号）<ul>
<li>静态路由<ul>
<li>如果设备不支持BGP，请指定静态路由。</li>
<li>使用静态路由，可以指定应传送到虚拟专用网关的路由（IP前缀）。</li>
<li>不支持BGP的设备也可以执行运行状况检查，以帮助在需要时故障转移到第二个隧道。</li>
</ul>
</li>
</ul>
</li>
<li>BGP动态路由<ul>
<li>如果VPN设备支持边界网关协议（BGP），请使用VPN连接指定动态路由。</li>
<li>使用BGP设备时，不需要为VPN连接指定静态路由，因为设备使用BGP进行自动发现并将其路由通告给虚拟专用网关。</li>
<li>建议使用支持BGP的设备，因为BGP协议提供强大的活动检测检查，如果第一个隧道出现故障，可以帮助故障转移到第二个VPN隧道</li>
<li>只有通过BGP通告或静态路由条目的虚拟专用网关已知的IP前缀才能从VPC接收流量。</li>
<li>VGW不会路由发布在BGP之外的任何其他流量，静态路由条目或其附加的VPC CIDR<h4 id="VPN-Connection-Redundancy"><a href="#VPN-Connection-Redundancy" class="headerlink" title="VPN Connection Redundancy"></a>VPN Connection Redundancy</h4><img src="https://i.loli.net/2019/08/10/yAYVsuhQUOBLtNv.png" alt="VPN-Connection-Redundancy.png"></li>
</ul>
</li>
<li>每个VPN连接都有两个隧道，以防止VGW成为单点故障，每个隧道使用唯一的虚拟专用网关公共IP地址</li>
<li>当一个隧道变得不可用时，例如为了维护，网络流量会自动路由到特定VPN连接的可用隧道</li>
<li>为防止在客户网关不可用时丢失连接，建议使用第二个客户网关为VPC和虚拟专用网关建立第二个VPN连接</li>
<li>建议使用边界网关协议（BGP）动态路由VPN连接，以在客户网关和虚拟专用网关之间交换路由信息</li>
<li>静态路由的VPN连接需要在客户网关侧输入网络的静态路由。</li>
<li>BGP通告和静态输入的路由信息允许双方的网关确定哪些隧道可用，并在发生故障时重新路由流量<h3 id="VPN-CloudHub"><a href="#VPN-CloudHub" class="headerlink" title="VPN CloudHub"></a>VPN CloudHub</h3></li>
<li>VPN CloudHub可用于在多站点之间提供多个VPN通道安全通信</li>
<li>远程站点彼此进行通信，而不只是与 VPC 进行通信</li>
<li>VPN CloudHub 在简单的星型拓扑连接模型上操作，可以在使用或不使用 VPC 的情况下操作 VPN CloudHub。</li>
<li>这种设计适合有多间分公司和现有 Internet 连接的客户，帮助他们实施方便、潜在低成本的星型拓扑连接模型，以便在这些远程办公室之间建立主要或备用连接<br><img src="https://i.loli.net/2019/08/10/4rd7DFAWt1SvoZe.png" alt="AWS_VPN_CloudHub-diagram.png"></li>
<li>蓝色虚线表示网络远程站点之间的流量通过其VPN连接进行路由的流量通道</li>
<li>使用 AWS VPN CloudHub，必须创建具有多个客户网关的虚拟专用网关</li>
<li>每个CGW使用唯一的边界网关协议 (BGP) 自治系统编号 (ASN)</li>
<li>客户网关可通过它们的 Site-to-Site VPN 连接传播适当的路由（BGP 前缀）</li>
<li>路由通告会被每个 BGP 对等体接收并重新通告，使每个站点都可以向其他站点发送或接受数据</li>
<li>每个辐射路由必须具有唯一的ASN，并且站点不得具有重叠的IP范围</li>
<li>每个站点还可以发送和从 VPC 接收数据（与使用标准 Site-to-Site VPN 连接的方式相同）</li>
<li>使用AWS Direct Connect连接到虚拟专用网关的站点也可以是AWS VPN CloudHub的一部分</li>
<li>配置VPN CloudHub VPN<ol>
<li>创建多个客户网关，每个网关都具有网关和ASN的唯一公共IP地址</li>
<li>每个CGW到公共虚拟专用网（VGW）关创建VPN连接</li>
<li>每个VPN连接必须通告其特定的BGP路由。 VPN连接的VPN配置文件来完成<h2 id="NAT网关-vs-NAT实例"><a href="#NAT网关-vs-NAT实例" class="headerlink" title="NAT网关 vs NAT实例"></a>NAT网关 vs NAT实例</h2></li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>NAT网关</th>
<th>NAT实例</th>
</tr>
</thead>
<tbody><tr>
<td>可用性</td>
<td>高度可用。每个可用区中的 NAT 网关都采用冗余实施。在每个可用区中创建一个 NAT 网关可确保架构不依赖于可用区</td>
<td>使用脚本管理实例之间的故障转移</td>
</tr>
<tr>
<td></td>
<td>NAT网关</td>
<td>NAT实例</td>
</tr>
<tr>
<td>————-</td>
<td>————-</td>
<td>——</td>
</tr>
<tr>
<td>可用性</td>
<td>高度可用。每个可用区中的 NAT 网关都采用冗余实施。在每个可用区中创建一个 NAT 网关可确保架构不依赖于可用区</td>
<td>使用脚本管理实例之间的故障转移</td>
</tr>
<tr>
<td>带宽</td>
<td>可以扩展到 45 Gbps</td>
<td>取决于实例类型的带宽</td>
</tr>
<tr>
<td>维护</td>
<td>由 AWS 管理。不需要进行任何维护</td>
<td>自行管理，例如需要对实例安装软件更新或操作系统补丁</td>
</tr>
<tr>
<td>性能</td>
<td>软件经过优化以便处理 NAT 流量</td>
<td>由配置来执行 NAT 的通用 AMI</td>
</tr>
<tr>
<td>费用</td>
<td>费用取决于使用的 NAT 网关的数量、使用时长以及通过 NAT 网关发送的数据量</td>
<td>费用取决于使用的 NAT 实例的数量、使用时长以及实例类型和大小</td>
</tr>
<tr>
<td>类型和大小</td>
<td>整合提供；不需要选择类型或范围</td>
<td>根据的预测工作负载选择适当的实例类型和大小</td>
</tr>
<tr>
<td>公有IP地址</td>
<td>在创建时选择弹性 IP 地址以与 NAT 网关关联</td>
<td>为 NAT 实例使用弹性 IP 地址或公有 IP 地址。随时可以通过将新的弹性 IP 地址与实例关联来更改公有 IP 地址</td>
</tr>
<tr>
<td>私有IP地址</td>
<td>在创建网关时自动从子网的 IP 地址范围中选择。</td>
<td>在启动实例时，从子网的 IP 地址范围内分配特定的私有 IP 地址</td>
</tr>
<tr>
<td>安全组</td>
<td>无法与 NAT 网关关联。可以将安全组与 NAT 网关之后的资源关联，以控制入站和出站流量。</td>
<td>与NAT 实例和 NAT 实例之后的资源关联，以控制入站和出站流量。</td>
</tr>
<tr>
<td>网络 ACL</td>
<td>使用网络 ACL 控制进出NAT 网关所在子网的流量</td>
<td>使用网络 ACL 控制进出 NAT 实例所在子网的流量</td>
</tr>
<tr>
<td>流日志</td>
<td>使用流日志捕获流量。</td>
<td>使用流日志捕获流量</td>
</tr>
<tr>
<td>端口转发</td>
<td>不支持</td>
<td>手动自定义配置以支持端口转发</td>
</tr>
<tr>
<td>堡垒服务器</td>
<td>不支持</td>
<td>用作堡垒服务器</td>
</tr>
<tr>
<td>流量指标</td>
<td><a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/vpc-nat-gateway-cloudwatch.html" target="_blank" rel="noopener">查看 NAT 网关的 CloudWatch 指标</a></td>
<td>查看实例的 CloudWatch 指标</td>
</tr>
<tr>
<td>超时行为</td>
<td>如果连接超时，NAT 网关向 NAT 网关后方的任何资源返回 RST 数据包，尝试继续进行连接 (它不发送 FIN 数据包)。</td>
<td>如果连接超时，NAT 实例向 NAT 实例后方的资源发送 FIN 数据包，以关闭连接</td>
</tr>
<tr>
<td>IP 分段</td>
<td>支持转发 UDP 协议的 IP 分段数据包。不支持 TCP 和 ICMP 协议的分段。将删除这些协议的分段数据包。</td>
<td>支持重组 UDP、TCP 和 ICMP 协议的 IP 分段数据包。</td>
</tr>
</tbody></table>
<h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><ol>
<li><a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/amazon-vpc-limits.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/amazon-vpc-limits.html</a></li>
<li>Amazon Virtual Private Cloud user guide </li>
<li>AWS Site-to-Site VPN user guide</li>
</ol>



</font>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">seven</p>
              <p class="site-description motion-element" itemprop="description">seven 的精神家园，学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="1988xuegang@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">seven</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




<!-- 新增访客统计代码 -->

<div class="busuanzi-count">
    <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户： <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数： <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
    <!-- 博客字数统计 -->
    <span class="site-pv">
      <i class="fa fa-pencil"></i>
      博客全站共： <span class="post-count"></span> 字
    </span>
</div>
<!-- 新增访客统计代码 END-->


<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("07/21/2018 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
setInterval("createtime()",250);
</script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
