<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="seven 的精神家园，学习笔记">
<meta name="keywords" content="云计算,大数据，kuberntes">
<meta property="og:type" content="website">
<meta property="og:title" content="岳阳北寒">
<meta property="og:url" content="http://sevengarden.club/index.html">
<meta property="og:site_name" content="岳阳北寒">
<meta property="og:description" content="seven 的精神家园，学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="岳阳北寒">
<meta name="twitter:description" content="seven 的精神家园，学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sevengarden.club/">





  <title>岳阳北寒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">岳阳北寒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">要有最朴素的生活和最遥远的梦想，即使明日天寒地冻，路远马亡.......</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-somrthing">
          <a href="/有料" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            somrthing
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/09/24/RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/24/RabbitMQ/" itemprop="url">RabbitMQ</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-24T18:50:49+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/消息队列/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息中间件功能"><a href="#消息中间件功能" class="headerlink" title="消息中间件功能"></a>消息中间件功能</h2><ul>
<li><strong>解耦</strong>:消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层， 两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程， 只要确保它们遵守同样的接口约束即可</li>
<li><strong>异步</strong>：消息中间件提供了异步处理机制， 允许应用把一些消息放入消息中间件中， 但并不立即处理它， 在之后需要的时候再慢慢处理。</li>
<li><strong>削峰</strong>：使用消息中间件能够使关键组件支撑突发访问压力， 不会因为突发的超负荷请求而完全崩溃<br><img src="https://i.loli.net/2019/09/23/lU6HvuaJkRpNxnW.png" alt="Snipaste_2019-09-23_15-11-53.png"></li>
</ul>
<h3 id="RabbitMQ服务端口"><a href="#RabbitMQ服务端口" class="headerlink" title="RabbitMQ服务端口"></a>RabbitMQ服务端口</h3><blockquote>
<p>RabbitMQ 是一个实现AMQP协议的消息中间件服务，采用Erlang语言进行编写。</p>
<ul>
<li>4369：epmd,负责维护RabbitMQ集群内的节点连接</li>
<li>5672：client端通信端口</li>
<li>15672：RabbitMQmanagement web ui 管理口</li>
<li>25672： RabbitMQ集群内节点通信端口</li>
</ul>
</blockquote>
<h3 id="RabbitMQ基本操作"><a href="#RabbitMQ基本操作" class="headerlink" title="RabbitMQ基本操作"></a>RabbitMQ基本操作</h3><ol>
<li>创建Queue</li>
<li>创建exchange</li>
<li>创建binding</li>
<li>发送msg</li>
<li>接收msg</li>
</ol>
<p><img src="https://i.loli.net/2019/09/23/AJNarVCmTRXhWdP.png" alt="Snipaste_2019-09-23_15-15-55.png"></p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ul>
<li>Exchange： 消息交换机，它指定消息按什么规则，路由到那个队列<ul>
<li>Direct：Bingding key和Routing key必须完全一致，不支持通配符</li>
<li>Topic：同Direct类型，但支持通配符。</li>
<li>Fanout：忽略binding key和routing key，消息会被传送到所有绑定的队列上</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/09/23/a4iC5t1eWPOInlT.png" alt="Snipaste_2019-09-23_15-18-30.png"></p>
<ul>
<li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列</li>
<li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li>
<li>Routing key：路由关键字，exchange根据这个关键字进行消息投递</li>
</ul>
<h4 id="Exchange-Delclare参数"><a href="#Exchange-Delclare参数" class="headerlink" title="Exchange Delclare参数"></a>Exchange Delclare参数</h4><hr>
<p><code>def exchange_declare(self, exchange, type, passive=False, durable=False,
auto_delete=True, nowait=False, arguments=None,
argsig=&#39;BssbbbbbF&#39;)</code></p>
<hr>
<ul>
<li>exchange: 交换器的名称。</li>
<li>type: 交换器的类型，常见的如fanout, direct 和topic</li>
<li>passive: passive设置为true用于检测相应的交换器是否存在。 如果存在则正常返回；否则RabbitMQ抛出异常:404 (not found)。</li>
<li>durable: 设置是否持久化。 durable设置为true 表示持久化。</li>
<li>auto_delete: 设置是否自动删除。 auto_delete 设置为true 则表示自动删除。 自动删除的前提是至少有一个队列或<br>者交换器与这个交换器绑定， 之后所有与这个交换器绑定的队列或者交换器都与此解绑。</li>
<li>nowait: 声明Exchange时，不需要RabbitMQ返回任何信息。在声明完一个交换器之后(实际服务器还并未完成交<br>换器的创建) ， 那么此时客户端紧接着使用这个交换器，必然会发生异常。</li>
<li>argument: 其他一些结构化参数，比如alternate-exchange</li>
</ul>
<h4 id="Queue-Declare参数"><a href="#Queue-Declare参数" class="headerlink" title="Queue Declare参数"></a>Queue Declare参数</h4><hr>
<p><code>def queue_declare(self, queue=&#39;&#39;, passive=False, durable=False,
exclusive=False, auto_delete=True, nowait=False,
arguments=None, argsig=&#39;BsbbbbbF&#39;)</code></p>
<hr>
<ul>
<li>queue: 队列的名称。</li>
<li>passive:同exchange_declare的passive参数含义。</li>
<li>durable: 设置是否持久化。 durable设置为true 表示持久化。</li>
<li>exclusive:设置是否排他。为true 则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声<br>明它的连接可见，并在连接断开时自动删除。</li>
<li>auto_delete: 设置是否自动删除。为true则设置队列为自动删除。自动删除的前提是:至少有一个消费者连接到<br>这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。</li>
<li>nowait: 同exchange_declare的nowait参数含义。</li>
<li>argument: 设置队列的其他一些参数，如x-message-ttl, x-expires, x-dead-letter-exchange, x-dead-letterrouting-key, x-max-priority 等。</li>
</ul>
<h4 id="Bing-参数"><a href="#Bing-参数" class="headerlink" title="Bing 参数"></a>Bing 参数</h4><hr>
<p><code>def queue_bind(self, queue, exchange=&#39;&#39;, routing_key=&#39;&#39;,
nowait=False, arguments=None, argsig=&#39;BsssbF&#39;)</code></p>
<hr>
<ul>
<li>queue: 队列名称。</li>
<li>exchange: 交换器名称。</li>
<li>routing_key: 用来绑定队列和交换器的路由键</li>
</ul>
<hr>
<p><code>def exchange_bind(self, destination, source=&#39;&#39;, routing_key=&#39;&#39;,
nowait=False, arguments=None, argsig=&#39;BsssbF&#39;)</code></p>
<hr>
<ul>
<li>destination: 目的交换器名称。</li>
<li>source: 源交换器名称。</li>
<li>routing_key: 用来绑定源交换器和目的交换器的路由键</li>
</ul>
<h3 id="消息可靠传输"><a href="#消息可靠传输" class="headerlink" title="消息可靠传输"></a>消息可靠传输</h3><ul>
<li><p>生产者确认</p>
<ul>
<li>通过事务机制实现</li>
<li>通过发送方确认机制实现</li>
</ul>
</li>
<li><p>生产者保证——保证消息从Producer传输到Rabbit Broker</p>
<ul>
<li>Mandatory参数</li>
<li>Alternate Exchange（备份交换器）</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/09/23/GiHuMJOfmkUev1z.png" alt="Snipaste_2019-09-23_17-29-14.png"></p>
<ul>
<li>设置mandatory参数，在生成者业务侧需增加监听回调函数，增加了生成者的复杂度。如果不想消息丢失，可以使用Alternate Exchange。这样可以将未被路由的消息存储在RabbitMQ中，再在需要的时候去处理这些消息。</li>
<li>Alternate Exchange和mandatory参数同时使用，那么mandatory参数无效。</li>
</ul>
<p><img src="https://i.loli.net/2019/09/23/BgWoebCmMHvYV7U.png" alt="Snipaste_2019-09-23_17-26-57.png"></p>
<p>事务机制和publisher confirm机制确保的是消息能够正确的发送至RabbitMQ的Exchange，如果Exchange没有匹配的Queue，那么消息也会丢失。所以发送方需要配合mandatory参数或者Alternate Exchange一起使用来提高消息传输的可靠性</p>
<ul>
<li><p>Broker保证——保证消息在RabbitMQ Broker不丢失</p>
<ul>
<li>Exchange持久化——声明交换器时将durable参数设置为true</li>
<li>Queue持久化——声明队列将durable参数设置为true</li>
<li>消息持久化——将消息的投递模式（delivery_mode）设置为2来实现消息的持久化<blockquote>
<p>单单只设置队列持久化，重启之后消息会丢失;单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。<br>单单设置消息持久化而不设置队列的持久化显得毫无意义。<br>虽然RabbitMQ的entities持久化可以保证消息的可靠性，但是会影响RabbitMQ的吞吐量。因此在选择是否要将<br>消息持久化时，需要在可靠性和吞吐量之间做一个权衡</p>
</blockquote>
</li>
</ul>
</li>
<li><p>消费者保证——保证消息从RabbitMQ传输到Consumer</p>
<ul>
<li>消费者确认——消费者在订阅队列时，设置no_ack参数<br>——————————<br><code>def basic_consume(self, queue=&#39;&#39;, consumer_tag=&#39;&#39;, no_local=False,no_ack=False, exclusive=False,nowait=False,callback=None, arguments=None, on_cancel=None,argsig=&#39;BssbbbbF&#39;)</code><br>———————————</li>
</ul>
</li>
<li><p>当no_ack为false时， RabbitMQ会等待消费者显式的回复确认信号后才从内存(或者磁盘)中移去消息。</p>
</li>
<li><p>当no_ack为true时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存(或者磁盘)中删除，而不管消<br>费者是否真正地消费到了这些消息。</p>
</li>
<li><p>采用消息确认机制后，只要设置no_ack参数为false，消费者就有足够的时间处理消息(任务) ，不用担心处理<br>消息过程中消费者进程挂掉后消息丢失的问题， 因为RabbitMQ 会一直等待持有消息直到消费者显式调用<br>Basic.Ack 命令为止。即调用如下函数:<br>————————————<br><code>def basic_ack(self, delivery_tag, multiple=False, argsig=&#39;Lb&#39;)</code><br>——————————</p>
</li>
</ul>
<h2 id="RabbitMQ-传输机制和幂等性"><a href="#RabbitMQ-传输机制和幂等性" class="headerlink" title="RabbitMQ 传输机制和幂等性"></a>RabbitMQ 传输机制和幂等性</h2><h3 id="消息的传输机制"><a href="#消息的传输机制" class="headerlink" title="消息的传输机制"></a>消息的传输机制</h3><ul>
<li>At most once:最多一次。消息可能会丢失，但绝对不会重传</li>
<li>At least once：最少一次。消息绝并不会丢失，但可能重传</li>
<li>Exactly once:恰好一次。每条消息只被传输一次并且只传输一次</li>
<li>RabbitMQ支持其中的“最多一次”和“最少一次”</li>
</ul>
<h3 id="消息的幂等性"><a href="#消息的幂等性" class="headerlink" title="消息的幂等性"></a>消息的幂等性</h3><ul>
<li>用户对同一操作发起的一个或多次请求的结果都是一样的</li>
<li>RabbitMQ并不能保证消息的幂等性。需要业务方通过解决消息的重复问题来保证幂等性操作</li>
</ul>
<h2 id="RabbitMQ过期时间（TTL）"><a href="#RabbitMQ过期时间（TTL）" class="headerlink" title="RabbitMQ过期时间（TTL）"></a>RabbitMQ过期时间（TTL）</h2><h3 id="设置消息的TTL"><a href="#设置消息的TTL" class="headerlink" title="设置消息的TTL"></a>设置消息的TTL</h3><ul>
<li>通过队列属性设置，队列中所有消息都有相同的过期时间。 (x-message-ttl)</li>
<li>对消息本身进行单独设置，每条消息的TTL 可以不同。 (expiration)</li>
<li>如果两种方法一起使用，则消息的TTL 以两者之间较小的那个数值为准</li>
</ul>
<h3 id="设置队列的TTL（x-peries）"><a href="#设置队列的TTL（x-peries）" class="headerlink" title="设置队列的TTL（x-peries）"></a>设置队列的TTL（x-peries）</h3><ul>
<li>队列的TTL表示队列被自动删除前处于未使用状态的时间</li>
</ul>
<h2 id="RabbitMQ-消息顺序性"><a href="#RabbitMQ-消息顺序性" class="headerlink" title="RabbitMQ 消息顺序性"></a>RabbitMQ 消息顺序性</h2><ul>
<li>消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。举个例子，不考虑消息重复的<br>情况，如果生产者发布的消息分别为msgl、 msg2 、 msg3 ，那么消费者必然也是按照msgl 、 msg2 、msg3 的顺序进行消费的</li>
<li>RabbitMQ并不能保证消息的顺序性，除非只有一个生产者和一个消息者的情况</li>
<li>如果要保证消息的顺序性， 需要<strong>业务方</strong>使用RabbitMQ 之后做进一步的处理，比如在消息体内添加全局有序<br>标识(类似SequenceID) 来实现</li>
</ul>
<h3 id="RabbitMQ-消息分发"><a href="#RabbitMQ-消息分发" class="headerlink" title="RabbitMQ 消息分发"></a>RabbitMQ 消息分发</h3><ul>
<li>Round-Robin分发（默认消息分发方式）</li>
<li>Fair分发（调用channel.basic_qos函数进行设置）</li>
</ul>
<h2 id="RabbitMQ使用实例"><a href="#RabbitMQ使用实例" class="headerlink" title="RabbitMQ使用实例"></a>RabbitMQ使用实例</h2><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p><img src="https://i.loli.net/2019/09/24/T5dc3xC1qXbaZ2n.png" alt="Snipaste_2019-09-24_09-15-15.png"></p>
<ul>
<li>RabbitMQ的延迟队列/重试队列可以采用设置消息的TTL+DLX(Dead-Letter-Exchange)来实现。</li>
<li>当消息在一个队列中变成死信后， 它能被重新被发送到另一个交换器中， 这个交换器就是DLX，绑定DLX的<br>队列就称之为死信队列</li>
</ul>
<h3 id="重试队列"><a href="#重试队列" class="headerlink" title="重试队列"></a>重试队列</h3><p><img src="https://i.loli.net/2019/09/24/KtZJI3bVgrvLYPm.png" alt="Snipaste_2019-09-24_09-18-26.png"></p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><img src="https://i.loli.net/2019/09/24/lPjVXzr2OmxRUyY.png" alt="Snipaste_2019-09-24_09-19-09.png"></p>
<ul>
<li>上面的代码中设置队列的优先级为10。消息的优先级默认最低为0，最高为队列设置的最大优先级。对于超过优先级队列指定的最大优先级的消息，优先级以最大优先级对待。</li>
<li>这个也是有前提的: 如果在消费者的消费速度大于生产者的速度且Broker 中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</li>
</ul>
<h3 id="ROC实现"><a href="#ROC实现" class="headerlink" title="ROC实现"></a>ROC实现</h3><p><img src="https://i.loli.net/2019/09/24/EUHP4eGlQpTjzYi.png" alt="Snipaste_2019-09-24_09-21-00.png"></p>
<h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><ul>
<li>RabbitMQ集群节点没有leader和follower之分， 所有节点是平等的。</li>
<li>RabbitMQ集群的queue有master和slave之分(这是采用Mirror queue的场景。 如果没有配置Mirror queue，则queue所处的节点也可称为该queue的master节点)。</li>
<li>RabbitMQ集群正常情况下， 客户端能够连接到集群中的任何节点对queue做操作，所有的操作会被RabbitMQ route到queue的master节点。</li>
<li>如果关闭了集群中的所有节点， 则需要确保在启动的时候最后关闭的那个节点是第一个启动的。 如果第一个启动的不是最后关闭的节点， 那么这个节点会等待最后关闭的节点启动</li>
<li>如果RabbitMQ集群节点没有采用Mirror queue，则某个节点宕机，则该节点上非持久化的消息将丢失。</li>
<li>采用Mirror queue设置RabbitMQ集群后， 到达queue的master节点的消息会被分发到queue的每个slave节点，防止消息丢失，保证RabbitMQ的高可用。</li>
<li>若queue的master节点宕机， “资历最老” 的queue的slave节点将被提升为新的master节点</li>
</ul>
<h3 id="消息队列对比"><a href="#消息队列对比" class="headerlink" title="消息队列对比"></a>消息队列对比</h3><table>
<thead>
<tr>
<th align="center">****</th>
<th align="center"><strong>RabbitMQ</strong></th>
<th align="center"><strong>Kafka</strong></th>
<th align="center"><strong>RocketMQ</strong></th>
<th align="center"><strong>Pulsar</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">成熟度</td>
<td align="center">成熟</td>
<td align="center">成熟</td>
<td align="center">比较成熟</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">所属社区/公司</td>
<td align="center">Mozilla Public License</td>
<td align="center">Apache</td>
<td align="center">Ali</td>
<td align="center">Apache</td>
</tr>
<tr>
<td align="center">活跃度</td>
<td align="center">高</td>
<td align="center">高</td>
<td align="center">中</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">开发语言</td>
<td align="center">Erlang</td>
<td align="center">Scala&amp;Java</td>
<td align="center">Java</td>
<td align="center">Java</td>
</tr>
<tr>
<td align="center">客户端支持语言</td>
<td align="center">Java/python/go/C/C++/Erl ang等，几乎支持所有常用语言</td>
<td align="center">Java/python/go/C/ C++等</td>
<td align="center"></td>
<td align="center">ava/python/go/C/ C++/websocket</td>
</tr>
<tr>
<td align="center">数据可靠性</td>
<td align="center">可以保证数据不丢失，有slave做备份</td>
<td align="center">数据可靠，并且有 replica机制，有容错容 灾能力</td>
<td align="center">支持异步实时刷盘，同 步刷盘，同步复制，异 步复制。</td>
<td align="center">实时刷盘，按用户配置， quorum-vote的方式并 发写入多个存储节点</td>
</tr>
<tr>
<td align="center">单机吞吐量</td>
<td align="center">万级</td>
<td align="center">十万级</td>
<td align="center">十万级</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">消息延迟</td>
<td align="center">微秒级</td>
<td align="center">微秒级</td>
<td align="center">微秒级，比kafka快</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">HA</td>
<td align="center">Master/Slave模式， master 提供服务， Slave作备份</td>
<td align="center">支持replica机制， leader宕掉后，基于 zookeeper在备份节点中 重新选举新的leader</td>
<td align="center">多Master模式 多Master多Slave模 式—异步复制 多Master多Slave模 式—同步双写</td>
<td align="center">服务/存储分层架构，服 务层无状态。 无Master/Slave，服务 层broker宕机， topic的 owner会被自动转到其 他alive的broker。 存储层节点宕机，服务 层和client不受影响</td>
</tr>
<tr>
<td align="center">模式</td>
<td align="center">发布/订阅</td>
<td align="center">发布/订阅</td>
<td align="center">发布/订阅</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">消息持久性</td>
<td align="center">内存/硬盘</td>
<td align="center">硬盘</td>
<td align="center">硬盘</td>
<td align="center">硬盘</td>
</tr>
<tr>
<td align="center">消息推拉模式</td>
<td align="center">多协议，Pull/Push均支持</td>
<td align="center">Pull</td>
<td align="center">多协议，Pull/Push均支持</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">是否有序</td>
<td align="center">若想有序，只能使用一个client</td>
<td align="center">多client保证有序</td>
<td align="center">有序</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">消息批量操作</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">顺序投递</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">事务</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">集群</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center">负载均衡</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/09/19/实践操作札记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/实践操作札记/" itemprop="url">实践操作札记</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-19T19:01:47+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>更新ing</p>
</blockquote>
<h2 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h2><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><ol>
<li>简单路由策略–对于域执行功能给定功能的单一资源(例如为 example.com 网站提供内容的 Web 服务器)，可以使用该策略</li>
<li>故障转移路由策略– 如果想要配置主动-被动故障转移，则可以使用该策略</li>
<li>地理位置路由策略—如果想要根据用户的位置来路由流量，则可以使用该策略</li>
<li>地理位置林进度路由策略–用于更具资源的位置来路由通信，以及（可选）将流量从一个位置中的资源转移到另一个位置中的资源</li>
<li>延迟路由策略–如果资源位于多个AWS区域，并且想要将流量路由到提供给哦你最佳延迟的区域，则可以使用该策略</li>
<li>多值应答路由策略–想要让Route 53用随机选择的正常记录（最多八条）响应DNS查询，则可是用该策略</li>
<li>甲醛路由策略—用于按照指定的比例将流量路由到多个资源</li>
</ol>
<h3 id="记录集"><a href="#记录集" class="headerlink" title="记录集"></a>记录集</h3><ul>
<li>一个Record只能有一个alias target</li>
<li>加权路由：加权路由允许将多个资源关联至单个域名 (example.com) 或子域名 (acme.example.com)，并选择向每个资源路由多少流量。这可用于多种用途，例如负载均衡、测试软件新版本等。要配置加权路由，可以创建与每个资源同名、同类型的记录，然后根据要发送到每个资源的流量的规模为每条记录分配相对权重。Amazon Route 53 将根据分配给记录的权重 (占该组中所有记录总权重的比例) 向资源发送流量</li>
</ul>
<h3 id="R53运行状态检查类型"><a href="#R53运行状态检查类型" class="headerlink" title="R53运行状态检查类型"></a>R53运行状态检查类型</h3><ol>
<li>监控指端节点的运行状况检查：可以配置运行状况检查来监控通过 IP 地址或域名指定的终端节点。Route 53 按照指定的固定间隔，通过 Internet 向您的应用程序、服务器或其他资源自动提交请求，以验证其是否可到达、是否可用及功能是否正常。也可以通过配置运行状况检查来发出与用户发出的请求类似的请求，如从特定 URL 请求网页</li>
<li>监控其他运行状况检查的运行状况检查：可以创建运行状况检查，以监控 Route 53 是将其他运行状况检查视为运行状况良好还是不佳。在下面的情况下，这种运行状况检查可能很有用：您有多个执行相同功能的资源 (如多台 Web 服务器)，主要关注的是运行状况良好的资源数是否达到最少数目。您可以为每个资源创建运行状况检查，而不为这些运行状况检查配置通知。然后，可以创建一个运行状况检查，来监控其他运行状况检查的状态，并且仅在可用的 Web 资源数低于指定阈值时通知</li>
<li>监控CloudWatch报警的运行状况检查：可以创建用于监控 CloudWatch 指标状态的 CloudWatch 警报，这些指标包括 Amazon DynamoDB 数据库的受限读取事件数或被认为运行状况良好的 Elastic Load Balancing 主机数。在创建警报后，可以创建运行状况检查，使其监控与 CloudWatch 针对警报监控的数据流相同的数据流。为了提高复原能力和可用性，Route 53 不等待 CloudWatch 警报进入 ALARM 状态。运行状况检查的状态会根据数据流以及 CloudWatch 警报中的条件从运行状况良好更改为运行状况不佳</li>
</ol>
<h2 id="AutoScaling"><a href="#AutoScaling" class="headerlink" title="AutoScaling"></a>AutoScaling</h2><ul>
<li>启动配置创建后不可修改，只能创建新的启动配置与最新的映像关联，然后再修改 Auto Scaling Group 与新创建的启动配置关联。替换掉的启动配置不好管理。</li>
<li>启动模板的优势在于有版本的概念。可以在上一版的基础上，替换最新制作的映像生成启动模板的新版本。不需要再更新 Auto Scaling Group 的相关属性。通过版本这个概念也可以很好的管理历史的映像。</li>
</ul>
<h2 id="Cloudfront"><a href="#Cloudfront" class="headerlink" title="Cloudfront"></a>Cloudfront</h2><ul>
<li>当使用 https 协议访问网站时，CNAME 跳转会有 SSL 证书的问题</li>
<li>创建 CloudFront Distribution 时一定要添加 Alternate Domain Names (CNAMEs)，否则 CloudFront 会报错<ul>
<li>因为 CloudFront 服务的边缘站点使用的是一个资源共享的模式，所以在默认的情况下 Distribution 本身并没有独立的专属 IP 地址，而是共享同一群IP地址，因此需要通过 Host 标头去匹配请求和 Distribution 之间的关联</li>
</ul>
</li>
</ul>
<h2 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h2><ul>
<li>CloudWatch base：5分钟传输一次指标，不需要付费，这个是开通的默认选项</li>
<li>Cloudwatch detailed：1分钟传输一次指标，需要支付额外的费用</li>
</ul>
<h2 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h2><ul>
<li>EC2访问公网需要有公共IP或者EIP，同时需要IGW网关，并attach到实例所在的VPC，创建一个路由表 0.0.0.0/0 指向IGW，最后就是检查acl和安全组是否开放了相关端口允许流量出入</li>
<li>不建议创建IAM user或者IAM group 通过用户的授信信息保存到应用中调用资源。</li>
<li>建议通过为EC2创建 IAM role，将应用部署到EC2上，来获取访问AWS其他服务资源的权限。将角色的授信策略绑定到角色上。</li>
</ul>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><ul>
<li>read after write for new object是提供了一致性的存储；</li>
<li>只有改变了现有的对象，才有可能导致最终一致性的问题发生；</li>
<li>S3的跨region复制必须启动versioning</li>
</ul>
<h2 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h2><ul>
<li>Nat gateway 不能直接与vpc endpoints、vpn connections、AWS Direct Connect或者vpc peering connection进行流量互通，如果你的实例在private subnet中需要通过vpc endpoint、vpn、AWS Direct Connect连接，可以直接用private subnet的路由表直接路由到这设备上；</li>
<li>不能直接从NAT gateway上通过VPC PEER/VPN/DC进行路由。NAT GATEWAY不能被这些连接的另一端直接使用</li>
<li>Custom VPC不支持DNS HOSTNAME ENABLE,当你在这个VPC创建一个EC2的时候不会带private DNS name。你需要修改VPC的属性，设置dns hostname被设置为enable。</li>
<li>DNS resolution是一个解决DNS HOSTNAME在AWS内部生效的能力，是通过AWS的DNS server。感觉有点类似我们管理host表；</li>
<li>自动赋予public IP这个事情如果是在public subnet中可以在操作的时候设定。如果是在private subnet中创建EC2，默认是disabled的</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>流量控制：如果web server与db instance在一个VPC中，设置流量访问控制建议直接使用SecurityGroup；</li>
<li>NACL的使用场景：主要用于你想拒绝一个指定的IP访问或者一个CIDR 块的访问的时候</li>
<li>简单来说，只是流量控制，使用SecurityGroup，如果有拒绝某些IP和CIDR的场景，就配合上NACL来控制流量</li>
</ul>
<h2 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h2><ul>
<li>Multi-AZ deployments解决的是高可用问题；</li>
<li>跨region复制才是解决容灾问题；</li>
<li>RDS采用了不同的技术来支持高可用的failover机制<ul>
<li>采用AWS failover 技术的有：oracle、Postgre、mysql、mariadb</li>
<li>sqlserver使用的是mirroring技术</li>
<li>Aurora使用的是集群下的数据库复制技术</li>
</ul>
</li>
</ul>
<h2 id="elasticache"><a href="#elasticache" class="headerlink" title="elasticache"></a>elasticache</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul>
<li>描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</li>
<li>解决方案方案：<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
</ol>
</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul>
<li>描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是指缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</li>
<li>解决方案<ol>
<li>设置热点数据永远不过期</li>
<li>家户斥锁</li>
</ol>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul>
<li>描述:缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是,缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</li>
<li>解决方案：<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>设置热点数据永远不过期</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/09/08/AWS-IAM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/AWS-IAM/" itemprop="url">AWS IAM</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-08T15:42:35+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IAM-Overview"><a href="#IAM-Overview" class="headerlink" title="IAM Overview"></a>IAM Overview</h2><ul>
<li>AWS Identity and Access Management (IAM) 够安全地管理对 AWS 服务和资源的访问</li>
<li>IAM用于控制<ul>
<li><strong>Identity</strong> - 谁可以使用AWS资源（身份验证）</li>
<li><strong>Access</strong> - 他们可以使用哪些资源以及以何种方式（授权）</li>
</ul>
</li>
<li>IAM还可以将帐户凭据保密</li>
<li>使用IAM，可以在AWS账户的保护下创建多个IAM用户，也可以通过与AD身份联合来启用临时访问。或者第三方提供商<br>IAM</li>
<li>也允许跨AWS账户访问资源（中国区特殊）</li>
</ul>
<h2 id="IAM-功能"><a href="#IAM-功能" class="headerlink" title="IAM 功能"></a>IAM 功能</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/30/AWS-DynamoDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/30/AWS-DynamoDB/" itemprop="url">AWS DynamoDB</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-30T21:23:32+08:00">
                2019-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DynamoDB</p>
<ul>
<li>Amazon DynamoDB 是一种完全托管的 NoSQL 数据库服务，提供快速且可预测的性能，同时还能够实现无缝扩展</li>
<li>DynamoDB使客户能够将操作和扩展分布式数据库的管理负担卸载到AWS，而无需担心硬件配置，设置和配置，复制，软件修补或群集扩展。</li>
<li>DynamoDB表没有固定的模式，表由项组成，每个项可能具有不同数量的属性。</li>
<li>DynamoDB在AWS区域中的三个设施之间同步复制数据，从而提供高可用性和数据持久性。</li>
<li>DynamoDB支持快速就地更新。 可以使用单个API调用连续递增或递减数字属性</li>
<li>DynamoDB使用经过验证的加密方法来安全地验证用户身份并防止未经授权的数据访问</li>
<li>内置耐用性，性能，可靠性和安全性，具有SSD（固态驱动器）存储和自动3向复制。</li>
<li>DynamoDB吞吐量和单位数毫秒级延迟使其非常适合游戏，广告技术，移动和许多其他应用程序</li>
<li>ElastiCache可以在DynamoDB之前使用，以便为非频繁更改的数据卸载大量读取</li>
</ul>
<h2 id="DynamoDB-核心组件"><a href="#DynamoDB-核心组件" class="headerlink" title="DynamoDB 核心组件"></a>DynamoDB 核心组件</h2><ul>
<li>在 DynamoDB 中，表、项目和属性是使用的核心组件。表 是项目 的集合，而每个项目是属性 的集合。</li>
<li>DynamoDB 使用主键来唯一标识表中的每个项目，并且使用二级索引来提供更大的查询灵活性。</li>
<li>可以使用 DynamoDB 流 捕获 DynamoDB 表中的数据修改事件</li>
</ul>
<h3 id="表、项目和属性"><a href="#表、项目和属性" class="headerlink" title="表、项目和属性"></a>表、项目和属性</h3><ul>
<li>表 – 类似于其他数据库系统，DynamoDB 将数据存储在表中。表 是数据的集合。例如，请参阅名为 People 的示例表，该表可用于存储有关好友、家人或关注的任何其他人的个人联系信息。也可以建立一个 Cars 表，存储有关人们所驾驶的车辆的信息。</li>
<li>项目 – 每个表包含零个或更多个项目。项目 是一组属性，具有不同于所有其他项目的唯一标识。在 People 表中，每个项目表示一位人员。在 Cars 表中，每个项目代表一种车。DynamoDB 中的项目在很多方面都类似于其他数据库系统中的行、记录或元组。在 DynamoDB 中，对表中可存储的项目数没有限制。</li>
<li>属性 – 每个项目包含一个或多个属性。属性 是基础的数据元素，无需进一步分解。例如，People 表中的一个项目包含名为 PersonID、LastName、FirstName 等的属性。对于 Department 表，项目可能包含 DepartmentID、Name、Manager 等属性。DynamoDB 中的属性在很多方面都类似于其他数据库系统中的字段或列。</li>
</ul>
<p><img src="https://i.loli.net/2019/08/30/C9BSzdZ574DRbKr.png" alt="HowItWorksPeople.png"></p>
<ul>
<li>表中的每个项目都有一个唯一的标识符或主键，用于将项目与表中的所有其他内容区分开来。在 People 表中，主键包含一个属性 (PersonID)。</li>
<li>与主键不同，People 表是无架构的，这表示属性及其数据类型都不需要预先定义。每个项目都能拥有其自己的独特属性。</li>
<li>大多数属性是标量 类型的，这表示它们只能具有一个值。字符串和数字是标量的常见示例。</li>
<li>某些项目具有嵌套属性 (Address)。DynamoDB 支持最高 32 级深度的嵌套属性。<br><img src="https://i.loli.net/2019/08/30/GSYNeTnXLj5ECK6.png" alt="HowItWorksMusic.png"></li>
<li>Music 的主键包含两个属性（Artist 和 SongTitle）。表中的每个项目必须具有这两个属性。Artist 和 SongTitle 的属性组合用于将表中的每个项目与所有其他内容区分开来。</li>
<li>与主键不同，Music 表是无架构的，这表示属性及其数据类型都不需要预先定义。每个项目都能拥有其自己的独特属性。</li>
<li>其中一个项目具有嵌套属性 PromotionInfo，该属性包含其他嵌套属性。DynamoDB 支持最高 32 级深度的嵌套属性。</li>
</ul>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>DynamoDB 支持两种不同类型的主键：</p>
<ul>
<li><p>分区键 – 由一个名为 partition key 的属性构成的简单主键。</p>
<ul>
<li>DynamoDB 使用分区键的值作为内部散列函数的输入。来自散列函数的输出决定了项目将存储到的分区 (DynamoDB 内部的物理存储)。</li>
<li>在只有分区键的表中，任何两个项目都不能有相同的分区键值。</li>
<li>表、项目和属性 中所述的 People 表是带简单主键 (PersonID) 的示例表。可以直接访问 People 表中的任何项目，方法是提供该项目的 PersonId 值。</li>
</ul>
</li>
<li><p>分区键和排序键 – 称为复合主键，此类型的键由两个属性组成。第一个属性是分区键，第二个属性是排序键。</p>
<ul>
<li>DynamoDB 使用分区键值作为对内部散列函数的输入。来自散列函数的输出决定了项目将存储到的分区 (DynamoDB 内部的物理存储)。具有相同分区键值的所有项目按排序键值的排序顺序存储在一起。</li>
<li>在具有分区键和排序键的表中，两个项目可能具有相同的分区键值。但是，这两个项目必须具有不同的排序键值。</li>
<li>表、项目和属性中所述的 Music 表是包含一个复合主键（Artist 和 SongTitle）的表的示例。可以直接访问 Music 表中的任何项目，方法是提供该项目的 Artist 和 SongTitle 值。</li>
<li>在查询数据时，复合主键可让获得额外的灵活性。例如，如果仅提供了 Artist 的值，则 DynamoDB 将检索该艺术家的所有歌曲。要仅检索特定艺术家的一部分歌曲，可以提供一个 Artist 值和一系列 SongTitle 值。</li>
</ul>
</li>
<li><p>项目的分区键也称为其哈希属性。哈希属性 一词源自 DynamoDB 中使用的内部哈希函数，以基于数据项目的分区键值实现跨多个分区的数据项目平均分布。</p>
</li>
<li><p>项目的排序键也称为其范围属性。范围属性 一词源自 DynamoDB 存储项目的方式，它按照排序键值有序地将具有相同分区键的项目存储在互相紧邻的物理位置。</p>
</li>
<li><p>每个主键属性必须为标量 (表示它只能具有一个值)。主键属性唯一允许的数据类型是字符串、数字和二进制。对于其他非键属性没有任何此类限制。</p>
</li>
</ul>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><ul>
<li>DynamoDB 支持两种索引：<ul>
<li>Global secondary index – 一种带有可能与表中不同的分区键和排序键的索引。</li>
<li>本地二级索引 – 分区键与表中的相同但排序键与表中的不同的索引。</li>
</ul>
</li>
<li>DynamoDB 中的每个表具有 20 个全局二级索引（默认限制）和 5 个本地二级索引的限制。</li>
<li>在前面显示的示例 Music 表中，可以按 Artist（分区键）或按 Artist 和 SongTitle（分区键和排序键）查询数据项。如果还想要按 Genre 和 AlbumTitle 查询数据，该怎么办？ 若要达到此目的，可在 Genre 和 AlbumTitle 上创建一个索引，然后通过与查询 Music 表相同的方式查询索引。</li>
<li>下图显示了示例 Music 表，该表包含一个名为 GenreAlbumTitle 的新索引。在索引中，Genre 是分区键，AlbumTitle 是排序键。<br><img src="https://i.loli.net/2019/08/30/YkLegfJ5RuO6cI4.png" alt="HowItWorksGenreAlbumTitle.png"><ul>
<li>每个索引属于一个表（称为索引的基表）。在上述示例中，Music 是 GenreAlbumTitle 索引的基表。</li>
<li>DynamoDB 将自动维护索引。当添加、更新或删除基表中的某个项目时，DynamoDB 会添加、更新或删除属于该表的任何索引中的对应项目。</li>
<li>当创建索引时，可指定哪些属性将从基表复制或投影 到索引。DynamoDB 至少会将键属性从基表投影到索引中。对于 GenreAlbumTitle 也是如此，只不过此时只有 Music 表中的键属性会投影到索引中。</li>
<li>可以查询 GenreAlbumTitle 索引以查找某个特定流派的所有专辑（例如，所有 Rock 专辑）。还可以查询索引以查找特定流派中具有特定专辑名称的所有专辑（例如，名称以字母 H 开头的所有 Country 专辑）。</li>
</ul>
</li>
</ul>
<h2 id="DynamoDB-流"><a href="#DynamoDB-流" class="headerlink" title="DynamoDB 流"></a>DynamoDB 流</h2><ul>
<li>DynamoDB 流 是一项可选功能，用于捕获 DynamoDB 表中的数据修改事件。有关这些事件的数据将以事件发生的顺序近乎实时地出现在流中。</li>
<li>每个事件由一条流记录 表示。如果对表启用流，则每当以下事件之一发生时，DynamoDB 流 都会写入一条流记录：<ul>
<li>向表中添加了新项目：流将捕获整个项目的映像，包括其所有属性。</li>
<li>更新了项目：流将捕获项目中已修改的任何属性的“之前”和“之后”映像。</li>
<li>从表中删除了项目：流将在整个项目被删除前捕获其映像。</li>
</ul>
</li>
<li>每条流记录还包含表的名称、事件时间戳和其他元数据。流记录具有 24 个小时的生命周期；在此时间过后，它们将从流中自动删除。</li>
</ul>
<h2 id="DynamoDB-性能"><a href="#DynamoDB-性能" class="headerlink" title="DynamoDB 性能"></a>DynamoDB 性能</h2><ul>
<li>自动水平缩放</li>
<li>固态硬盘（SSD）上运行<ul>
<li>SSD有助于实现可预测的低延迟响应时间的设计目标，以便以任何规模存储和访问数据。</li>
<li>SSD高I / O性能使其能够经济高效地为大规模请求工作负载提供服务，并以低请求定价传递此效率</li>
</ul>
</li>
<li>允许配置读写速率<ul>
<li>按需扩大吞吐量</li>
<li>每个UTC日历可以缩减吞吐量</li>
</ul>
</li>
<li>自动分区，重新分配和重新分区数据，并提供额外的服务器容量<ul>
<li>随着表的增大</li>
<li>预配置吞吐量增加</li>
</ul>
</li>
<li>全局二级索引<ul>
<li>可以预先创建或稍后添加</li>
</ul>
</li>
</ul>
<h2 id="DynamDB-一致性"><a href="#DynamDB-一致性" class="headerlink" title="DynamDB 一致性"></a>DynamDB 一致性</h2><ul>
<li>每个DynamoDB表自动存储在三个分散的地理位置，以确保数据一致性；</li>
<li>读取一致性表示在同一项的后续读取操作中反映数据项的成功写入或更新的方式和时间</li>
<li>DynamoDB 支持最终一致性 和强一致性 读取。<ul>
<li>最终一致性读取<ul>
<li>最终一致性选项可最大化读取吞吐量。</li>
<li>所有副本的一致性通常在一秒钟内达到</li>
<li>但是，最终一致的读取可能不会反映最近完成的写入的结果。</li>
<li>短时间后重复读取应返回更新的数据。 </li>
</ul>
</li>
<li>强一致性读取<ul>
<li>强一致性读取返回的结果反映了在读取之前收到成功响应的所有写入</li>
</ul>
</li>
</ul>
</li>
<li>Query，GetItem和BatchGetItem操作默认执行最终一致的读取<ul>
<li>Query和GetItem操作可以强制一致</li>
<li>查询操作无法对全局二级索引执行强一致性读取</li>
<li>可以强制BatchGetItem操作在每个表的基础上强一致</li>
</ul>
</li>
</ul>
<h2 id="DynamoDB-安全"><a href="#DynamoDB-安全" class="headerlink" title="DynamoDB 安全"></a>DynamoDB 安全</h2><ul>
<li>细粒度访问控制（FGAC）可以高度控制表中的数据</li>
<li>FGAC帮助控制谁（调用者）可以访问表的哪些项或属性并执行哪些操作（读/写功能）</li>
<li>FGAC与IAM集成，后者管理安全凭证和相关权限</li>
</ul>
<h2 id="DynamoDB跨区域复制"><a href="#DynamoDB跨区域复制" class="headerlink" title="DynamoDB跨区域复制"></a>DynamoDB跨区域复制</h2><ul>
<li><p>DynamoDB跨区域复制允许在一个或多个AWS区域中维护DynamoDB表（称为主表）的相同副本（称为副本）</p>
</li>
<li><p>对表的写入将自动传播到所有副本</p>
</li>
<li><p>跨区域复制当前支持单主模式。单主具有一个主表和一个或多个副本表</p>
</li>
<li><p>读取副本将异步更新，因为一旦主表接受了写入操作，DynamoDB就会将写入操作确认为成功。然后，写入将稍微延迟地传播到每个副本</p>
</li>
<li><p>跨区域复制在一下场景中很有用</p>
<ul>
<li>如果发生数据中心故障，则进行快速灾难恢复</li>
<li>通过从最近的AWS数据中心读取DynamoDB表，更快地提供数据，从而更快地为多个地区的客户进行读取。</li>
<li>更轻松的流量管理，可以跨表分配读取工作负载，从而在主表中消耗更少的读取容量。</li>
<li>通过提升读取副本成主来轻松实现区域迁移</li>
<li>实时数据迁移，复制数据以及表同步时，切换应用程序以写入目标区域</li>
</ul>
</li>
<li><p>跨区域复制成本取决于</p>
<ul>
<li>预配置吞吐量（写入和读取）</li>
<li>存储副本表的大小</li>
<li>跨地区的数据传输</li>
<li>从DynamoDB Streams读取数据以使表保持同步</li>
<li>根据实例类型和区域配置EC2实例的成本，以承载复制过程。</li>
</ul>
<p>注意：已执行DynamoDB上的跨区域复制，定义AWS Data Pipeline作业，该作业在DynamoDB流和开箱即用跨区域复制支持之前在内部使用EMR传输数据</p>
<h2 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h2><ul>
<li>Amazon DynamoDB 全局表 为部署多区域、多主机数据库提供了完全托管的解决方案，而不必构建和维护自己的复制解决方案。</li>
<li>可支持数据访问位置和数据库工作负载的区域容错</li>
<li>应用程序现在可以在世界各地的AWS区域中对DynamoDB执行读取和写入操作，任何区域中的更改都会传播到复制表的每个区域</li>
<li>全局表有助于构建应用程序以利用数据局部性来减少总体延迟。</li>
<li>全局表确保最终的一致性</li>
<li>全局表在单个AWS账户内的区域之间复制数据，目前不支持跨账户访问</li>
</ul>
<h2 id="DynamoDB-Streams"><a href="#DynamoDB-Streams" class="headerlink" title="DynamoDB Streams"></a>DynamoDB Streams</h2><ul>
<li>AWS 为 DynamoDB 和 DynamoDB 流 维护单独的终端节点。要使用数据库表和索引，应用程序需要访问 DynamoDB 终端节点。要读取和处理 DynamoDB 流 记录，应用程序需要访问相同区域内的 DynamoDB 流 终端节点</li>
<li>DynamoDB Streams提供按时间排序的项目级更改序列，在过去24小时内对表中的数据进行更改，之后将其删除</li>
<li>DynamoDB Streams维护每个项目的有序事件序列，但不维护项目例</li>
<li>例如，假设有一个DynamoDB表跟踪游戏的高分，并且表中的每个项目代表一个单独的玩家。如果按此顺序进行以下三次更新：  <ul>
<li>更新1：将玩家1的高分改为100分  </li>
<li>更新2：将玩家2的高分改为50分</li>
<li>更新3：将玩家1的高分改为125分</li>
<li>DynamoDB Streams将维护Player 1得分事件的顺序。但是，它不会维持玩家之间的秩序。因此，在2个玩家1事件之间无法保证玩家2得分事件</li>
</ul>
</li>
<li>DynamoDB 流 确保以下内容：<ul>
<li>每个流记录仅在流中显示一次。</li>
<li>对于 DynamoDB 表中修改的每个项目，流记录将按照对该项目进行的实际修改的顺序显示</li>
</ul>
</li>
<li>DynamoDB流可用于多区域复制，以使其他数据存储与DynamoDB的最新更改保持同步，或根据对表所做的更改执行操作</li>
<li>DynamoDB Streams API可帮助开发人员在更改项目之前和之后使用更新并接收项目级数据 </li>
<li>DynamoDB Streams允许读取速度高达DynamoDB表的预配置写入容量的两倍</li>
<li>必须基于每个表启用DynamoDB Streams</li>
</ul>
<h2 id="DynamoDB-触发器"><a href="#DynamoDB-触发器" class="headerlink" title="DynamoDB 触发器"></a>DynamoDB 触发器</h2><ul>
<li>DynamoDB触发器（就像数据库trigger）是一种允许基于表上的项级更新执行自定义操作的功能</li>
<li>DynamoDB触发器可用于发送通知，更新聚合表以及将DynamoDB表连接到其他数据源等方案</li>
<li>DynamoDB触发器流程<ul>
<li>DynamoDB触发器的自定义逻辑作为代码存储在AWS Lambda函数中。</li>
<li>可以通过将AWS Lambda函数与表上的流（通过DynamoDB Streams）相关联来创建给定表的触发器。</li>
<li>更新表后，更新将发布到DynamoDB Streams。</li>
<li>反过来，AWS Lambda从关联的流中读取更新并执行函数中的代码。</li>
</ul>
</li>
</ul>
<h2 id="DynamoDB-Accelerator-DAX"><a href="#DynamoDB-Accelerator-DAX" class="headerlink" title="DynamoDB Accelerator DAX"></a>DynamoDB Accelerator DAX</h2><ul>
<li>DynamoDB Accelerator（DAX）是DynamoDB的完全托管，高可用性内存缓存，可提供高达10倍的性能提升 - 从毫秒到微秒 - 甚至可达到每秒数百万个请求。</li>
<li>DAX完成了向表中添加内存加速所需的所有繁重工作，而无需开发人员管理缓存失效，数据填充或集群管理。</li>
<li>DAX具有容错性和可扩展性。</li>
<li>DAX群集具有主节点和零个或多个读副本节点。 当主节点发生故障时，DAX将自动进行故障转移并选择新的主节点。 对于缩放，添加或删除只读副本</li>
</ul>
<h2 id="VPC端点"><a href="#VPC端点" class="headerlink" title="VPC端点"></a>VPC端点</h2><ul>
<li>DynamoDB的VPC端点通过在VPC内启用对DynamoDB的私有访问，而无需Internet网关或NAT网关，从而提高了隐私和安全性，尤其是那些处理具有合规性和审计要求的敏感工作负载的端点。</li>
<li>DynamoDB的VPC端点支持IAM策略以简化DynamoDB访问控制，其中访问可以限制为特定的VPC端点。</li>
<li>只能为与VPC位于同一AWS区域中的Amazon DynamoDB表创建VPC端点</li>
<li>无法使用DynamoDB的VPC端点访问DynamoDB Streams</li>
</ul>
<h2 id="DynamoDB-加密"><a href="#DynamoDB-加密" class="headerlink" title="DynamoDB 加密"></a>DynamoDB 加密</h2><ul>
<li>传输加密<ul>
<li>可以通过在客户端加密敏感数据或使用加密连接（TLS）来完成</li>
</ul>
</li>
<li>静态加密<ul>
<li>存储在 Amazon DynamoDB 中的所有用户数据完全处于静态加密之中</li>
<li>DynamoDB 静态加密通过在加密表中保护数据来提供额外的一层数据保护，包括其主键、本地和全局二级索引、流、全局表、备份和 DynamoDB Accelerator (DAX) 集群</li>
<li>静态加密与 AWS KMS 集成，以管理用于加密表的加密密钥。</li>
<li>只能为新表启用静态加密，而不能为现有表启用加密</li>
<li>一旦为表启用加密，就无法禁用</li>
<li>DynamoDB Streams不支持加密</li>
<li>使用S3的服务器端加密对加密的DynamoDB表的按需备份进行加密</li>
<li>静态加密使用256位AES加密对数据进行加密。</li>
</ul>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>使用的表的数量保持最小值</li>
<li>在DynamoDB中存储元数据，在Amazon S3中存储大型BLOB</li>
<li>使用每天，每周，每月等表来存储时间序列数据</li>
<li>使用条件或乐观并发控制（OCC）更新</li>
<li>乐观并发控制就像RDMS中的乐观锁定一样</li>
<li>OCC通常用于数据争用较少的环境，冲突很少，可以完成事务而无需管理锁和事务</li>
<li>OCC假设可以经常完成多个交易而不会相互干扰</li>
<li>使用数据资源执行事务，而不获取对这些资源的锁定并等待清除其他事务锁定</li>
<li>在提交事务之前，将验证数据是否被任何其他事务修改。如果是这样，它将被回滚并需要使用更新的数据重新启动</li>
<li>与其他并发控制方法（如悲观锁定）相比，OCC导致更高的吞吐量，因为即使在避免死锁时，锁定也会极大地限制有效并发性</li>
<li>避免热键和热分区</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/30/AWS-CloudFront/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/30/AWS-CloudFront/" itemprop="url">AWS CloudFront</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-30T19:44:53+08:00">
                2019-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CloudFront-overview"><a href="#CloudFront-overview" class="headerlink" title="CloudFront overview"></a>CloudFront overview</h2><ul>
<li>Amazon CloudFront 是一个 Web 服务，它加快将静态和动态 Web 内容（如 .html、.css、.js 和图像文件）分发到用户的速度</li>
<li>CloudFront 通过全球数据中心网络传输内容，这些数据中心称为边缘站点。当用户请求用 CloudFront 提供的内容时，用户被路由到提供最低延迟 (时间延迟) 的边缘站点，从而以尽可能最佳的性能传送内容</li>
<li>CloudFront通过将每个用户请求路由到最能为内容提供服务的边缘位置来加速内容的分发，从而提供最低的延迟</li>
<li>CloudFront可显着减少用户请求必须通过的网络跃点数，从而有助于提高性能，提供更低的延迟和更高的数据传输速率</li>
<li>CloudFront是分发经常访问的静态内容的最好选择，这些内容受益于边缘交付 - 如流行的网站图像，视频，媒体文件或软件下载</li>
</ul>
<h2 id="CloudFront-Benefits"><a href="#CloudFront-Benefits" class="headerlink" title="CloudFront Benefits"></a>CloudFront Benefits</h2><ul>
<li>CloudFront消除了在互联网上多个站点中进行缓存服务器网络的费用和复杂性，以及过度配置容量的需要，以便在潜在的流量爆发中也能提供服务</li>
<li>提供数据更高的可靠性和可用性，对象的副本保存在世界各地的边缘位置</li>
<li>CloudFront与源服务器保持持久连接，以便可以尽快从源服务器获取这些文件</li>
<li>在诸如多个用户同时在边缘位置同时获取相同源文件请求中，折叠请求次数，减少对源站点的负载</li>
<li>CloudFront与AWS WAF集成，后者一种web应用程序防火墙，允许通过基于IP地址，HTTP标头和自定义URL字符串配置的规则来保护web应用</li>
</ul>
<h2 id="Configuration-amp-Content-Delivery"><a href="#Configuration-amp-Content-Delivery" class="headerlink" title="Configuration &amp; Content Delivery"></a>Configuration &amp; Content Delivery</h2><ul>
<li>Configuration<ol>
<li>指定源服务器以获取要分发的文件。源服务器将存储对象的原始最终版本。如果通过 HTTP 提供内容，源服务器将为 Amazon S3 存储桶或 HTTP 服务器；使用 Adobe Media Server RTMP 协议按需分发媒体文件，则源服务器始终为 Amazon S3 存储桶</li>
<li>添加/上载到源服务器上的文件请使用公共读取权限或限制性OAI权限</li>
<li>创建一个 CloudFront 分配，在用户通过网站或应用程序请求文件时，这会指示 CloudFront 从哪些源服务器中获取文件</li>
<li>CloudFront 将分配的配置（而不是的内容）发送到它的所有边缘站点，边缘站点是位于地理位置分散的数据中心（CloudFront 在其中缓存对象的副本）的服务器集合</li>
<li>网站可与CloudFront提供的域名或自定义备用域名一起使用</li>
<li>Origin服务器可以配置为限制访问协议，缓存行为，向文件添加标头以添加TTL或到期时间</li>
</ol>
</li>
<li>Content delivery to users<ol>
<li>当用户访问网站时，DNS将请求路由指向到CloudFront边缘站点，该位置可以最低的延迟响应用户对网站文件或对象的访问</li>
<li>如果请求对象存在于edge 位置缓存中，则cloudfront会立即返回该对象</li>
<li>如果请求对象不在edge位置缓存中，则cloudfront会从origin服务器请求对象，并在它开始接收数据事就返回给用户</li>
<li>当对象到达其TTL值时，对于任何新请求，cloudfront会向origin服务器检查任何新版本，若有则更新，若没有则继续当前版本</li>
</ol>
</li>
</ul>
<h2 id="Delivery-Methods"><a href="#Delivery-Methods" class="headerlink" title="Delivery Methods"></a>Delivery Methods</h2><h3 id="Web-分发"><a href="#Web-分发" class="headerlink" title="Web 分发"></a>Web 分发</h3><ul>
<li>支持静态或动态内容，例如使用HTTP或HTTPS的html、css、js、图像等</li>
<li>多媒体内容支持HLS或渐进式下载使用<ul>
<li>对于按需流式传输，可以使用 CloudFront 以常见格式（如 MPEG DASH、Apple HLS、Microsoft 平滑流和 CMAF）将内容流式传输到任何设备。</li>
<li>对于广播实时流，可以在边缘站点缓存媒体片段，以便将按正确顺序传输片段的清单文件的多个请求组合起来，从而减小源服务器的负载</li>
</ul>
</li>
<li>只是实时活动内容，如会议、音乐会、演唱会等。对于实时数据流，可以使用AWS Cloudformation堆栈自动创建分发</li>
<li>源站可以是S3或HTTP服务器，如web server或ELB</li>
</ul>
<h3 id="RTMP分发"><a href="#RTMP分发" class="headerlink" title="RTMP分发"></a>RTMP分发</h3><ul>
<li>支持使用Adobe Media Server和Adobe实时消息传递协议（RTMP）传输媒体文件</li>
<li>必须使用S3作为源站</li>
<li>使用cloudfront流逝传输媒体文件，需要一下支持<ul>
<li>媒体文件</li>
<li>媒体播放器，JW Player，Flowplayer或Adobe Flash</li>
</ul>
</li>
<li>最终用户使用提供的媒体播放器查看媒体文件，而不是本地安装的播放器</li>
<li>用户使用流逝传输媒体文件时，一边播放一遍下载</li>
<li>媒体文件并不存放于本地存储系统上</li>
<li>需要创建两个cloudfront分配，媒体播放器的web分发和媒体文件的RMTP分发</li>
<li>媒体播放器和媒体文件可以存储在同一个源S3或不同bucket中</li>
</ul>
<h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><ul>
<li>源站可以是S3或者HTTP服务器</li>
<li>HTTP服务器作为源站，需要映射其资源的域名，且文件必须是公共可读的</li>
<li>对于使用S3 作为源站，使用bucket地址或静态网址端点地址，文件需要公开读取或OAI受限保护</li>
<li>可以使用Origin Access Identity配置源限制访问（仅限S3），以防止直接访问S3对象</li>
<li>每个存储同，支持分配多个源，并将其用户请求分配到不同的缓存规则上。缓存行为中的路径模式决定哪些请求路由到与缓存行为关联的源(S3 bucket)</li>
</ul>
<h2 id="Cache-behavior"><a href="#Cache-behavior" class="headerlink" title="Cache behavior"></a>Cache behavior</h2><p>缓存行为为网站上文件的特定 URL 路径模式配置各种 CloudFront 功能</p>
<ul>
<li>路径模式。</li>
<li>如果为 CloudFront 分配配置了多个源，希望 CloudFront 将的请求转发到哪个源。</li>
<li>是否将查询字符串转发到源。</li>
<li>是否访问指定文件需要签名 URL。</li>
<li>是否要求用户使用 HTTPS 访问那些文件。</li>
<li>那些文件保留在 CloudFront 缓存中的最小时间长度，不管源添加到文件中的任何 Cache-Control 标头的值。</li>
</ul>
<h2 id="Vuewer-Protocol-Policy"><a href="#Vuewer-Protocol-Policy" class="headerlink" title="Vuewer Protocol Policy"></a>Vuewer Protocol Policy</h2><blockquote>
<p>可以配置查看器协议策略以定义允许的访问协议。 可以是HTTP和HTTPS，也可以是仅HTTPS或HTTP重定向到HTTPS</p>
</blockquote>
<h3 id="HTTPS-connection"><a href="#HTTPS-connection" class="headerlink" title="HTTPS connection"></a>HTTPS connection</h3><ul>
<li>在CloudFront和Viewers之间，可以将缓存分发配置为允许HTTP或HTTPS请求，或仅使用HTTPS，或将所有HTTP请求重定向到HTTPS</li>
<li>在CloudFront和Origin之间，可以将缓存分布配置为要求CloudFront使用HTTPS从源中提取对象，或者CloudFront使用查看器用于请求对象的协议。</li>
<li>S3 作为源站<ul>
<li>对于网站，协议必须是HTTP，因为不支持HTTPS</li>
<li>对于S3存储桶，默认的Origin协议策略是Match Viewer，无法更改。 因此，当CloudFront配置为在查看器和CloudFront之间需要HTTPS时，它会自动使用HTTPS与S3通信。</li>
</ul>
</li>
<li>通过使用以下方法，还可以将CloudFront配置为使用HTTPS处理备用域名： <ul>
<li>使用专用IP地址提供HTTPS请求</li>
<li>CloudFront将备用域名与专用IP地址相关联，并且证书与IP地址关联。 当从DNS服务器收到IP地址的请求时，</li>
<li>CloudFront使用IP地址标识分发和SSL / TLS证书以返回给查看者</li>
<li>无论用户使用何种浏览器或其他查看器，此方法都适用于每个HTTPS请求。</li>
<li>使用专用IP地址会产生额外的每月费用</li>
</ul>
</li>
<li>使用SNI提供HTTPS请求<ul>
<li>SNI自定义SSL依赖于TLS协议的SNI扩展，它允许通过包含主机名在同一IP地址上提供多个域</li>
<li>使用SNI方法，CloudFront将IP地址与备用域名相关联，但IP地址不是专用的</li>
<li>CloudFront无法根据IP地址确定请求所针对的域，因为IP地址不是专用的 </li>
<li>支持SNI的浏览器会自动从请求URL获取域名，并将其添加到请求标头中的新字段。</li>
<li>当CloudFront从支持SNI的浏览器收到HTTPS请求时，它会在请求标头中找到域名，并使用适用的SSL / TLS证书响应该请求。</li>
<li>Viewer和CloudFront执行SSL协商，CloudFront将请求的内容返回给查看器。</li>
<li>较旧的浏览器不支持它</li>
<li>除标准CloudFront数据传输和请求费用外，SNI Custom SSL无需额外费用</li>
</ul>
</li>
<li>对于端到端HTTPS连接，需要在Viewers和CloudFront＆CloudFront和Origin之间应用证书，并满足以下要求<ul>
<li>查看者和CloudFront之间的HTTPS<ul>
<li>由受信任的证书颁发机构（CA）（如Comodo，DigiCert或Symantec）颁发的证书;</li>
<li>由AWS Certificate Manager（ACM）提供的证书;</li>
<li>自签名证书。</li>
<li>CloudFront与自定义源之间的HTTPS</li>
<li>如果源不是ELB负载平衡器，则证书必须由受信任的CA（如Comodo，DigiCert或Symantec）颁发。</li>
<li>对于ELB负载平衡器，可以使用ACM提供的证书</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="允许的HTTP-方法"><a href="#允许的HTTP-方法" class="headerlink" title="允许的HTTP 方法"></a>允许的HTTP 方法</h3><ul>
<li>CloudFront支持GET，HEAD，OPTIONS，PUT，POST，PATCH，DELETE来获取，添加，更新和删除对象，以及获取对象标头。</li>
<li>GET，HEAD，OPTIONS方法仅使用CloudFront获取对象，对象标题或检索从源支持的选项列表</li>
<li>POST，PUT操作也可以用于加速，例如PUT操作，从Web表单提交数据，这些数据直接代理回原始服务器</li>
<li>CloudFront仅缓存对GET和HEAD请求以及（可选）OPTIONS请求的响应。 CloudFront不会缓存对PUT，POST，PATCH，DELETE请求方法的响应，并且这些请求将定向到源</li>
<li>PUT，POST http方法也有助于加速内容上传，因为这些操作将被发送到源，例如S3通过CloudFront边缘位置，提高效率，减少延迟，并允许应用程序受益于CloudFront从边缘位置到源服务器维护的受监视的持久连接</li>
</ul>
<h3 id="优化缓存和可用性"><a href="#优化缓存和可用性" class="headerlink" title="优化缓存和可用性"></a>优化缓存和可用性</h3><ul>
<li>控制cache max-age<ul>
<li>要增加缓存命中率，可以将origin配置为向对象添加Cache-Control max-age指令。</li>
<li>间隔越长，从原点检索的频率越低</li>
</ul>
</li>
<li>针对查询字符串参数进行缓存<ul>
<li>对于Web分发，可以将CloudFront配置为基于查询参数进行缓存</li>
<li>缓存性能可以提高<ul>
<li>将CloudFront配置为仅转发源将返回唯一对象的查询字符串。</li>
<li>对于例如参数值使用相同的情况。 参数值A或a，即使返回的响应或对象相同，CloudFront也会将相同的请求缓存两次</li>
<li>使用相同的参数顺序，例如 对于请求a = x＆b = y和b = y＆a = x，即使返回的响应或对象相同，CloudFront也会缓存相同的请求两次</li>
<li>对于RTMP分发，当CloudFront从源服务器请求对象时，它会删除任何查询字符串参数。</li>
</ul>
</li>
</ul>
</li>
<li>基于Cookie值的缓存<ul>
<li>对于Web分发，可以将CloudFront配置为基于cookie值进行缓存。</li>
<li>默认情况下，它在边缘位置缓存时不考虑cookie</li>
<li>缓存性能可以通过以下提高<ul>
<li>将 CloudFront 配置为仅转发指定的 Cookie 而不是转发所有 Cookie。对于配置 CloudFront 以转发到源的 Cookie，CloudFront 转发 Cookie 名称和值的所有组合，并分别缓存源返回的对象，即使这些对象完全相同。例如，如果请求包含2个包含3个可能值的cookie，则即使响应考虑了单个cookie，CloudFront也会缓存所有可能的组合，Cookie名称和值都区分大小写，因此最好坚持使用相同的大小写<ul>
<li>为静态和动态内容创建单独的缓存行为，并将CloudFront配置为仅将Cookie转发到源，例如用于动态内容。对于css文件，cookie没有意义，因为对象不会随cookie值而改变</li>
</ul>
</li>
<li>如果可能，为动态内容创建单独的缓存行为，对于每个用户，cookie值是唯一的（例如用户ID），动态内容根据较少数量的唯一值而变化，从而减少组合的数量</li>
</ul>
</li>
<li>对于RTMP分发，无法配置CloudFront进行处理cookie<ul>
<li>当CloudFront从源服务器请求对象时，它会在将请求转发到源之前删除所有cookie。 如果源返回任何cookie以及对象CloudFront在将对象返回给查看器之前删除它们。</li>
</ul>
</li>
</ul>
</li>
<li>请求标头进行缓存<ul>
<li>默认情况下，CloudFront在边缘位置缓存对象时不考虑标头。</li>
<li>CloudFront配置为基于请求标头进行缓存，不会更改CloudFront转发的标头，只会更改CloudFront是否根据标头值缓存对象</li>
<li>通过以下方式提高缓存性能<ul>
<li>将 CloudFront 配置为仅基于指定标头进行转发和缓存，而不是基于所有标头转发和缓存</li>
<li>尝试避免基于具有大量唯一值的请求标头进行缓存</li>
<li>CloudFront配置为将所有标头转发到源，CloudFront不会缓存与此缓存行为关联的对象。 相反，它将每个请求发送到原点</li>
<li>CloudFront基于标头值进行缓存，它不考虑标题名称的情况，但考虑标题值的情况</li>
</ul>
</li>
<li>对于RTMP分发，无法将CloudFront配置为基于标头值进行缓存。</li>
</ul>
</li>
</ul>
<h3 id="对象缓存和过期"><a href="#对象缓存和过期" class="headerlink" title="对象缓存和过期"></a>对象缓存和过期</h3><ul>
<li>对象到期时间即对象在从Origin再次获取之前保留在CloudFront缓存中的时间</li>
<li>低过期时间有助于提供频繁更改的内容，长过期时间有助于提高性能并减少原始负载</li>
<li>到期时间后，CloudFront会检查它是否仍具有最新版本</li>
<li>到期时间后，CloudFront会检查它是否仍具有最新版本<ul>
<li>如果缓存已具有最新版本，则origin返回304状态代码（未修改）。</li>
<li>如果CloudFront缓存没有最新版本，则原点返回200状态代码（OK）和对象的最新版本</li>
</ul>
</li>
<li>如果不经常请求边缘位置中的对象，CloudFront可能会逐出该对象，在其到期日期之前删除该对象，以便为最近请求的对象腾出空间。</li>
<li>默认情况下，每个对象在24小时后自动过期</li>
<li>对于Web分发，可以通过更改默认行为<ul>
<li>对于整个路径模式，可以通过设置Minimum TTL，Maximum TTL和Default TTL值来配置缓存行为</li>
<li>对于单个对象，可以将origin配置为向对象添加Cache-Control max-age或Cache-Control s-maxage指令或Expires头字段。</li>
<li>AWS建议在Expires标头上使用Cache-Control max-age指令来控制对象缓存行为</li>
<li>如果同时指定了Cache-Control max-age指令和Expires标头，则CloudFront仅使用<strong>Cache-Control max-age</strong>的值</li>
<li>来自查看器的GET请求中的HTTP Cache-Control或Pragma标头字段不能用于强制CloudFront返回到对象的源服务器</li>
<li>默认情况下，当原始返回HTTP 4xx或5xx状态代码时，CloudFront会将这些错误响应缓存五分钟，然后将该对象的下一个请求提交到原点以查看是否请求的对象可用</li>
</ul>
</li>
<li>对于RTMP分发<ul>
<li>可以将Cache-Control或Expires标头添加到对象，以更改CloudFront在将另一个请求转发到源之前将对象保留在边缓存中的时间。</li>
<li>最短持续时间为3600秒（一小时）。如果指定较低的值，CloudFront将使用3600秒。  </li>
</ul>
</li>
</ul>
<h2 id="配置安全访问和限制对内容的访问"><a href="#配置安全访问和限制对内容的访问" class="headerlink" title="配置安全访问和限制对内容的访问"></a>配置安全访问和限制对内容的访问</h2><h3 id="提供私有内容"><a href="#提供私有内容" class="headerlink" title="提供私有内容"></a>提供私有内容</h3><ul>
<li>可采用两种方式控制用户对私有内容的访问，如下图所示：<ul>
<li>限制对 CloudFront 边缘缓存中的文件的访问</li>
<li>通过执行下列操作之一，限制对源中文件的访问：<ul>
<li>为 Amazon S3 存储桶（除非已将其配置为网站终端节点）设置源访问身份 (OAI)</li>
<li>为私有 HTTP 服务器配置自定义标头或者将 Amazon S3 存储桶配置作为网站终端节点<br><img src="https://i.loli.net/2019/08/30/d2QlFRyZ4nkm6c8.png" alt="001.png"></li>
</ul>
</li>
</ul>
</li>
<li>创建签名 URL 或签名 Cookie 以控制对文件的访问时，可以指定以下限制：<ul>
<li>结束日期和时间，在此之后，URL 不再有效</li>
<li>（可选）URL 生效的日期和时间</li>
<li>（可选）可用于访问内容的 IP 地址或计算机的地址范围</li>
</ul>
</li>
<li>选择保护 Amazon S3 存储桶中的内容，以便用户可以通过 CloudFront 访问内容，但无法使用 Amazon S3 URL 直接访问内容。这可防止其他人绕过 CloudFront 并使用 Amazon S3 URL 访问希望限制访问的内容。虽然此步骤未要求使用签名 URL，但我们建议使用。</li>
<li>签名URL或签名Cookie可以使用HTTP服务器作为源，与CloudFront一起使用。 它要求内容可公开访问，并且应注意不要共享内容的直接URL</li>
<li>源端限制可适用于<ul>
<li>对于S3，使用Origin Access Identity仅使用Bucket策略或Object ACL授予CloudFront访问权限，以及删除任何其他访问权限</li>
<li>对于HTTP服务器，可以通过CloudFront添加自定义标头，可以在Origin使用它来验证请求来自CloudFront</li>
</ul>
</li>
</ul>
<h3 id="可信签署人"><a href="#可信签署人" class="headerlink" title="可信签署人"></a>可信签署人</h3><ul>
<li>要创建签名 URL 或签名 Cookie，至少需要一个具有有效 CloudFront 密钥对的 AWS 账户。该账户被称为可信签署人。</li>
<li>只要将可信签署人的 AWS 账户 ID 添加到分配中，CloudFront 就会立即开始要求用户使用签名 URL 或签名 Cookie 访问文件</li>
<li>创建签名 URL 或签名 Cookie 时，使用可信签署人的私有密钥来签署 URL 或 Cookie 的一部分。当某人请求限制的文件时，CloudFront 会比较 URL 或 Cookie 的已签名部分与未签名部分，以确认 URL 或 Cookie 未被篡改。CloudFront 还会验证 URL 或 Cookie 是否有效，例如是否未超过过期日期和时间</li>
<li>指定可信签署人时，还会间接指定要求签名 URL 或签名 Cookie 的文件：<ul>
<li>Web 分配 – 将可信签署人添加到缓存行为中。如果分配只有一个缓存行为，用户则必须使用签名 URL 或签名 Cookie 访问与该分配关联的任何文件。如果创建了多个缓存行为，并将可信签署人添加到某些缓存行为中而没有添加到其他缓存行为中，则可要求用户使用签名 URL 或签名 Cookie 访问某些文件而不是其他文件。</li>
<li>RTMP 分配（仅签名 URL） – 将可信签署人添加到分配中。在将可信签署人添加到 RTMP 分配后，用户必须使用签名 URL 访问与该分配相关联的任何文件。</li>
</ul>
</li>
<li>用于创建CloudFront签名URL或签名cookie的每个可信签署者AWS账户必须拥有自己的活动CloudFront密钥对，应该经常轮换</li>
<li>每个缓存行为或RTMP分配最多可以分配5个可信签名者</li>
</ul>
<h3 id="签名URL-vs-签名cookie"><a href="#签名URL-vs-签名cookie" class="headerlink" title="签名URL vs 签名cookie"></a>签名URL vs 签名cookie</h3><ul>
<li>在以下情况下使用签名 URL：<ul>
<li>希望使用 RTMP 分配。RTMP 分配不支持签名 Cookie。</li>
<li>希望限制对单个文件的访问，例如应用程序的安装程序下载。</li>
<li>用户使用不支持 Cookie 的客户端 (例如，自定义 HTTP 客户端)。</li>
</ul>
</li>
<li>在以下情况下使用签名 Cookie：<ul>
<li>希望提供对多个限制文件的访问，例如，HLS 格式视频的所有文件或者网站订户区域中的所有文件。</li>
<li>不希望更改当前 URL。</li>
</ul>
</li>
</ul>
<h3 id="标准策略-vs-自定义策略"><a href="#标准策略-vs-自定义策略" class="headerlink" title="标准策略 vs 自定义策略"></a>标准策略 vs 自定义策略</h3><ul>
<li>创建签名 URL 时，需要编写 JSON 格式的策略声明，以指定对签名 URL 的限制，例如，URL 的有效期。可以使用标准策略或自定义策略。以下是标准策略和自定义策略的比较</li>
</ul>
<table>
<thead>
<tr>
<th>描述</th>
<th>标准策略</th>
<th>自定义策略</th>
</tr>
</thead>
<tbody><tr>
<td>可对多个文件重复使用策略声明。要重复使用策略声明，必须在 Resource 对象中使用通配符。有关更多信息，请参阅 在使用自定义策略的签名 URL 的策略声明中指定的值。)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>可指定用户开始访问内容的日期和时间。</td>
<td>否</td>
<td>是（可选）</td>
</tr>
<tr>
<td>可指定用户无法再访问内容的日期和时间。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可指定能够访问内容的用户的 IP 地址或 IP 地址范围。</td>
<td>否</td>
<td>是（可选）</td>
</tr>
<tr>
<td>签名 URL 包括策略的 Base64 编码版本，这会导致更长的 URL。</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>CloudFront 何时检查签名 URL 中的过期日期和时间来确定该 URL 是否仍有效，取决于该 URL 是用于 Web 分配还是用于 RTMP 分配<ul>
<li>Web 分配 – 在发出 HTTP 请求时，CloudFront 检查签名 URL 中的过期日期和时间。如果客户端刚好在过期时间之前开始下载大型文件，即使在下载过程中到了过期时间，该下载也应该完成。如果客户端使用 Range GET 来获取较小的文件，在过期时间到期后发生的任何 GET 请求将会失败。</li>
<li>RTMP分配 - 播放事件开始时，CloudFront 检查签名 URL 中的过期时间。如果客户端在过期时间到期之前开始播放媒体文件，CloudFront 将允许播放整个媒体文件。然而，根据媒体播放器，暂停和重新开始可能触发另一个播放事件。跳到媒体文件中另一个位置将触发另一个播放事件。如果在过期时间到期后发生播放事件，CloudFront 不会提供媒体文件。</li>
</ul>
</li>
</ul>
<h3 id="提供压缩"><a href="#提供压缩" class="headerlink" title="提供压缩"></a>提供压缩</h3><ul>
<li>将 CloudFront 配置为在查看器请求的请求标头中包含 Accept-Encoding: gzip 时自动压缩某些类型的文件，并提供压缩文件</li>
<li>在压缩内容时，由于文件更小，因此下载速度更快，在某些情况下，大小不到原件的四分之一。—特别是对于 JavaScript 和 CSS 文件，更快的下载转化为向用户更快地提供网页。</li>
<li>查看器请求必须在请求标头中包含 Accept-Encoding: gzip，否则，CloudFront 不会压缩请求的文件</li>
<li>如果使用自定义或 Amazon S3 源，可以将源配置为使用或不使用 CloudFront 压缩功能压缩文件。源可以压缩 CloudFront 无法压缩的文件类型。</li>
<li>如果源向 CloudFront 返回压缩文件，CloudFront 将根据 Content-Encoding 标头值检测到已压缩该文件，而不会再次压缩该文件。</li>
<li>使用 CloudFront 压缩内容<ol>
<li>创建或更新 CloudFront 分配，并配置 CloudFront 以压缩内容。</li>
<li>查看器请求文件。查看器将 Accept-Encoding: gzip 标头添加到请求中。这表示查看器支持压缩的内容。</li>
<li>在边缘站点，CloudFront 将在缓存中检查请求中引用的文件的压缩版本。</li>
<li>如果压缩的文件已在缓存中，则 CloudFront 将文件返回到查看器并跳过剩余步骤。</li>
<li>如果压缩文件没有位于缓存中，则 CloudFront 将请求转发到源服务器，它可以是 Amazon S3 存储桶或自定义源。</li>
<li>源服务器将请求文件的未压缩版本返回到 CloudFront。</li>
<li>CloudFront 确定文件是否可压缩：<ul>
<li>文件必须是 CloudFront 可压缩的类型。</li>
<li>文件大小必须介于 1000 和 10000000 字节之间。</li>
<li>响应必须包含 Content-Length 标头，以便 CloudFront 可以确定文件大小是否在 CloudFront 压缩的范围内。如果缺少    </li>
<li>Content-Length 标头，则 CloudFront 不会压缩文件。</li>
<li>该响应不得包含 Content-Encoding 标头。</li>
</ul>
<ol start="8">
<li>如果文件是可压缩的，则 CloudFront 将压缩文件，将压缩后的文件返回到查看器并将它添加到缓存中。</li>
<li>查看器将解压缩文件。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Distribution-Details"><a href="#Distribution-Details" class="headerlink" title="Distribution Details"></a>Distribution Details</h2><h3 id="替代域名（CNAME）"><a href="#替代域名（CNAME）" class="headerlink" title="替代域名（CNAME）"></a>替代域名（CNAME）</h3><ul>
<li>默认情况下，CloudFront为分发分配域名，例如d111111abcdef8.cloudfront.net</li>
<li>备用域名（也称为CNAME）可用于将自己的自定义域名用于指向对象的链接</li>
<li>Web和RTMP分发都支持备用域名。</li>
<li>CloudFront在域名开头支持*通配符，而不是单独指定子域。</li>
<li>但是，通配符不能替换部分子域名，例如， * domain.example.com，或者不能替换域名中间的子域名，例如子域.*.example.com</li>
</ul>
<h3 id="限制内容的地理分配"><a href="#限制内容的地理分配" class="headerlink" title="限制内容的地理分配"></a>限制内容的地理分配</h3><ul>
<li>当用户请求内容时，CloudFront 通常会提供请求的内容，而不考虑用户所在的位置。如果需要阻止特定国家/地区的用户访问内容，可以使用 CloudFront 地理限制功能来执行下列操作之一：<ul>
<li>仅当用户位于批准的国家/地区白名单中的某个国家/地区时，才允许他们访问内容。</li>
<li>当用户位于阻止的国家/地区黑名单中的某个国家/地区时，阻止他们访问内容。<blockquote>
<p>CloudFront 使用第三方 GeoIP 数据库确定用户的位置。IP 地址和国家/地区之间映射的准确性因区域而异。根据最近的测试，整体准确性为 99.8%。请注意，如果 CloudFront 无法确定用户的位置，CloudFront 将提供用户请求的内容。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="CloudFront与Amazon-S3"><a href="#CloudFront与Amazon-S3" class="headerlink" title="CloudFront与Amazon S3"></a>CloudFront与Amazon S3</h3><ul>
<li>CloudFront可用于分发S3存储桶中的内容</li>
<li>对于RTMP分发，S3存储区是唯一受支持的源，并且不能使用自定义源</li>
<li>在S3上使用CloudFront具有以下优势<ul>
<li>如果在更高的使用频率下频繁访问对象，则可以更具成本效益，CloudFront数据传输的价格远低于S3数据传输的价格。</li>
<li>CloudFront的下载速度比单独使用S3更快，因为对象存储的距离更接近用户</li>
<li>当使用S3作为分发的原点并将存储桶移动到其他区域时，如果满足以下两个条件，则CloudFront最多可能需要一个小时来更新其记录以包括区域更改：<ul>
<li>源访问标识（OAI）用于限制对存储桶的访问</li>
<li>存储桶被移动到需要签名版本4进行身份验证的S3区域</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="源站访问识别"><a href="#源站访问识别" class="headerlink" title="源站访问识别"></a>源站访问识别</h3><ul>
<li>以S3为源站，S3中的对象必须被授予公共读取权限，因此可以从S3和CloudFront访问对象</li>
<li>尽管CloudFront不公开底层S3 URL，但如果直接共享或由应用程序使用，则可以为用户所知</li>
<li>要使用CloudFront签名URL或签名cookie来提供对对象的访问，有必要阻止用户直接访问S3对象</li>
<li>直接访问S3对象会导致 <ul>
<li>绕过CloudFront签名URL或签名cookie提供的控制，例如，控制用户无法再访问内容的日期时间，并且IP地址可用于访问内容</li>
<li>CloudFront访问日志不太有用，因为它们不完整。</li>
</ul>
</li>
<li>源访问标识（OAI）可用于防止用户直接从S3访问对象</li>
<li>可以创建原始访问标识（一种特殊的CloudFront用户）并将其与分发相关联。</li>
<li>需要将S3存储桶/对象权限配置为仅提供对源访问标识的访问</li>
<li>当用户从CloudFront访问该对象时，它使用OAI代表用户获取内容，同时限制对S3对象的直接访问</li>
</ul>
<h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><ul>
<li>CloudFront可以配置为包括自定义标头或修改现有标头，只要它将请求转发到源</li>
<li>验证用户没有直接访问源，绕过CDN</li>
<li>如果用户使用不支持CORS的查看器，请配置CloudFront以将Origin标头转发到源。 这将导致origin为每个请求返回Access-Control-Allow-Origin标头</li>
</ul>
<h3 id="添加和更新对象"><a href="#添加和更新对象" class="headerlink" title="添加和更新对象"></a>添加和更新对象</h3><ul>
<li>只需要将对象添加爱到Origin，CloudFront将在访问时开发分发他们</li>
<li>通过以下方式更新<ul>
<li>覆盖原始对象</li>
<li>创建不同的版本并更新向用户公开的链接</li>
</ul>
</li>
<li>为了更新对象，建议使用版本控制，例如拥有文件或带有版本的整个文件夹，因此在更新对象时强制刷新可以更改链接</li>
<li>版本控制<ul>
<li>在CloudFront开始提供新版本之前，没有时间等待对象过期</li>
<li>从边缘提供的对象的一致性没有差异</li>
<li>支付对象失效不涉及任何费用。</li>
</ul>
</li>
</ul>
<h3 id="删除-使对象无效"><a href="#删除-使对象无效" class="headerlink" title="删除/使对象无效"></a>删除/使对象无效</h3><ul>
<li>默认情况下，对象将在到期时被删除（TTL），并且最新的对象将从Origin获取</li>
<li>对象也可以在到期之前从边缘缓存中删除<ul>
<li>更改对象名称（版本控制）已提供具有不同名称的对象的不同版本</li>
<li>在边缘缓存中使对象失效，对于下一个请求，cloudfront返回到Origin以获取对象</li>
</ul>
</li>
<li>Web分发<ul>
<li>如果需要频繁更新对象，则建议更改对象名称（版本控制），而不是像对象那样更改对象<ul>
<li>即使用户在本地或在缓存代理后面缓存了版本，也可以控制请求返回的对象。如果对象无效，则用户可能会继续查看旧版本，直到它们从这些缓存过期。</li>
<li>由于CloudFront访问日志包含对象的名称，因此可以更轻松地分析对象更改的结果</li>
<li>提供了向不同用户提供不同版本的方法。</li>
<li>简化了对象修订之间的前滚和后退。</li>
<li>更便宜，因为没有收取使对象无效的费用。</li>
<li>例如将header-v1.jpg更改为header-v2.jpg</li>
</ul>
</li>
<li>使缓存中的对象失效<ul>
<li>缓存中的对象可以在它们到期之前显式无效以强制刷新</li>
<li>允许使所选对象无效</li>
<li>允许使多个对象无效，例如如果目录中的对象或名称以相同字符开头的所有对象，则可以在失效路径的末尾包含*通配符</li>
<li>无效路径可以用于例如单个对象。 /js/ab.js或多个对象，例如： / js / <em>并且即使</em>通配符请求可能使数千个对象无效，也会被计为单个请求</li>
</ul>
</li>
</ul>
</li>
<li>对于RTMP分发，对象不能无效</li>
</ul>
<h3 id="Range-GETS"><a href="#Range-GETS" class="headerlink" title="Range GETS"></a>Range GETS</h3><ul>
<li>在GET请求中使用Range标头的部分请求有助于以较小的单位下载对象，从而提高部分下载的效率和部分失败的传输的恢复。</li>
<li>对于partial get 请求，cloudfront <ul>
<li>检查边缘位置中的缓存是否包含请求的范围或整个对象，如果存在，则立即提供</li>
<li>如果请求的范围不存在，它会将请求转发到源，并且可能请求比客户端请求更大的范围以优化性能</li>
<li>如果origin支持范围标头，则返回请求的对象范围，CloudFront将其返回给查看器</li>
<li>如果原点不支持范围标题，则返回完整对象，CloudFront将为整个对象提供服务并将其缓存以备将来使用。</li>
<li>CloudFront使用缓存的整个对象来提供任何未来范围的GET标头请求</li>
</ul>
</li>
</ul>
<h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><ul>
<li>可以将CloudFront配置为创建包含有关CloudFront接收的每个用户请求的详细信息的日志文件</li>
<li>可用于Web和RTMP分发</li>
<li>启用日志记录后，可以指定一个S3存储桶，CloudFront将保存文件</li>
<li>CloudFront定期为分发提供访问日志，最多可达一小时几次</li>
<li>CloudFront通常会在日志中显示的事件的一小时内将该时间段的日志文件传递到S3存储桶。 但请注意，某段时间内的某些或所有日志文件条目有时可能会延迟最多24小时</li>
</ul>
<h2 id="CloudFront-费用"><a href="#CloudFront-费用" class="headerlink" title="CloudFront 费用"></a>CloudFront 费用</h2><ol>
<li>数据传输到Internet<ul>
<li>对于从CloudFront边缘位置传输的数据量，将收取费用，以GB为单位</li>
<li>不再收取从AWS源（例如，S3，EC2等）到CloudFront的数据传输。</li>
<li>适用于从所有AWS区域到所有全球CloudFront边缘位置的数据传输</li>
</ul>
</li>
<li>HTTP/HTTPS 请求<ul>
<li>为内容进行的HTTP / HTTPS请求数</li>
</ul>
</li>
<li>失效请求<ul>
<li>无效请求中的每个路径</li>
<li>失效请求中列出的路径表示要从CloudFront缓存中失效的对象的URL（如果路径包含通配符，则为多个URL）</li>
</ul>
</li>
<li>与Cloudfront分配相关联的专用IP 自定义SSL证书</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/28/AWS-Elastic-LoadBalancer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/AWS-Elastic-LoadBalancer/" itemprop="url">AWS Elastic LoadBalancer</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T21:08:05+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Elastic Load Balancing 在多个目标（如 Amazon EC2 实例、容器、IP 地址和 Lambda 函数）之间自动分配传入的应用程序流量</li>
<li>ELB作为客户侧访问的单一入口</li>
<li>ELB通过允许在一个或多个可用区域中添加或删除多个EC2实例来帮助透明并提高应用程序可用性，而不会中断业务流量</li>
<li>ELB的优势<ul>
<li>自身设计是一个高度容错和自动监控的分布式系统</li>
<li>简化管理、维护和扩展负载均衡的复杂性</li>
<li>可以是抵御网络攻击的第一道防线</li>
<li>可以卸载加密和解密（SSL终止）的工作，以便于EX2实例专注于自身负载</li>
<li>与Auto Scaling集成，可确保有足够的后端容量，以满足不同的流量压力</li>
<li>非单点故障</li>
</ul>
</li>
<li>默认情况下，Elastic Load Balancer将每个请求独立地路由到具有最小负载的已注册实例。</li>
<li>如果EC2实例失败，ELB会自动将流量重新路由到剩余正在运行的健康EC2实例。 如果还原失败的EC2实例，Elastic Load Balancing将恢复该实例的流量。</li>
<li>负载均衡器仅适用于区域内的AZ</li>
</ul>
<p><img src="https://i.loli.net/2019/08/28/bieqrjDdSkMzvo6.png" alt="screen-shot-2016-04-05-at-7-54-34-am.png"></p>
<h1 id="AWS-ELB-Application-Load-Balancer"><a href="#AWS-ELB-Application-Load-Balancer" class="headerlink" title="AWS ELB Application Load Balancer"></a>AWS ELB Application Load Balancer</h1><blockquote>
<p>Application Load Balancer 运行于请求级别（第 7 层），可根据请求的内容将流量路由至 EC2 实例、容器、IP 地址和 Lambda 函数等目标。Application Load Balancer 最适合 HTTP 和 HTTPS 流量的高级负载均衡，面向交付包括微服务和基于容器的应用程序在内的现代应用程序架构，提供高级请求路由功能。Application Load Balancer 通过确保始终使用最新的 SSL/TLS 密码和协议，简化并提高应用程序的安全性。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/08/28/S57BoUwFTL2Rpcn.png" alt="img2.png"></p>
<h2 id="Application-Load-Balancer-Benefits"><a href="#Application-Load-Balancer-Benefits" class="headerlink" title="Application Load Balancer Benefits"></a>Application Load Balancer Benefits</h2><ul>
<li>支持基于路径的路由，可以根据请求中的URL将侦听器规则配置为转发请求。</li>
<li>通过使用多个端口注册实例，支持将请求路由到单个EC2实例上的多个服务。</li>
<li>支持容器化应用程序。 EC2容器服务（ECS）可以在计划任务时选择未使用的端口，并使用此端口向目标组注册任务，从而有效地使用群集。</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查，并在目标组级别报告了许多CloudWatch指标。 通过将目标组附加到Auto Scaling组，可以根据需求动态扩展每个服务。</li>
</ul>
<h2 id="Application-Load-Balancer-Features"><a href="#Application-Load-Balancer-Features" class="headerlink" title="Application Load Balancer Features"></a>Application Load Balancer Features</h2><ul>
<li>支持使用HTTP和HTTPS协议对应用程序进行负载平衡</li>
<li>支持HTTP/2，本机启用。支持HTTP/2的客户端可以通过TLS连接</li>
<li>支持WebSockets和Secure WebSockets</li>
<li>默认情况下，支持请求追踪</li>
<li>支持使用负载均衡器生成的cookie的粘滞会话（会话关联），将来自同一客户端的请求路由到同一目标</li>
<li>支持SSL终止，在将请求发送到后端目标之前解密ALB上的请求</li>
<li>支持第7层特​​定功能，如X-Forwarded-For标头，以帮助确定实际的客户端IP，端口和协议</li>
<li>随着请求容量自动伸缩调整其负载大小</li>
<li>支持跨AZ部署，提高高可用性和传入流量分布</li>
<li>与ACM集成以提供SSL / TLS证书并将其绑定到负载均衡器，从而使整个SSL卸载过程变得非常容易</li>
<li>支持IPv6,面向internet的负载均衡</li>
<li>支持请求追踪，自定义标识符“X-Amzn-Trace-Id”HTTP头标注在所有请求上，以帮助跟踪各种服务的请求流</li>
<li>支持安全组来控制允许进出负载均衡器的流量</li>
<li>提供访问日志，记录发送到负载均衡器的所有请求，并将日志存储在S3中，以便以压缩格式进行后续分析</li>
<li>支持连接空闲超时 -  ALB为每个请求维护两个连接，一个连接客户端（前端），另一个连接目标实例（后端）。如果在空闲超时时间过去之前没有发送或接收数据，则ALB关闭前端连接</li>
<li>支持使用循环算法的慢启动模式，允许添加新目标但不会用大量请求占用新目标</li>
<li>与CloudWatch集成以提供请求计数，错误计数，错误类型和请求延迟等指标</li>
<li>与AWS WAF集成，这是一种Web应用程序防火墙，允许通过允许基于IP地址，HTTP标头和自定义URI字符串的规则配置来保护Web应用程序免受攻击</li>
<li>与CloudTrail集成以接收在AWS账户上进行的ALB API调用的历史记录</li>
</ul>
<h2 id="Application-Load-Balancer-Listeners"><a href="#Application-Load-Balancer-Listeners" class="headerlink" title="Application Load Balancer Listeners"></a>Application Load Balancer Listeners</h2><ul>
<li>侦听器是使用配置的协议和端口检查连接请求的进程</li>
<li>支持HTTP和HTTPS协议，端口好范围1-65535</li>
<li>ALB支持HTTPS侦听器的SSL终止，这有助于卸载加密和解密工作，以便目标可以专注于其主要工作。</li>
<li>HTTPS侦听器在侦听器上仅支持一个SSL服务器证书。</li>
<li>具有HTTP和HTTPS侦听器的WebSockets（安全WebSockets）</li>
<li>支持HTTP/2和HTTPS侦听器<ul>
<li>一个HTTP/2连接可以并发128个请求</li>
<li>ALB将这些请求转换为单独的HTTP / 1.1请求，并使用循环路由算法将它们分布到目标组中的健康目标上。</li>
<li>HTTP / 2更有效地使用前端连接，从而减少客户端与负载均衡器之间的连接。</li>
<li>不支持HTTP / 2的服务器推送功能</li>
</ul>
</li>
<li>侦听器都有一个默认规则，可以自定义其他规则</li>
<li>每个规则都包含优先级，动作，可选主机条件和可选路径条件<ul>
<li>优先级——按优先级顺序评估规则，从最低值到最高值。 默认规则具有最低优先级</li>
<li>动作——每个规则操作都有一个类型和一个目标组。 目前，唯一支持的类型是forward，它将请求转发给目标组。 可以随时更改规则的目标组。</li>
<li>条件——有两种类型的规则条件：主机和路径。 当满足规则的条件时，则采取其行动</li>
</ul>
</li>
<li>主机条件或基于主机的路由<ul>
<li>主机条件可用于定义根据主机头中的主机名将请求转发到不同目标组的规则</li>
<li>这使得能够使用单个ALB支持多个域，例如， orders.example.com，images.example.com，registration.example.com</li>
<li>每个主机条件都有一个主机名。</li>
</ul>
</li>
<li>路径条件或基于路径的路由<ul>
<li>路径条件可用于定义根据请求中的URL将请求转发到不同目标组的规则 </li>
<li>每个路径条件具有一个路径模式，例如， example.com/orders,example.com/images,example.com/registration</li>
<li>如果请求中的URL与侦听器规则中的路径模式完全匹配，则使用该规则路由请求。</li>
</ul>
</li>
</ul>
<h2 id="相比CLB的优势"><a href="#相比CLB的优势" class="headerlink" title="相比CLB的优势"></a>相比CLB的优势</h2><ul>
<li>支持基于路径的路由，其中​​可以配置规则以使侦听器基于URL转发请求</li>
<li>支持基于主机的路由，其中​​可以为侦听器配置规则，以根据HTTP标头中的主机字段转发请求。</li>
<li>支持将请求路由到单个EC2实例上的多个应用程序。可以使用多个端口向同一目标组注册每个实例或IP地址</li>
<li>支持按IP地址注册目标，包括负载均衡器的VPC外部目标。</li>
<li>使用动态端口映射为ECS支持容器化应用程序</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查和许多CloudWatch指标</li>
<li>将目标组附加到Auto Scaling组可以根据需求动态扩展每个服务</li>
<li>访问日志包含其他信息并以压缩格式存储</li>
<li>提高负载均衡器性能</li>
</ul>
<h1 id="AWS-ELB-Network-Load-Balancer"><a href="#AWS-ELB-Network-Load-Balancer" class="headerlink" title="AWS ELB Network Load Balancer"></a>AWS ELB Network Load Balancer</h1><ul>
<li>网络负载均衡器运行于连接级别（第 4 层），可根据 IP 协议数据将连接路由至Amazon VPC内的不同目标（Amazon EC2 实例、微服务和容器）</li>
<li>网络负载均衡器最适合 TCP 和 UDP 流量的负载均衡，能够在保持超低延迟的同时每秒处理数百万个请求</li>
<li>网络负载均衡器还经过了优化，能够处理突发的和不稳定的流量模式，同时在每个可用区使用单个静态 IP 地址</li>
<li>集成了其他常见的 AWS 服务，例如 Auto Scaling、Amazon EC2 Container Service (ECS)、Amazon CloudFormation 和 Amazon AWS Certificate Manager (ACM)</li>
</ul>
<h2 id="Network-Load-Balancer-Features"><a href="#Network-Load-Balancer-Features" class="headerlink" title="Network Load Balancer Features"></a>Network Load Balancer Features</h2><h3 id="基于连接的负载均衡"><a href="#基于连接的负载均衡" class="headerlink" title="基于连接的负载均衡"></a>基于连接的负载均衡</h3><ul>
<li>可以对 TCP 和 UDP 流量执行负载均衡，将连接路由到不同的目标 – Amazon EC2 实例、微服务和容器。</li>
</ul>
<h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><ul>
<li>网络负载均衡器具有高可用性。</li>
<li>它接受来自客户端的传入流量，并在同一可用区内的目标之间分配此流量。</li>
<li>负载均衡器还监控其已注册目标的运行状况，并确保它仅将流量路由到正常运行的目标。</li>
<li>当负载均衡器检测到无法正常运行的目标时，它会停止将流量路由到该目标，并将流量重新路由到剩余的正常运行的目标。如果一个可用区中的所有目标全都无法正常运行，但已在另一个可用区中设置了目标，则网络负载均衡器将自动进行故障转移以将流量路由到其他可用区中正常运行的目标。</li>
</ul>
<h3 id="高吞吐量"><a href="#高吞吐量" class="headerlink" title="高吞吐量"></a>高吞吐量</h3><ul>
<li>网络负载均衡器旨在处理不断增长的流量，并可以对每秒数百万个请求进行负载均衡。它还可以处理突发的不稳定流量模式。</li>
</ul>
<h3 id="低延迟"><a href="#低延迟" class="headerlink" title="低延迟"></a>低延迟</h3><ul>
<li>网络负载均衡器为延迟敏感的应用程序提供极低的延迟。</li>
</ul>
<h3 id="保留源-IP-地址"><a href="#保留源-IP-地址" class="headerlink" title="保留源 IP 地址"></a>保留源 IP 地址</h3><ul>
<li>网络负载均衡器保留客户端源 IP，允许后端查看客户端的 IP 地址。然后，应用程序可以将其用于进一步处理。</li>
</ul>
<h3 id="静态-IP-支持"><a href="#静态-IP-支持" class="headerlink" title="静态 IP 支持"></a>静态 IP 支持</h3><ul>
<li>网络负载均衡器自动提供每个可用区（子网）的静态 IP，应用程序可将其用作负载均衡器的前端 IP。</li>
</ul>
<h3 id="弹性-IP-支持"><a href="#弹性-IP-支持" class="headerlink" title="弹性 IP 支持"></a>弹性 IP 支持</h3><ul>
<li>网络负载均衡器还允许为每个可用区（子网）分配弹性 IP，从而提供自己的固定 IP。</li>
</ul>
<h3 id="TLS-卸载"><a href="#TLS-卸载" class="headerlink" title="TLS 卸载"></a>TLS 卸载</h3><ul>
<li>网络负载均衡器支持在客户端和负载均衡器之间终止 TLS。</li>
<li>除了为在完成客户端与负载均衡器之间的 TLS 握手时首选的密码和协议提供灵活性的预定义安全策略外，网络负载均衡器还提供通过 AWS Identity and Access Management (IAM) 和 AWS Certificate Manager 管理 SSL 证书的功能。</li>
<li>在网络负载均衡器上终止 TLS 后，源 IP 地址将继续保留在的后端应用程序中。</li>
</ul>
<h3 id="运行状况检查"><a href="#运行状况检查" class="headerlink" title="运行状况检查"></a>运行状况检查</h3><ul>
<li>网络负载均衡器支持网络和应用程序目标运行状况检查。</li>
<li>网络级健康检查<ul>
<li>基于底层目标（实例或容器）对正常流量的总体响应。</li>
<li>如果目标很慢或无法响应新的连接请求，则标记为不可用</li>
</ul>
</li>
<li>应用程序级健康检查<ul>
<li>通过定期探测给定目标上的特定 URL，它可以集成实际应用程序的运行状况</li>
</ul>
</li>
</ul>
<h3 id="DNS-故障转移"><a href="#DNS-故障转移" class="headerlink" title="DNS 故障转移"></a>DNS 故障转移</h3><ul>
<li>如果没有向网络负载均衡器注册的正常运行的目标，或者给定区域中的网络负载均衡器节点无法正常运行，则 Amazon Route 53 会将流量定向到其他可用区中的负载均衡器节点。</li>
</ul>
<h3 id="与-Amazon-Route-53-集成"><a href="#与-Amazon-Route-53-集成" class="headerlink" title="与 Amazon Route 53 集成"></a>与 Amazon Route 53 集成</h3><ul>
<li>如果的网络负载均衡器无法响应，则与 Route 53 的集成将从服务中删除不可用的负载均衡器 IP 地址，并将流量定向到另一个区域中的备用网络负载均衡器。</li>
</ul>
<h3 id="与-AWS-服务集成"><a href="#与-AWS-服务集成" class="headerlink" title="与 AWS 服务集成"></a>与 AWS 服务集成</h3><ul>
<li>网络负载均衡器已与其他 AWS 服务集成，例如 Auto Scaling、Elastic Container Service (ECS)、CloudFormation、Elastic BeanStalk、CloudWatch、Config、CloudTrail、CodeDeploy 和 AWS Certificate Manager (ACM)。</li>
</ul>
<h3 id="长时间运行的-TCP-连接"><a href="#长时间运行的-TCP-连接" class="headerlink" title="长时间运行的 TCP 连接"></a>长时间运行的 TCP 连接</h3><p>网络负载均衡器支持长时间运行的 TCP 连接，这是 WebSocket 类型的应用程序的理想选择。</p>
<h3 id="集中-API-支持"><a href="#集中-API-支持" class="headerlink" title="集中 API 支持"></a>集中 API 支持</h3><ul>
<li>网络负载均衡器使用与 Application Load Balancer 相同的 API。这将使能够在同一 Amazon EC2 实例上的多个端口之间使用目标组、运行状况检查和负载均衡，以支持容器化应用程序。</li>
</ul>
<h3 id="可靠的监控和审核"><a href="#可靠的监控和审核" class="headerlink" title="可靠的监控和审核"></a>可靠的监控和审核</h3><ul>
<li>Amazon CloudWatch 报告网络负载均衡器指标。CloudWatch 提供诸如活动流计数、正常运行的主机计数、新流计数、已处理的字节等指标。网络负载均衡器还与 AWS CloudTrail 集成。CloudTrail 跟踪对网络负载均衡器的 API 调用。</li>
</ul>
<h3 id="增强的日志记录"><a href="#增强的日志记录" class="headerlink" title="增强的日志记录"></a>增强的日志记录</h3><ul>
<li>可以使用流日志功能记录发送到负载均衡器的所有请求。</li>
<li>流日志捕获有关进出 VPC 中网络接口的 IP 流量的信息。流日志数据使用 Amazon CloudWatch Logs 进行存储。</li>
<li>在的网络负载均衡器上添加 TLS 侦听器后，可以选择启用“访问日志”功能，这些访问日志将发送到选择的 S3 存储桶中。“访问日志”会捕获有关侦听器接收的每个 TLS 连接的信息，可从中了解成功和失败的 TLS 握手情况。</li>
</ul>
<h3 id="区域隔离"><a href="#区域隔离" class="headerlink" title="区域隔离"></a>区域隔离</h3><ul>
<li>网络负载均衡器专为单个区域中的应用程序架构而设计。</li>
<li>如果可用区中的某些内容失败，我们将自动故障转移到其他正常运行的可用区。</li>
<li>虽然我们建议客户在多个可用区中配置负载均衡器和目标以实现高可用性，但可以在单个可用区中启用网络负载均衡器，以支持需要区域隔离的架构。</li>
</ul>
<h3 id="使用IP地址作为目标进行负载平衡"><a href="#使用IP地址作为目标进行负载平衡" class="headerlink" title="使用IP地址作为目标进行负载平衡"></a>使用IP地址作为目标进行负载平衡</h3><ul>
<li>允许使用应用程序后端的IP地址作为目标，对AWS或本地托管的任何应用程序进行负载平衡。</li>
<li>允许负载平衡到托管在任何IP地址和实例上任何接口上的应用程序后端。</li>
<li>跨AWS和本地资源实现负载均衡的能力有助于迁移到云，突发到云或故障转移到云</li>
<li>托管在本地位置的应用程序可用作Direct Connect连接和EC2-Classic（使用ClassicLink）的目标。</li>
</ul>
<h2 id="相比CLB的优势-1"><a href="#相比CLB的优势-1" class="headerlink" title="相比CLB的优势"></a>相比CLB的优势</h2><ul>
<li>能够处理不稳定的工作负载并扩展到每秒数百万个请求，而无需预热</li>
<li>支持负载均衡器的静态IP /弹性IP地址</li>
<li>支持按IP地址注册目标，包括负载均衡器的VPC（内部部署）之外的目标。</li>
<li>支持将请求路由到单个EC2实例上的多个应用程序。 可以使用多个端口向同一目标组注册单个实例或IP地址。</li>
<li>支持容器化应用程序。 使用动态端口映射，ECS可以在计划任务时选择未使用的端口，并使用此端口向目标组注册任务。</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查，并在目标组级别报告了许多CloudWatch指标。 将目标组附加到Auto Scaling组可以根据需求动态扩展每个服务</li>
</ul>
<h1 id="ELB-主要功能"><a href="#ELB-主要功能" class="headerlink" title="ELB 主要功能"></a>ELB 主要功能</h1><h2 id="Scaling-ELB"><a href="#Scaling-ELB" class="headerlink" title="Scaling ELB"></a>Scaling ELB</h2><ul>
<li>每个ELB都分配并配置了默认容量</li>
<li>ELB Controller 存储了所有配置信息，还监视负载均衡器并管理用于处理客户端请求的容量</li>
<li>随着流量配置文件的更改，控制器服务会扩展负载平衡器以处理更多请求，并在所有AZ中进行相同的扩展</li>
<li>ELB通过利用更大的资源（向上扩展 - 具有更高性能特征的资源）或更多独立资源（向外扩展）来增加其容量</li>
<li>AWS本身处理ELB容量的扩展，并且此扩展与ELB将其请求路由到的EC2实例的扩展不同，这由Auto Scaling处理</li>
<li>Elastic Load Balancing扩展所需的时间范围为1到7分钟，具体取决于流量配置文件中的更改</li>
</ul>
<h2 id="预热-ELB"><a href="#预热-ELB" class="headerlink" title="预热 ELB"></a>预热 ELB</h2><ul>
<li>ELB最适合逐渐增加流量</li>
<li>AWS能够自动扩展并处理绝大多使用场景</li>
<li>但是，在某些情况下，如果预计存在流量峰值或无法将负载测试配置为逐渐增加流量，建议联系AWS支持以使负载均衡器“预热”</li>
<li>AWS将通过将负载均衡器配置为具有基于预期流量的适当容量级别来帮助预热ELB</li>
<li>AWS需要有关开始日期，结束日期和每秒预期请求率的信息以及请求/响应的总大小</li>
</ul>
<h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><ul>
<li>ELB根据流量配置文件自动缩放</li>
<li>缩放时，Elastic Load Balancing服务将更新负载均衡器的域名系统（DNS）记录，以便新资源在DNS中注册其各自的IP地址。</li>
<li>创建的DNS记录包括60秒的生存时间（TTL）设置</li>
<li>默认情况下，当客户端执行DNS解析时，ELB将返回多个IP地址，并在每个DNS解析请求上随机排序记录。</li>
<li>建议客户端至少每60秒重新查找DNS，以利用增加的容量</li>
</ul>
<h2 id="负载均衡类型"><a href="#负载均衡类型" class="headerlink" title="负载均衡类型"></a>负载均衡类型</h2><ul>
<li>面向internet（具有公共IP地址）<ul>
<li>面向Internet的负载均衡器通过Internet从客户端接收请求，并将这些请求分发到使用负载均衡器注册的EC2实例</li>
</ul>
</li>
<li>内部负载均衡（只有私有IP地址）<ul>
<li>将流量路由到私有子网中的EC2实例</li>
</ul>
</li>
</ul>
<h2 id="可用区-子网"><a href="#可用区-子网" class="headerlink" title="可用区/子网"></a>可用区/子网</h2><ul>
<li>Elastic Load Balancing允许添加子网，并在子网所在的每个可用区中创建负载均衡器节点</li>
<li>ELB至少连接一个子网</li>
<li>每个AZ只能有一个子网连接到ELB。 连接已附加AZ的子网将替换现有子网</li>
<li>每个子网必须具有至少具有/ 27位掩码的CIDR块，并且至少具有8个空闲IP地址，ELB使用这些IP地址与后端实例建立连接</li>
<li>对于高可用性，建议为每个AZ附加一个子网，至少两个AZ，即使实例位于一个子网中</li>
<li>子网可以与ELB连接或分离，它将启动或停止向子网中的实例发送请求</li>
</ul>
<h2 id="安全组和NACL"><a href="#安全组和NACL" class="headerlink" title="安全组和NACL"></a>安全组和NACL</h2><ul>
<li>安全组和NACL应允许来自客户端的负载均衡器侦听器端口上的入站流量用于Internet ELB或VPC CIDR用于内部ELB</li>
<li>安全组和NACL应允许实例侦听器端口和运行状况检查端口上的后端实例的出站流量</li>
<li>此外，nacl应该允许在临时端口上响应</li>
<li>所有EC2实例都应该允许来自ELB的传入流量</li>
</ul>
<h2 id="SSL协商配置"><a href="#SSL协商配置" class="headerlink" title="SSL协商配置"></a>SSL协商配置</h2><ul>
<li>对于HTTPS负载平衡器，Elastic Load Balancing使用安全套接字层（SSL）协商配置（称为安全策略）来协商客户端和负载均衡器之间的SSL连接。<br>安全策略是SSL协议，SSL密码和服务器顺序首选项选项的组合</li>
<li>Elastic Load Balancing支持以下版本的SSL协议TLS 1.2，TLS 1.1，TLS 1.0，SSL 3.0，SSL 2.0（现已弃用）<br>SSL协议使用多个SSL密码来加密Internet上的数据。</li>
<li>Elastic Load Balancing支持Server Order Preference选项，用于协商客户端和负载均衡器之间的连接。<br>在SSL连接协商过程中，这允许负载均衡器控制并选择其列表中位于客户端密码列表中的第一个密码，而不是检查客户端列表中的第一个密码与服务器列表匹配的默认行为。</li>
<li>Elastic Load Balancer允许使用预定义的安全策略或为特定需求创建自定义安全策略。如果未指定，则ELB选择最新的预定义安全策略。</li>
</ul>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><ul>
<li>负载均衡对所有已注册的实例执行运行状况检查，无论实例处于健康状态还是不健康状态</li>
<li>负载均衡器执行运行状况检查以发现EC2实例的可用性，负载均衡器定期发送ping，尝试连接或向健康状况发送请求以检查EC2实例。</li>
<li>运行状况检查是健康实例状态的InService和不健康实例的OutOfService</li>
<li>负载均衡器每隔几秒向Ping协议、Ping端口和Ping路径上的每个注册实例发送一个请求。它等待实例在响应超时期间内响应。如果健康检查超过连续失败响应的不健康阈值，负载平衡器将该实例退出服务。当健康检查超过连续成功响应的健康阈值时，负载平衡器将实例重新投入服务。</li>
<li>负载均衡器仅向健康的EC2实例发送请求，并停止将请求路由到不健康的实例</li>
</ul>
<h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><ul>
<li>侦听器是检查来自客户端的连接请求的进程</li>
<li>侦听器配置有用于前端（客户端到负载平衡器）连接的协议和端口，以及用于后端（负载平衡器到后端实例）连接的协议和端口</li>
<li>监听器支持HTTP，HTTPS，SSL，TCP协议</li>
<li>HTTPS或SSL连接需要X.509证书，负载均衡器使用证书终止连接，然后在将请求发送到后端实例之前解密来自客户端的请求。<br>如果要使用SSL，但不想终止负载均衡器上的连接，请使用TCP进行从客户端到负载均衡器的连接，使用SSL协议进行从负载均衡器到后端应用程序的连接，并在处理请求的后端实例上部署证书。</li>
<li>如果为后端使用HTTPS / SSL连接，则可以在后端实例上启用身份验证。此身份验证可用于确保后端实例仅接受加密通信，并确保后端实例具有正确的证书。</li>
<li>ELB HTTPS侦听器不支持客户端SSL证书</li>
</ul>
<h2 id="空闲连接超时"><a href="#空闲连接超时" class="headerlink" title="空闲连接超时"></a>空闲连接超时</h2><ul>
<li>对于客户端通过负载均衡器发出的每个请求，它为每个客户端请求维护两个连接，一个与客户端的连接，另一个连接到后端实例。</li>
<li>对于每个连接，负载均衡器管理在指定时间段内没有数据通过连接发送时触发的空闲超时。 如果未发送或接收数据，则在空闲超时时间（默认为60秒）过后，它将关闭连接</li>
<li>对于冗长的操作（例如文件上载），应调整连接的空闲超时设置，以确保冗长的操作有时间完成</li>
</ul>
<h2 id="X-Forwarded标头和代理协议支持"><a href="#X-Forwarded标头和代理协议支持" class="headerlink" title="X-Forwarded标头和代理协议支持"></a>X-Forwarded标头和代理协议支持</h2><ul>
<li>由于Elastic Load Balancer拦截客户端和后端服务器之间的流量，后端服务器不知道客户端和负载均衡器之间使用的IP地址，协议和端口。<br>ELB提供X-Forwarded标头支持，以帮助后端服务器在使用HTTP协议时跟踪相同的内容</li>
<li>X-Forwarded-For请求标头，用于在使用HTTP或HTTPS负载均衡器时帮助后端服务器识别客户端的IP地址</li>
<li>X-Forwarded-Proto请求标头，用于帮助后端服务器识别客户端用于连接服务器的协议（HTTP/S）</li>
<li>X-Forwarded-Port请求标头，用于帮助后端服务器识别HTTP或HTTPS负载均衡器用于连接客户端的端口</li>
<li>ELB提供代理协议支持，以帮助后端服务器在使用非HTTP协议或使用HTTPS时不跟踪负载平衡器上的SSL连接。</li>
<li>代理协议是一种Internet协议，用于从请求连接的源传送连接到请求连接的目标的连接信息。</li>
<li>Elastic Load Balancing使用代理协议版本1，它使用可读的头格式，其中包含源IP地址，目标IP地址和端口号等连接信息</li>
<li>如果ELB已经在启用了代理协议的代理服务器后面，则在ELB上启用代理协议将添加两次头</li>
</ul>
<h2 id="块区域负载均衡"><a href="#块区域负载均衡" class="headerlink" title="块区域负载均衡"></a>块区域负载均衡</h2><ul>
<li>默认情况下，负载均衡器会在其启用的可用区域内均匀分配传入请求，例如 如果AZ-a有5个实例且AZ-b有2个实例，则每个AZ的负载仍将分配50％</li>
<li>启用跨区域负载平衡允许ELB在所有后端实例上均匀分配传入请求，而不管AZ包含多少个实例</li>
<li>跨区域负载平衡器减少了在每个可用区中维护相同数量的后端实例的需要，并提高了应用程序处理一个或多个后端实例丢失的能力</li>
<li>建议在每个可用区中保持大致相等数量的实例，以获得更高的容错能力</li>
</ul>
<h2 id="连接耗尽"><a href="#连接耗尽" class="headerlink" title="连接耗尽"></a>连接耗尽</h2><ul>
<li>默认情况下，如果注册的带有ELB的EC2实例已取消注册或变得不健康，则负载均衡器会立即关闭连接</li>
<li>连接耗尽可以帮助负载均衡器在保持现有连接打开的同时完成正在进行的请求，并防止任何新请求被发送到取消注册或不健康的实例</li>
<li>连接耗尽有助于执行维护，例如部署软件升级或替换后端实例，而不会影响客户体验</li>
<li>连接耗尽允许指定最大时间（介于1到3,600秒之间，默认为300秒），以便在将实例报告为取消注册之前保持连接处于活动状态。最大超时限制不适用于与不健康实例的连接</li>
<li>如果实例是Auto Scaling组的一部分并且已为负载均衡器启用了连接耗尽，则Auto Scaling会在由于扩展事件或运行状况而终止实例之前等待正在进行的请求完成，或等待最大超时到期检查更换</li>
</ul>
<h2 id="粘性会话"><a href="#粘性会话" class="headerlink" title="粘性会话"></a>粘性会话</h2><ul>
<li>ELB可以配置为使用粘性会话功能（也称为会话关联），使其能够将用户的会话绑定到实例，并确保将所有请求发送到同一实例</li>
<li>粘性保持一段时间，可以通过应用程序的会话cookie（如果存在）或通过名为AWSELB的cookie（通过Elastic Load balancer创建）来控制</li>
<li>默认情况下，禁用ELB的粘性会话</li>
</ul>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>HTTP / HTTPS负载均衡器。</li>
<li>SSL流量应该在ELB上终止。 ELB通过使用HTTP cookie在HTTP / HTTPS侦听器上执行会话粘性。 如果SSL流量未在ELB上终止并在后端实例上终止，则ELB无法查看HTTP标头，因此无法设置或读取任何来回传递的HTTP标头。</li>
<li>每个可用区中至少有一个健康实例。</li>
</ul>
<h3 id="基于持续时间的粘性会话"><a href="#基于持续时间的粘性会话" class="headerlink" title="基于持续时间的粘性会话"></a>基于持续时间的粘性会话</h3><ul>
<li>基于持续时间的会话粘性由ELB维护，使用创建的特殊cookie来跟踪每个请求到每个侦听器的实例。</li>
<li>当负载均衡器收到请求时，它首先检查请求中是否存在此cookie。 如果是，则将请求发送到cookie中指定的实例。</li>
<li>如果没有cookie，ELB会根据现有的负载平衡算法选择一个实例，并在响应中插入一个cookie，用于绑定来自同一用户的后续请求。</li>
<li>粘性策略配置定义了cookie过期，它确定了每个cookie的有效期。 Cookie会在有效期到期后自动更新。</li>
</ul>
<h3 id="应用程序控制粘性会话"><a href="#应用程序控制粘性会话" class="headerlink" title="应用程序控制粘性会话"></a>应用程序控制粘性会话</h3><ul>
<li>负载均衡器仅使用特殊cookie将会话与处理初始请求的实例相关联，但遵循策略配置中指定的应用程序cookie的生命周期。</li>
<li>如果应用程序响应包含新的应用程序cookie，则负载均衡器仅插入新的粘性cookie。 负载均衡器粘性cookie不会随每个请求更新。</li>
<li>如果明确删除或过期应用程序cookie，则在发出新的应用程序cookie之前，会话将停止粘滞。</li>
<li>如果实例失败或变得不健康，负载均衡器会停止将路由请求发送到该实例，而是根据现有的负载均衡算法选择新的健康实例。 负载均衡器将会话视为现在“卡住”到新的正常实例，并继续将请求路由到该实例，即使失败的实例返回。</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><ul>
<li><strong><font color="red">对于 Application Load Balancer，用于接收请求的负载均衡器节点会按照优先级顺序评估侦听器规则以确定应用哪个规则，然后使用轮询路由算法从目标组中选择一个目标以实施规则操作。每个目标组的路由都是单独进行的，即使某个目标已在多个目标组中注册。</font></strong></li>
<li><strong><font color="red">对于 Network Load Balancer，用于接收连接的负载均衡器节点会根据协议、源 IP 地址、源端口、目标 IP 地址、目标端口和 TCP 序列号，使用流式哈希算法从目标组中为默认规则选择一个目标。来自客户端的 TCP 连接具有不同的源端口和序列号，可以路由到不同的目标。每个单独的 TCP 连接在连接的有效期内路由到单个目标。</font></strong></li>
<li><font color="red"><strong>对于 Classic Load Balancer，接受请求的负载均衡器节点将利用不同算法来选择已注册的实例。它对 TCP 侦听器使用轮询路由算法，对 HTTP 和 HTTPS 侦听器使用最少未完成请求路由算法。<br></strong></font></li>
</ul>
<h2 id="ALB-vs-NLB-vs-CLB"><a href="#ALB-vs-NLB-vs-CLB" class="headerlink" title="ALB vs NLB vs CLB"></a>ALB vs NLB vs CLB</h2><table>
<thead>
<tr>
<th align="left"><strong>功能</strong></th>
<th align="center"><strong>Application Load Balancer</strong></th>
<th align="center"><strong>Network Load Balancer</strong></th>
<th align="center"><strong>Classic Load Balancer</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议</td>
<td align="center">HTTP、HTTPS</td>
<td align="center">TCP、UDP、TLS</td>
<td align="center">TCP、SSL/TLS、HTTP、HTTPS</td>
</tr>
<tr>
<td align="left">平台</td>
<td align="center">VPC</td>
<td align="center">VPC</td>
<td align="center">EC2-Classic、VPC</td>
</tr>
<tr>
<td align="left">运行状况检查</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">CloudWatch 指标</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">日志记录</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">区域故障转移</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">Connection Draining（注销延迟）</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">负载均衡到同一实例上的多个端口</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">IP 地址即目标</td>
<td align="center">✔</td>
<td align="center">✔（TCP、TLS）</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">负载均衡器删除保护</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">可配置的空闲连接超时</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">跨区负载均衡</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">粘性会话</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">静态 IP</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">弹性 IP 地址</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">保留源 IP 地址</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于资源的 IAM 权限</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">基于标签的 IAM 权限</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">慢启动</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">WebSocket</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">PrivateLink 支持</td>
<td align="center"></td>
<td align="center">✔（TCP、TLS）</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于源 IP 地址 CIDR 的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">第 7 层</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于路径的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于主机的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">本机 HTTP/2</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">重定向</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">固定响应</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Lambda 函数即目标</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于 HTTP 标头的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于 HTTP 方法的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于查询字符串参数的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">安全性</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">SSL 卸载</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">服务器名称指示 (SNI)</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">后端服务器加密</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">用户身份验证</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">自定义安全策略</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
</tbody></table>
<h1 id="AutoScaling-amp-ELB"><a href="#AutoScaling-amp-ELB" class="headerlink" title="AutoScaling &amp; ELB"></a>AutoScaling &amp; ELB</h1><ul>
<li>Auto Scaling动态添加和删除EC2实例，而Elastic Load Balancing通过优化路由流量来管理传入请求，这样就不会有任何一个实例超负荷运行</li>
<li>AUto Scaling有助于在用户需求增加时自动增加EC2实例的数量，并在需求下降时减少EC2实例的数量</li>
<li>ELB服务有助于在所有正在运行的EC2实例之间自动分配传入的Web流量</li>
<li>ELB使用负载平衡器来监控流量并处理来自Internet的请求</li>
<li>使用ELB和Auto Scaling<ul>
<li>可以轻松地在动态变化的EC2实例中路由流量</li>
<li>负载均衡器充当Auto Scaling组中实例的所有传入流量的单一连接点<br><img src="https://i.loli.net/2019/08/28/47J6cRxMrObEjwY.png" alt="Screen-Shot-2016-06-07-at-4.13.10-PM.png"></li>
</ul>
</li>
</ul>
<h2 id="Attaching-Detaching-ELB-with-Auto-Scaling-Group"><a href="#Attaching-Detaching-ELB-with-Auto-Scaling-Group" class="headerlink" title="Attaching/Detaching ELB with Auto Scaling Group"></a>Attaching/Detaching ELB with Auto Scaling Group</h2><ul>
<li>Auto Scaling与Elastic Load Balancing集成，可以将一个或多个负载均衡器连接到现有的Auto Scaling组。</li>
<li>ELB使用其IP地址注册EC2实例，并将请求路由到实例的主接口（eth0）的主IP地址。</li>
<li>连接ELB后，它会自动在组中注册实例，并在实例之间分配传入流量</li>
<li>分离ELB时，它会在取消注册组中的实例时进入“删除”状态。</li>
<li>如果启用了连接耗尽，ELB将在取消注册实例之前等待正在进行的请求完成。</li>
<li>从ELB注销实例后，实例仍在运行</li>
<li>Auto Scaling会在启动时向ELB添加实例，但这可以暂停。 在暂停期间启动的实例在恢复后不会添加到负载均衡器，并且必须手动注册。</li>
</ul>
<h2 id="High-Availability-amp-Redundancy"><a href="#High-Availability-amp-Redundancy" class="headerlink" title="High Availability &amp; Redundancy"></a>High Availability &amp; Redundancy</h2><ul>
<li>Auto Scaling可以跨越同一区域内的多个AZ</li>
<li>当一个AZ变得不健康或不可用时，Auto Scaling会在未受影响的AZ中启动新实例</li>
<li>当不健康的AZ恢复时，Auto Scaling会在所有健康的AZ中重新分配流量</li>
<li>可以设置Elastic Load balancer以在区域内的单个AZ或多个AZ中跨EC2实例分发传入请求</li>
<li>建议通过跨区域内多个AZ的Auto Scaling组使用Auto Scaling和ELB，然后设置ELB以在这些AZ之间分配传入流量，来利用地理冗余的安全性和可靠性。</li>
<li>在为ELB启用的所有AZ中，传入流量均衡负载到AZ中</li>
</ul>
<h2 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h2><ul>
<li>Auto Scaling组通过定期检查EC2实例状态检查的结果来确定每个实例的运行状况</li>
<li>如果实例未通过EC2实例状态检查，Auto Scaling会将实例标记为运行状况不佳并替换实例</li>
<li>ELB还对在其上注册的EC2实例执行健康检查，例如 ping和健康检查页面提供应用程序</li>
<li>如果ELB运行状况检查失败，则默认情况下，Auto Scaling不会替换实例</li>
<li>应使用实例的ELB运行状况检查来确保流量仅路由到正常运行的实例</li>
<li>向Auto Scaling组注册负载均衡器后，除了EC2实例状态检查之外，还可以将其配置为使用ELB运行状况检查的结果来确定Auto Scaling组中EC2实例的运行状况。</li>
</ul>
<h2 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h2><ul>
<li>Elastic Load Balancing将有关负载均衡器和EC2实例的数据发送到Amazon CloudWatch。 CloudWatch收集有关资源性能的数据，并将其显示为指标。</li>
<li>在使用Auto Scaling组注册一个或多个负载均衡器后，可以将Auto Scaling组配置为使用ELB指标（例如请求延迟或请求计数）自动扩展应用程序</li>
</ul>
<h1 id="AWS-ELB-Monitoring"><a href="#AWS-ELB-Monitoring" class="headerlink" title="AWS ELB Monitoring"></a>AWS ELB Monitoring</h1><h2 id="Cloud-Watch-Metrics"><a href="#Cloud-Watch-Metrics" class="headerlink" title="Cloud Watch Metrics"></a>Cloud Watch Metrics</h2><ul>
<li>Elastic Load Balancing向Amazon CloudWatch发布有关负载均衡器和后端实例的数据采集信息</li>
<li>仅当请求流经负载均衡器时，Elastic Load Balancing才会将指标报告给CloudWatch。 如果有请求流经负载均衡器，Elastic Load Balancing将以60秒的间隔测量并发送其指标。 如果没有请求流经负载均衡器或没有指标数据，则不会报告该指标。</li>
</ul>
<p>监控指标包含如下</p>
<ul>
<li>HealthyHostCount，UnHealthyHostCount<ul>
<li>使用负载均衡器注册的健康和不健康实例的数量</li>
<li>统计数据是平均值，最小值和最大值</li>
</ul>
</li>
<li>RequestCount<ul>
<li>在指定的时间间隔内（1或5分钟）完成的请求数或连接数</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>latency<ul>
<li>请求离开负载均衡器之后经过的时间（以秒为单位），直到收到响应的标头</li>
<li>统计数据是平均值</li>
</ul>
</li>
<li>SurgeQueueLength<ul>
<li>待处理路由的请求总数</li>
<li>如果请求无法与正常实例建立连接以便路由请求，则负载均衡器会对请求进行排队</li>
<li>队列的最大大小为1,024。队列已满时，将拒绝其他请求。</li>
<li>统计信息是max，因为它表示排队请求的峰值</li>
</ul>
</li>
<li>SpilloverCount<ul>
<li>由于浪涌队列已满而被拒绝的请求总数。理想情况下应为0</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>HTTPCode_ELB_4XX，HTTPCode_ELB_5XX<ul>
<li>负载均衡器生成的客户端和服务器错误代码</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>HTTPCode_Backend_2XX，HTTPCode_Backend_3XX，HTTPCode_Backend_4XX，HTTPCode_Backend_5XX<ul>
<li>已注册实例生成的HTTP响应代码数</li>
<li>统计数据是总和</li>
</ul>
</li>
</ul>
<h2 id="ELB-访问日志"><a href="#ELB-访问日志" class="headerlink" title="ELB 访问日志"></a>ELB 访问日志</h2><ul>
<li>Elastic Load Balancing提供访问日志，可捕获有关发送到负载均衡器的所有请求的详细信息</li>
<li>每个日志都包含诸如接收请求的时间，客户端的IP地址，延迟，请求路径和服务器响应之类的信息。<br>Elastic Load Balancing捕获日志并将其存储在Amazon S3存储桶中</li>
<li>默认情况下禁用访问日志记录，无需任何额外费用即可启用。 只需支付S3存储费用</li>
</ul>
<h2 id="Cloud-Trail-日志"><a href="#Cloud-Trail-日志" class="headerlink" title="Cloud Trail 日志"></a>Cloud Trail 日志</h2><ul>
<li>AWS CloudTrail可用于捕获由AWS账户或代表AWS账户制作的Elastic Load Balancing API的所有调用，并且可以直接使用Elastic Load Balancing API，也可以通过AWS管理控制台或AWS CLI间接调用</li>
<li>CloudTrail将信息作为日志文件存储在指定的Amazon S3存储桶中。</li>
<li>CloudTrail收集的日志可用于监控负载均衡器的活动，并确定进行的API调用，使用的源IP地址，拨打电话的人员，拨打电话的时间等等。</li>
</ul>
<h1 id="Classic-Load-Balancer-vs-Application-Load-Balancer"><a href="#Classic-Load-Balancer-vs-Application-Load-Balancer" class="headerlink" title="Classic Load Balancer vs Application Load Balancer"></a>Classic Load Balancer vs Application Load Balancer</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>CLB是跨多个EC2实例的流量的简单负载平衡的理想选择，</li>
<li>ALB是微服务或基于容器的体系结构的理想选择，在这种体系结构中，需要将流量路由到多个服务或在同一EC2实例上的多个端口之间进行负载平衡。</li>
</ul>
<p><img src="https://i.loli.net/2019/08/28/oiZSxfG1CDlRYVb.png" alt="AWS-ELB-Classic-Load-Balancer-vs-Application-Load-Balancer.png"></p>
<h2 id="支持协议"><a href="#支持协议" class="headerlink" title="支持协议"></a>支持协议</h2><ul>
<li>CLB在第4层运行，支持HTTP，HTTPS，TCP，SSL，而Application Load Balancer在第7层运行，支持HTTP，HTTPS，HTTP / 2，WebSockets</li>
<li>如果需要第4层功能，则应使用CLB</li>
</ul>
<h2 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h2><ul>
<li>CLB 支持EC2-Classic和EC2-VPC，而ALB仅支持EC2-VPC</li>
</ul>
<h2 id="Stick-Sessions（Cookies）"><a href="#Stick-Sessions（Cookies）" class="headerlink" title="Stick Sessions（Cookies）"></a>Stick Sessions（Cookies）</h2><ul>
<li>Stick Sessions（粘性会话）使负载均衡器能够将用户的会话绑定到特定实例，从而确保会话期间来自用户的所有请求都发送到同一个实例</li>
<li>Classic和Application Load Balancer都支持粘性会话以保持会话亲和性</li>
</ul>
<h2 id="空闲连接超时-1"><a href="#空闲连接超时-1" class="headerlink" title="空闲连接超时"></a>空闲连接超时</h2><ul>
<li>空闲连接超时有助于指定一个时间段，如果在空闲超时时间过去之前没有数据发送或接收，ELB将使用该时间段来关闭连接</li>
<li>Classic和Application Load Balancer都支持空闲连接超时</li>
</ul>
<h2 id="连接耗尽-1"><a href="#连接耗尽-1" class="headerlink" title="连接耗尽"></a>连接耗尽</h2><ul>
<li>连接耗尽使负载均衡器能够完成对取消注册或不健康的实例的正在进行的请求</li>
<li>Classic和Application Load Balancer都支持连接耗尽</li>
</ul>
<h2 id="SSL终止"><a href="#SSL终止" class="headerlink" title="SSL终止"></a>SSL终止</h2><ul>
<li>CLB和ALB都支持SSL终端，以便在将客户端发送到目标之前对其进行解密，从而减轻负载。 必须在负载均衡器上安装SSL证书。</li>
</ul>
<h2 id="后端服务器身份验证"><a href="#后端服务器身份验证" class="headerlink" title="后端服务器身份验证"></a>后端服务器身份验证</h2><ul>
<li>后端服务器身份验证允许对实例进行身份验证。 仅当实例提供给负载均衡器的公钥与负载均衡器的身份验证策略中的公钥匹配时，负载均衡器才与实例通信。</li>
<li>CLB器支持，而应用程序负载均衡器不支持后端服务器身份验证 </li>
</ul>
<h2 id="跨区域负载平衡"><a href="#跨区域负载平衡" class="headerlink" title="跨区域负载平衡"></a>跨区域负载平衡</h2><ul>
<li>跨区域负载平衡有助于在其启用的AZ中的所有实例之间均匀分配传入请求。 默认情况下，Load Balancer将在其启用的AZ上均匀分布请求，而不管其承载的实例如何。</li>
<li>Classic和Application Load Balancer都支持跨区域负载平衡，但是对于Classic，需要启用它，而对于ALB，它始终启用</li>
</ul>
<h2 id="健康检查-1"><a href="#健康检查-1" class="headerlink" title="健康检查"></a>健康检查</h2><ul>
<li>Classic和Application Load Balancer都支持运行状况检查，以确定实例是健康的还是不健康的<br>ALB提供运行状况检查改进，允许配置200-399的详细错误代码</li>
</ul>
<h2 id="CloudWatch指标"><a href="#CloudWatch指标" class="headerlink" title="CloudWatch指标"></a>CloudWatch指标</h2><ul>
<li>Classic和Application Load Balancer都与CloudWatch集成以提供指标，ALB提供额外的指标</li>
</ul>
<h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><ul>
<li>访问日志捕获有关发送到负载均衡器的请求的详细信息。 每个日志都包含诸如接收请求的时间，客户端的IP地址，延迟，请求路径和服务器响应之类的信息</li>
<li>Classic和Application Load Balancer都提供访问日志，ALB提供其他属性</li>
</ul>
<h2 id="基于主机的路由和基于路径的路由"><a href="#基于主机的路由和基于路径的路由" class="headerlink" title="基于主机的路由和基于路径的路由"></a>基于主机的路由和基于路径的路由</h2><ul>
<li>基于主机的路由使用主机条件来定义根据主机头中的主机名将请求转发到不同目标组的规则。 这使ALB能够使用单个负载均衡器支持多个域。</li>
<li>基于路径的路由使用路径条件来定义基于请求中的URL将请求转发到不同目标组的规则。 每个路径条件都有一个路径模式。 如果请求中的URL与侦听器规则中的路径模式完全匹配，则使用该规则路由请求。<br>只有ALB支持基于主机和路径的路由。</li>
</ul>
<h2 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h2><ul>
<li>只有ALB支持使用ECS进行动态端口映射，这允许两个服务容器在动态端口上的单个服务器上运行，ALB自动检测并重新配置自身。</li>
</ul>
<h2 id="删除保护"><a href="#删除保护" class="headerlink" title="删除保护"></a>删除保护</h2><ul>
<li>只有ALB支持删除保护，如果启用了删除保护，则无法删除负载均衡器</li>
</ul>
<h2 id="请求跟踪"><a href="#请求跟踪" class="headerlink" title="请求跟踪"></a>请求跟踪</h2><ul>
<li>只有ALB支持请求跟踪来跟踪从客户端到目标或其他服务的HTTP请求。</li>
</ul>
<h2 id="VPC中的IPv6"><a href="#VPC中的IPv6" class="headerlink" title="VPC中的IPv6"></a>VPC中的IPv6</h2><ul>
<li>只有ALB在VPC中支持IPv6</li>
</ul>
<h2 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h2><ul>
<li>只有ALB支持AWS WAF，可以直接在VPC中的ALB（内部和外部）上使用，以保护网站和Web服务</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/26/札记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/札记/" itemprop="url">札记</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T19:23:57+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数字化转型（金融）"><a href="#数字化转型（金融）" class="headerlink" title="数字化转型（金融）"></a>数字化转型（金融）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="left"><strong>信息化模型</strong></th>
<th align="left"><strong>数字化模型</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用模式</td>
<td align="left">专线支持的网点、ATM、POS机等客户场景</td>
<td align="left">互联网生态及自有APP的用户场景、无人银行</td>
</tr>
<tr>
<td align="center">人员思维</td>
<td align="left">项目经理思维，架构师思维</td>
<td align="left">产品思维、数据思维</td>
</tr>
<tr>
<td align="center">产品形态</td>
<td align="left">以金融机构为视角的专业化产品</td>
<td align="left">以客户体验为核心的生态化产品</td>
</tr>
<tr>
<td align="center">开发模式</td>
<td align="left">基于完整需求进行瀑布式开发</td>
<td align="left">基于体验点进行敏捷开发</td>
</tr>
<tr>
<td align="center">合作模式</td>
<td align="left">业务部门定义产品，科技部门实现产品</td>
<td align="left">业务部门和科技部门共同定义产品</td>
</tr>
<tr>
<td align="center">团队组织</td>
<td align="left">由项目经理、架构师、领域开发人员组成的开发中心、测试中心、数据中心</td>
<td align="left">包含项目经理、产品经理、全栈开发组成</td>
</tr>
<tr>
<td align="center">技术平台</td>
<td align="left">自建、私有云</td>
<td align="left">自建+ 租用 私有云+公有云</td>
</tr>
<tr>
<td align="center">数据架构</td>
<td align="left">大数据</td>
<td align="left">数据湖</td>
</tr>
<tr>
<td align="center">应用架构</td>
<td align="left">MVC/三层</td>
<td align="left">现代化应用</td>
</tr>
<tr>
<td align="center">开发运维工具</td>
<td align="left">开发工具/运维工具</td>
<td align="left">DevOps、AIoPS</td>
</tr>
<tr>
<td align="center">自动化程度</td>
<td align="left">实现“人管机器”的技术自动化</td>
<td align="left">业务自动化</td>
</tr>
</tbody></table>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><ul>
<li>I/O路经长</li>
<li>latency 大（网络抖动、多副本处理）</li>
</ul>
<p>优化时延主要方法：</p>
<ul>
<li>硬件升级，诸如NVME、RDMA</li>
<li>优化I/O路径，通信框架</li>
<li>优化每个模块的处理时间</li>
<li>优化磁盘布局</li>
<li>增加数据缓存层</li>
</ul>
<h4 id="数据仓库-vs-数据湖"><a href="#数据仓库-vs-数据湖" class="headerlink" title="数据仓库 vs 数据湖"></a>数据仓库 vs 数据湖</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据</td>
<td align="left">来自食物系统、运营数据库、业务应用程序</td>
<td align="left">IoT设备、网络、移动应用程序、社交媒体（非关系）</td>
</tr>
<tr>
<td align="center">Schema</td>
<td align="left">写入型Schema</td>
<td align="left">写入分析时（读取型 Schema）</td>
</tr>
<tr>
<td align="center">性价比</td>
<td align="left">更快查询结果成本高</td>
<td align="left">更快查询结果较低存储成本</td>
</tr>
<tr>
<td align="center">数据质量</td>
<td align="left">可作为重要事实依据的高度监管数据</td>
<td align="left">任何可以或无法进行监管数据</td>
</tr>
<tr>
<td align="center">用户</td>
<td align="left">业务分析师</td>
<td align="left">数据科学家、数据开发人员和业务分析师</td>
</tr>
<tr>
<td align="center">分析</td>
<td align="left">批处理、BI、可视化</td>
<td align="left">机器学习、预测成本、数据发现和分析</td>
</tr>
</tbody></table>
<blockquote>
<p>数据湖概念：</p>
</blockquote>
<p> <em>在保障数据持久性和安全性的前提下，存储任何量级的各种数据（结构化、非结构化、半结构化），并对其运用不同的分析手段（查询、统计、挖掘），以获得数据内在价值并指导业务发展</em></p>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><ul>
<li>InnoDB的行锁匙实现在索引上的</li>
<li>并发控制保证数据一致性常见手段<ul>
<li>锁（locking）</li>
<li>数据多版本（multi versioning）</li>
</ul>
</li>
<li>共享锁（share lock ）,读数据枷锁</li>
<li>排他锁（exclusive lock），修改数据加X锁</li>
<li>写事务未提交，读相关数据select阻塞</li>
<li>由锁机制延伸出数据多版本</li>
</ul>
<p>核心原理</p>
<ul>
<li>写任务发生时，将数据克隆一份，以版本号区别</li>
<li>写人物操作新克隆的数据，直至提交</li>
<li>并发读可以继续读取旧版本数据，不至于阻塞</li>
</ul>
<ul>
<li>普通锁串行，读写锁读读并行，数据多版本读写并行</li>
<li>Redo日志保证已提交事务的ACID特性，设计思路是通过顺序写代替随机写，提高并发</li>
<li>redo 日志保证未提交事务的ACID特性，存储在回滚段中</li>
<li>InnoDB是基于MVCC的存储引擎，利用存储在回滚段里undo日志，即数据的旧版本提高并发 </li>
<li>InnoDB 之所以并发高，快照读不加锁</li>
<li>InnoDB 所有的普通Select 都是快照读</li>
</ul>
<p>InnoDB 存储引擎</p>
<ol>
<li>重做日志 redo log 用于实力故障恢复是，继续那些已经commit 但尚未完全回写到磁盘的事务</li>
<li>回滚日志 undo log 用于在实例故障恢复时，借助undo log将尚未commit的食物，回滚到事务开始前的状态</li>
</ol>
<p>总结：redo log 可以保证事务的原子性和持久性，undo log可以保证事务的一致性（事务的隔离性是由锁来实现的）<br>redo和undo 都可以视作一种恢复操作，redo恢复提交事务修改的页操作，记录的内容是物理日志，记录的是页的物理修改操作；而undo回滚行记录到某个特定的版本，记录的是逻辑日志，根据每行记录进行记录。</p>
<p>数据库索引</p>
<ol>
<li>B+ 树 数据结构：高度平衡的多叉树，叶子节点保存所有数据。（注意B+树的非聚集索引的叶子节点并不是直接存放的给定键值的行，而是数据行所在的页，然后数据库通过把页读入内存，再在内存中查找）</li>
<li>B+ 树数据结构应用在数据库的索引实现中，具有高度的扇出性，一般B+树的高度都在2～4层，也就是说查找某一键值的行记录时最多只需要2～4此IO</li>
</ol>
<p>B+树索引可以分为聚集索引（主键索引，已主键作为key的索引）和辅助索引（非聚集索引）。</p>
<ul>
<li>聚集索引的叶子节点保存的是数据，即行记录；</li>
<li>InnoDB的主键索引的排序查找和范围查找非常快；</li>
</ul>
<p>InnoDB的数据文件本身就是索引文件。MyISAM索引文件爱你和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引仅够，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引data域存储相应记录主键的值而不是地址，InnoDB的所有辅助索引引用主键作为data域。<br>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两边索引：首先检索辅助索引获得主键，然后哦用主键到主索引中检索获得记录。</p>
<p>数据库事务隔离级别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>隔离级别</strong></td>
<td align="left"><strong>脏读（Dirty Read）</strong></td>
<td align="left"><strong>不可重复读（NonRepeattable Read）</strong></td>
<td align="left"><strong>幻读（Phantom Read）</strong></td>
</tr>
<tr>
<td align="left">未提交读 （Read uncommited）</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">已提交读（Read commited）</td>
<td align="left">不可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可重复读（Repeatable read）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可串行化（Serializable）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
</tr>
</tbody></table>
<ul>
<li>未提交读（Read Uncommited）：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读（Read Committed）：只能读取到已经提交的数据。Oracle等多数据默认都是该级别（不重复读）</li>
<li>可重复读（RepeatedRead）：可重复读。在同一个事务内的查询都是事务开始时刻是一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻想读。</li>
<li>串行读（Serializable）：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<p>MySQL尽量避免使用NULL（空值）列，其使得索引、索引统计和值都比较复杂</p>
<ul>
<li>MySql 复制上的读/写分离<ul>
<li>由于备库是异步的，主要的难点是如何处理备库上的脏数据</li>
<li>常见读/写分离方法如下：<ul>
<li>基于查询分离：将所有不能容忍脏数据的读和写查询分配到主服务器上，其他读查询分配到备库上</li>
<li>基于脏数据分离：通过应用检查复制延迟，以确定备库数据是否太旧。</li>
<li>基于会话分离：判断用户是否修改了数据。在会话层设置标记位，表明做了更新，就将该用户的查询在一段时间内总是指向主库。</li>
<li>基于版本分离：跟踪对象的版本号以及或时间戳，通过从备库读取对象的版本或时间戳判断数据是否足够新</li>
<li>基于全局版本/会话分离：应用执行写操作是，在提交事务后，执行一次show master status，然后在缓存中存储主库日志坐标，作为被修改对象以及或会话版本号。当应用连接到备库时，执行show slave status并将备库上的坐标和缓存中的版本号相比。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Apache WEB 处理动态内容</p>
<ul>
<li>Apache 通常是通过prefork配置来使用mod_php、mod_perl和mod_python模块，prefork模式会为每个请求预分配进程。</li>
<li>PHP、Perl和Python脚本是可以定制化的，每个进程使用50Mb或100MB内存</li>
</ul>
<p>lightttpd、nginx擅长处理静态内容，Tomcat处理动态内容</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/26/AWS-Route-53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/AWS-Route-53/" itemprop="url">AWS Route 53</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T19:15:38+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Amazon Route 53 是一种具有很高可用性和可扩展性的域名系统 (DNS) Web 服务。可以使用 Route 53 以任意组合执行三个主要功能：域注册、DNS 路由和运行状况检查。</p>
<ol>
<li><p>域名注册</p>
</li>
<li><p>将Internet路由到域名</p>
<ul>
<li>域名解析到正确的IP地址</li>
<li>使用权威DNS服务器的全局网络响应DNS查询，从而减少延迟</li>
<li>将Internet流量路由到CloudFront，Elastic Beanstalk，ELB或S3。 对这些资源进行DNS查询是免费的</li>
</ul>
</li>
<li><p>检查资源的运行状况</p>
<ul>
<li>可以监控Web和电子邮件服务器等资源的运行状况。</li>
<li>通过Internet向应用程序发送自动请求</li>
<li>验证它是否可访问，可用且功能正常</li>
<li>可以为运行状况检查配置CloudWatch警报，以便在资源不可用时发送通知。</li>
<li>可以配置为将Internet流量路由远离不可用的资源</li>
</ul>
<h2 id="支持的DNS记录类型"><a href="#支持的DNS记录类型" class="headerlink" title="支持的DNS记录类型"></a>支持的DNS记录类型</h2></li>
</ol>
<ul>
<li><p>A（IPv4地址记录）</p>
</li>
<li><p>AAAA（IPv6 地址记录）</p>
</li>
<li><p>CNAME（规范名称记录）</p>
<ul>
<li>格式与域名相同</li>
<li>DNS协议不允许为DNS命名空间的顶级节点创建CNAME记录，也称为区域顶点（例如，区域顶点）。 DNS名称example.com注册，区域顶点是example.com，无法创建example.com的CNAME记录，但可以为<a href="http://www.example.com，newproduct.example.com等创建CNAME记录。" target="_blank" rel="noopener">www.example.com，newproduct.example.com等创建CNAME记录。</a></li>
<li>如果为子域创建了CNAME记录，则无法为该子域创建该子域的任何其他资源记录集。如果为<a href="http://www.example.com创建了CNAME，而不是可以创建名称字段值为www.example.com的其他资源记录集" target="_blank" rel="noopener">www.example.com创建了CNAME，而不是可以创建名称字段值为www.example.com的其他资源记录集</a></li>
</ul>
</li>
<li><p>CAA (认证机构授权)</p>
</li>
<li><p>MX (邮件交换记录)</p>
</li>
<li><p>NAPTR（命名授权指针记录）</p>
</li>
<li><p>NS（名称服务器记录）</p>
<ul>
<li>NS记录标识托管区域的名称服务器。 NS记录的值是名称服务器的域名。</li>
</ul>
</li>
<li><p>PTR（指针记录）</p>
</li>
<li><p>SOA（起始授权记录）</p>
</li>
<li><p>SPF（发件人策略框架）</p>
</li>
<li><p>SRV（服务定位器）</p>
</li>
<li><p>TXT（文本记录）</p>
</li>
<li><p>Amazon Route 53 还提供别名记录，这些记录是 Amazon Route 53 专用的 DNS 扩展。</p>
</li>
</ul>
<h2 id="Alias-记录类型"><a href="#Alias-记录类型" class="headerlink" title="Alias 记录类型"></a>Alias 记录类型</h2><ul>
<li>Route　53支持别名资源记录集，可以将查询路由到CloudFront分配，Elastic Beanstalk，ELB，配置为静态网站的S3存储桶或其他Route 53资源记录集</li>
<li>别名记录不是DNS RFC的标准，是Route 53的扩展功能</li>
<li>别名记录类似于CNAME记录，但可以为根域或顶点域、子域创建别名记录，而cname只能用于记录子域</li>
<li>Route 53自动识别别名记录资源所引用的资源记录的变化，如对于指向ELB的指导年，若负载均衡的IP发生变化，则Route 53将自动在DNS的回应中反映这些变化，而不对包含资源记录集的托管区域进行任何更改</li>
<li>若alias记录集指向CloudFront、ELB或S3，则无法设置TTL；Route 53使用cloudfront、LB或者S3的TTL</li>
</ul>
<table>
<thead>
<tr>
<th>NAME 记录</th>
<th>别名记录</th>
</tr>
</thead>
<tbody><tr>
<td>CNAME 记录可以将 DNS 查询重定向到任何 DNS 记录。例如，可以创建一条 CNAME 记录，该记录将查询从 acme.example.com 重定向到 zenith.example.com 或 acme.example.org。不需要使用 Route 53 作为您要将查询重定向到的域的 DNS 服务。</td>
<td>别名记录只能将查询重定向到选定的 AWS 资源，例如：Amazon S3 存储桶 ;CloudFront 分配;其中创建别名记录的 Route 53 托管区域中的其他记录;例如，可以创建一个名为 acme.example.com 的别名记录，该记录将查询重定向到 Amazon S3 存储桶（也称为 acme.example.com.）。还可以创建一个 acme.example.com 别名记录，该记录将查询重定向到 example.com 托管区域中名为 zenith.example.com 的记录。</td>
</tr>
<tr>
<td>不能创建与托管区域（区域 APEX）同名的 CNAME 记录。对于域名 (example.com) 的托管区域和子域 (zenith.example.com) 的托管区域都是如此。</td>
<td>在大多数配置中，您可以创建一个与托管区域（区域 APEX）同名的别名记录。一个例外情况是，当您要将来自区域 APEX（如 example.com）的查询重定向到具有类型 CNAME（如 zenith.example.com）的同一托管区域中的记录时。别名记录必须与您要将流量路由到的目标记录具有相同的类型，而为顶级域名创建 CNAME 记录的做法不受支持，即使对于别名记录也是如此。</td>
</tr>
<tr>
<td>Route 53 收取 CNAME 查询费用。</td>
<td>对于 AWS 资源的别名查询，Route 53 不收费。有关更多信息，请参阅 Amazon Route 53 定价。</td>
</tr>
<tr>
<td>无论记录类型如何，CNAME 记录都会重定向对记录名称（如 A 或 AAAA）的 DNS 查询。</td>
<td>仅当别名记录的名称（如 acme.example.com）和别名记录的类型（如 A 或 AAAA）与 DNS 查询中的名称和类型匹配时，Route 53 才响应 DNS 查询。</td>
</tr>
<tr>
<td>CNAME 记录在响应 dig 或 nslookup 查询时显示为 CNAME 记录。</td>
<td>别名记录显示为您在创建记录时指定的记录类型，例如 A 或 AAAA。别名属性仅在 Route 53 控制台中或在响应以编程方式发出的请求时可见，例如 AWS CLI list-resource-record-sets 命令。</td>
</tr>
</tbody></table>
<h2 id="托管区域"><a href="#托管区域" class="headerlink" title="托管区域"></a>托管区域</h2><ul>
<li>托管区域是一个记录容器，记录中包含的信息说明您希望如何路由特定域（如 example.com）及其子域（acme.example.com、zenith.example.com）的流量。</li>
<li>管区域与相应域具有相同的名称。</li>
<li>有两种类型的托管区域：<ul>
<li>公有托管区域 包含指定了如何路由 Internet 流量的记录。</li>
<li>私有托管区域 包含指定了如何在 Amazon VPC 中路由流量的记录。</li>
</ul>
</li>
<li>在托管区域中创建记录<ul>
<li>记录定义了为每个域名或子域名路由路由的位置。</li>
<li>托管区域中每条记录的名称必须以托管区域的名称结尾。</li>
</ul>
</li>
</ul>
<h2 id="Route-53-Split-view-Split-horizon-DNS"><a href="#Route-53-Split-view-Split-horizon-DNS" class="headerlink" title="Route 53 Split-view(Split-horizon) DNS"></a>Route 53 Split-view(Split-horizon) DNS</h2><ul>
<li>允许公开使用的相同域名访问网站的内部版本</li>
<li>使用Route 53 Spilt-view 为DNS维护具有相同域名的私有和公共托管区域</li>
<li>确保在VPC上启用DNS解析和DNS主机名</li>
<li>DNS查询将根据请求的来源回答答案。 在VPC内，答案将来自私有托管区域，而公共查询将从公共托管区域返回答案。</li>
</ul>
<h1 id="DNS-路由策略"><a href="#DNS-路由策略" class="headerlink" title="DNS 路由策略"></a>DNS 路由策略</h1><h2 id="简单路由策略"><a href="#简单路由策略" class="headerlink" title="简单路由策略"></a>简单路由策略</h2><ul>
<li>简单路由策略是一种简单的循环策略，可以在有单个资源为域执行功能时应用。如为网站提供内容的服务器</li>
<li>AWS Route 53基于资源记录集中的值来响应DNS查询。 如A记录中的IP地址</li>
</ul>
<h2 id="加权轮询（WRR）"><a href="#加权轮询（WRR）" class="headerlink" title="加权轮询（WRR）"></a>加权轮询（WRR）</h2><ul>
<li>加权路由策略使路由53能够以指定的比例（权重）将流量路由到不同的资源，例如，75％的一个服务器和25％的另一个服务器</li>
<li>可以为权重指定0到255之间的任何数字</li>
<li>当存在多个执行相同功能的资源（例如，服务于相同站点的web服务器）时，可以应用加权路由策略</li>
<li>加权资源记录集允许您将多个资源与单个DNS名称相关联</li>
<li>常见用例包括<ul>
<li>负载均衡</li>
<li>A / B测试和试用新版软件</li>
</ul>
</li>
<li>创建一组加权资源记录集，可以创建具有相同DNS名称和类型组合的两个或更多资源记录集，并且为每个资源记录集分配唯一标识符和相对权重</li>
<li>处理DNS查询时，Route 53搜索具有指定名称和类型的资源记录集或一组资源记录集</li>
<li>Route 53从组中选择一个。选择任何一个资源记录集的概率取决于其权重作为该组中所有资源记录集的总权重的比例，例如，假设<a href="http://www.example.com具有三个权重为1的资源记录集（20％）" target="_blank" rel="noopener">www.example.com具有三个权重为1的资源记录集（20％）</a> ），1（20％）和3（60％）（总和= 5）。平均而言，Route 53在五分之一的时间中选择前两个资源记录集中的每一个，并且返回三分之三的时间的第三资源记录集。</li>
</ul>
<h2 id="基于延迟的路由（LBR）"><a href="#基于延迟的路由（LBR）" class="headerlink" title="基于延迟的路由（LBR）"></a>基于延迟的路由（LBR）</h2><ul>
<li>基于延迟的路由策略使Route 53能够根据哪个数据中心为用户提供最低的网络延迟来响应DNS查询</li>
<li>当有多个资源执行相同的功能时，可以使用基于延迟的路由策略，并且Route 53需要配置为使用提供最快响应和最低延迟的资源来响应DNS查询</li>
<li>可以为托管应用程序的每个区域中的EC2资源创建延迟资源记录集。当Route 53收到对应域的查询时，它会选择为EC2区域设置的延迟资源记录，为用户提供最低延迟。然后，Route 53以与该资源记录集相关联的值进行响应，例如，您能在爱尔兰和东京的EC2数据中心中具有example.com的Web服务器。当用户从新加坡浏览example.com时，Route 53将从用户位置获取具有最低延迟的数据中心（东京）</li>
<li><strong>由于网络连接和路由的变化，Internet上主机之间的延迟可能会随着时间的推移而发生变化。基于延迟的路由基于在一段时间内执行的等待时间测量，并且测量结果反映了这些变化。</strong>如果新加坡用户到爱尔兰的延迟有所改善，用户可以路由到爱尔兰</li>
<li>基于延迟的路由不能保证来自相同地理位置的用户出于任何合规性原因将从同一位置提供服务</li>
<li>可以使用Route 53支持的除NS或SOA之外的任何记录类型来创建延迟资源记录集</li>
</ul>
<h2 id="故障转移策略（Failover）"><a href="#故障转移策略（Failover）" class="headerlink" title="故障转移策略（Failover）"></a>故障转移策略（Failover）</h2><ul>
<li>故障转移路由策略允许主动 - 被动故障转移配置，其中一个资源在可用时占用所有流量，而另一个资源在第一个资源不可用时占用所有流量。</li>
<li>Route 53运行状况检查代理将监视应用程序的每个位置/端点以确定可用性。</li>
<li>故障转移路由策略仅适用于公共托管区域</li>
</ul>
<h2 id="地理位置路由策略（Geo-DNS）"><a href="#地理位置路由策略（Geo-DNS）" class="headerlink" title="地理位置路由策略（Geo DNS）"></a>地理位置路由策略（Geo DNS）</h2><ul>
<li>地理位置路由策略使路由53能够根据用户的地理位置（即DNS查询源自的位置）响应DNS查询</li>
<li>常见用例包括<ul>
<li>内容的本地化和以用户语言呈现部分或全部网站</li>
<li>限制内容的分发仅限于您拥有发行权的位置。</li>
<li>以可预测，易于管理的方式平衡端点之间的负载，以便每个用户位置始终路由到同一端点。</li>
</ul>
</li>
<li>地理位置路由策略允许按洲，国家或州（仅在美国）指定地理位置</li>
<li>地理定位记录集，如果创建的话，用于例如重叠的地理区域。非洲大陆，然后是同一大洲的国家，优先考虑最小的地理区域，这允许将一个大陆的一些查询路由到一个资源，并查询该大陆上的选定国家的不同资源</li>
<li>地理定位的工作原理是将IP地址映射到位置，这些位置可能未映射到确切的地理位置</li>
<li>可以创建默认资源记录集来处理这些查询，也可以创建没有创建显式记录集的查询</li>
<li>如果未创建默认资源记录集，则Route 53对来自这些位置的查询返回“无应答”响应</li>
<li>无法创建指定相同地理位置的两个地理位置资源记录集</li>
<li>Route 53支持EDNS0的edns-client-subnet扩展（EDNS0为DNS协议添加了几个可选扩展。）以提高地理定位路由的准确性</li>
</ul>
<h1 id="AWS-Route-53-Resolver"><a href="#AWS-Route-53-Resolver" class="headerlink" title="AWS Route 53 Resolver"></a>AWS Route 53 Resolver</h1><h2 id="解析VPC和本地网络之间的DNS查询"><a href="#解析VPC和本地网络之间的DNS查询" class="headerlink" title="解析VPC和本地网络之间的DNS查询"></a>解析VPC和本地网络之间的DNS查询</h2><ul>
<li>Route 53 Resolver在VPC内提供自动DNS解析</li>
<li>默认情况下，Resolver会回答VPC域名的DNS查询，例如EC2实例或ELB负载均衡器的域名</li>
<li>Resolver对所有其他域名的公共名称服务器执行递归查找</li>
<li>但是，本地实例无法解析Route 53 DNS条目，而Route 53无法解析本地DNS条目</li>
<li>可以通过Direct Connect或VPN连接配置AWS VPC与本地网络之间的DNS解析</li>
<li>Route 53 Resolver是区域性的</li>
<li>要使用入站或出站转发，请在VPC中创建解析器端点</li>
<li>作为端点定义的一部分，指定要将入站DNS查询转发到的IP地址或要从其发出的出站查询的IP地址。 对于指定的每个IP地址，Resolver会自动创建VPC弹性网络接口</li>
</ul>
<h2 id="将-DNS-查询从网络上的解析程序转发到-Route-53-解析程序"><a href="#将-DNS-查询从网络上的解析程序转发到-Route-53-解析程序" class="headerlink" title="将 DNS 查询从网络上的解析程序转发到 Route 53 解析程序"></a>将 DNS 查询从网络上的解析程序转发到 Route 53 解析程序</h2><p><img src="https://i.loli.net/2019/08/26/7PEZxyOBLbNWR3h.png" alt="Resolver-inbound-endpoint.png"></p>
<ul>
<li>本地网络上的DNS解析器可以将DNS查询转发到指定VPC中的解析器。</li>
<li>这使DNS解析器能够轻松解析AWS资源的域名，例如EC2实例或Route 53私有托管区域中的记录。</li>
</ul>
<h2 id="将查询从-VPC-有条件地转发到您网络上的解析程序"><a href="#将查询从-VPC-有条件地转发到您网络上的解析程序" class="headerlink" title="将查询从 VPC 有条件地转发到您网络上的解析程序"></a>将查询从 VPC 有条件地转发到您网络上的解析程序</h2><p><img src="https://i.loli.net/2019/08/26/UPLo5bKJQHVxmIw.png" alt="Resolver-outbound-endpoint.png"></p>
<ul>
<li>配置解析程序，将它从 VPC中EC2实例收到的查询转发到您网络上的 DNS 解析程序</li>
<li>要转发选定的查询，可以创建解析程序规则，指定要转发的 DNS 查询的域名（例如 example.com），以及希望将查询转发到网络上的 DNS 解析程序的 IP 地址</li>
<li>如果查询与多个规则匹配（example.com、acme.example.com），解析程序会选择匹配最具体的规则 (acme.example.com) 并将查询转发到该规则中指定的IP地址</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/22/AWS-Storage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/AWS-Storage/" itemprop="url">AWS Storage</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T21:21:37+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://i.loli.net/2019/08/20/S5pGc6xsHIB8MlZ.jpg" alt="AWS——Storage (2).jpeg"></p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><blockquote>
<p>AWS提供多种基于云的存储选择，每个服务都具有独特的性能、持久性、可用性、成本和接口，以及其他特性(如可伸缩性和弹性)。在选择存储服务请考虑其适应场景和Anti-Patterns（不推荐）模式。（可参考下图）</p>
</blockquote>
<p><img src="https://i.loli.net/2019/08/20/17jtOg8lUSsuWQH.png" alt="002.png"><br><em>本文以下内容不涉及EC2 Instancestore、CloudFront、RDS、ElasticeCache等有关数据的存储，主要是以独立的存储服务提供数据存储与管理的服务组件，因为如instancestore是临时性的，在EC2的生命周期结束之后数据就会被删除，而RDS数据库的数据处理引擎和存储有着比较紧密的耦合度（不是指不可分离），不在这里阐述.</em></p>
<h1 id="S3-对象存储"><a href="#S3-对象存储" class="headerlink" title="S3(对象存储)"></a>S3(对象存储)</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>高度可扩展，可靠且低延迟的数据存储基础架构，成本极低。</li>
<li>通过一个简单的Web服务接口，可以在<font color="red">任何时间</font>从EC2内或Web上的<font color="red">任何位置</font>存储和检索<font color="red">任何数量</font>的数据。</li>
<li>write、read、delete等操作，每个对象大小1byte~5TB之间。</li>
<li>S3 bucket中的对象数量可以理解为无限的。</li>
<li>强安全控制，支持静态加密，并提供多种机制来提供对Amazon S3资源访问的细粒度控制（ACL、Policy、IAM）。</li>
<li>可扩展，允许许多单独的客户端或应用程序线程对Amazon S3数据进行并发读取或写入访问。</li>
<li>提供数据生命周期管理功能，允许用户定义规则以自动将Amazon S3数据存档到Amazon Glacier，或者在生命周期结束时删除数据。</li>
</ul>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>存储和分发静态web内容和媒体<ul>
<li>静态网站托管，并仅为具有静态内容的网站提供高度可用、可扩展的解决方案，支持HTML、图像、视频和客户端脚本（如javascript）。</li>
<li>适用于快速增长的互联网网站，托管密集型数据，如视频、照片共享网站（Instagram，不需要考虑存储的供给问题）</li>
<li>每一个content都可以通过对象的唯一HTTP URL访问。</li>
<li>作为CDN溯源（Origin）站点，如搭配CloudFront会有更好的效果</li>
<li>借助S3的弹性设计，非常适合承载带宽要求极高的web内容</li>
</ul>
</li>
<li>大型对象数据存储<ul>
<li>可以与RDS或NoSQL数据库配合，用于存储大型对象，例如 文件或对象，而关联的元数据例（如名称，标签，注释等）可以存储在RDS或NoSQL数据库中，可以对其进行索引和查询，从而更快地访问相关数据。（对象存储系统并不像文件系统一样有自己的索引机制，所以其访问实际是由独立的URL实现的。）</li>
</ul>
</li>
<li>计算和大规模分析的数据存储（计算之后）<ul>
<li>通常用作计算和大规模分析的数据存储，例如金融交易分析，点击流分析（网站）和媒体转码数据。</li>
<li>借助其水平伸缩性，同时从多个计算节点访问数据而不受单个连接的限制。</li>
</ul>
</li>
<li>关键数据的备份和归档<ul>
<li>借助其数据高度持久性、架构可扩展性、数据安全方案，可用作数据备份和归档领域，并未业务连续性提供灾难恢复解决方案</li>
<li>数据冗余的存储region范围内（即覆盖AZ之间，）提供以上场景所需的高度持久的存储基础设施。</li>
<li>提供版本控制功能，用于关键数据意外删除。(need enable version  feature)</li>
</ul>
</li>
</ul>
<h2 id="Anti-Patterns（不建议）"><a href="#Anti-Patterns（不建议）" class="headerlink" title="Anti-Patterns（不建议）"></a>Anti-Patterns（不建议）</h2><ul>
<li>动态网站<ul>
<li>S3非常适合托管静态网站，但是无法托管需要服务器端交互，脚本或数据库交互的动态网站，而应该托管在Amazon EC2上。（也就是其本质是WORM属性，适合读场景，并不适合数据变化快的场景）</li>
</ul>
</li>
<li>备份和归档存储<ul>
<li>不频繁读取访问权限的长期归档存储的数据可以在Glacier中更经济有效地存储。</li>
</ul>
</li>
<li>结构化数据查询<ul>
<li>Amazon S3不提供查询功能，因此要读取对象，必须知道对象名称和键。相反，将S3与RDS或Dynamo DB配合，以存储、索引和查询关于Amazon S3对象的元数据</li>
<li>注意:S3现在提供了查询功能，也可以使用Athena（一种交互式查询服务，可使用此服务通过标准 SQL 在 Amazon S3 中轻松分析数据）</li>
</ul>
</li>
<li>快速变化的数据<ul>
<li>频繁更新的数据，建议使用具有较低读/写延迟的存储解决方案，如Amazon EBS卷、RDS或Dynamo DB。</li>
</ul>
</li>
<li>文件系统<ul>
<li>S3使用扁平的命名空间，不能作为独立的或通过POSIX兼容文件系统。但是可以通过使用分隔符（通常是’/‘或’’字符），可以构造键值模拟给定存储桶中文件系统的分层文件夹结构。（对象存储系统是扁平的结构，而文件系统是树状结构）</li>
</ul>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>在同一region内，EC2访问S3速度很快。</li>
<li>S3在设计上，相较于Internet网络访问在服务器端延迟是相对很低的。</li>
<li>S3在扩展性，请求数和用户访问数，支持几乎无限数量的Web级应用程序。</li>
<li>对于多线程、多应用程序或多客户访问S3，则S3的总吞吐量通常是以线性增加的方式提供服务或响应需求。</li>
</ul>
<h2 id="冗余性-amp-可用性"><a href="#冗余性-amp-可用性" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>S3在所选地理范围内，通过多设备和多设施之间自动化、同步机制实现数据存储最高级别的数据持久性和可用性。</li>
<li>内置数据的纠错机制（Daemon模式）和高可用架构（没有单点故障）。</li>
<li>设计目标：每个对象99.999999999％（11个9）的持久性和一年内（使用周期内，每个region可能有差异）99.99％的可用性。</li>
<li>提供版本控制功能，以防意外删除或覆盖。</li>
<li>支持MFA（多重身份验证）模式控制存储桶的版本控制功能。（双重身份验证）</li>
<li>非关键和可重复的数据，例如缩略图，转码媒体等，可使用S3 Reduced Redundancy Storage（RRS），以较低的存储成本提供较低的耐用性。</li>
<li>RRS的设计目标是在给定的一年内为每个对象提供99.99%的耐久性。虽然RRS不如标准的Amazon S3耐用，但它的耐用性仍然是典型磁盘驱动器的400倍。</li>
</ul>
<h2 id="扩展性-amp-弹性"><a href="#扩展性-amp-弹性" class="headerlink" title="扩展性&amp;弹性"></a>扩展性&amp;弹性</h2><p>注：Elasticity and Scalability 对比，英文原文如下（个人觉得比较好的解释）</p>
<ul>
<li>Scalability is the ability of a system to handle the increased load on its current hardware and software resources. In a highly scalable system it is possible to increase the workload without increasing the resource capacity. Scalability supports any sudden surge in the demand/traffic with current set of resources.（可伸缩性是系统处理其当前硬件和软件资源上增加的负载的能力。 在高度可扩展的系统中，可以在不增加资源容量的情况下增加工作量。 可扩展性支持使用当前资源集的任何突然的需求/流量激增。）</li>
<li>Elasticity is the ability of a system to increase the workload by increasing the hardware/software resources dynamically. Highly elastic systems can handle the increased demand and traffic by dynamically commission and decommission resources. Elasticity is an important characteristic of Cloud Computing applications. Elasticity means how well your architecture is adaptable to workload in real time.（弹性是系统通过动态增加硬件/软件资源来增加工作负载的能力。 高弹性系统可以通过动态调试和停用资源来处理增加的需求和流量。 弹性是云计算应用程序的一个重要特征，意味着架构能够实时适应工作负载。）</li>
<li>S3旨在自动提供非常高的伸缩性、弹性。</li>
<li>S3 bucket几乎可以无限数量的存储对象数据和文件。</li>
<li>S3将自动管理扩展并将数据的冗余副本分发到同一区域中其他AZ中的存储设备上，所有这些都使用AWS的高性能基础架构。</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>S3为管理和数据操作提供标准的REST和SOAP Web服务API。（注 -不推荐使用HTTP上的SOAP支持，但仍可通过HTTPS使用它。 SOAP不支持新的Amazon S3功能。建议使用REST API或AWS SDK。）</li>
<li>S3提供易于使用的高级别的工具包或SDK，封装了包含底层API的不同语言（如Java，.NET，PHP和Ruby）。</li>
<li>S3命令行界面（CLI）提供一组常见操作的类高级Linux Amazon S3文件命令，例如ls，cp，mv，sync等。还提供执行递归上载和下载的功能使用文件夹级别的S3命令，并支持并行传输。</li>
<li>管理控制台提供简单的基于Web的用户界面轻松创建和管理Amazon S3存储桶，上载和下载对象以及浏览Amazon S3存储桶内容的功能。</li>
<li>所有接口都能够将S3对象（文件）存储在唯一命名的存储桶（top-level folders）中，每个对象在该存储桶中的都具有唯一对象标识符（key id）。</li>
</ul>
<h1 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>极低成本的存储服务，为数据备份和存档提供高度安全，持久和灵活的存储。</li>
<li>可靠地存储数据，并且每月只需0.01美元每千兆字节。（价格可能变动）</li>
<li>将操作和扩展存储的管理负担转移到AWS，例如容量规划、硬件供应、数据复制、硬件故障检测和修复，或耗时的硬件迁移等。（用户只需关注其归档服务即可，其他一概不需要care）</li>
<li>数据作为归档文件存储在Glacier中，归档文件可以表示单个文件，也可以表示多个文件合成一个归档文件。</li>
<li>通过IAM控制访问存储在Vault中的存档文件。</li>
<li>从Vaults检索存档需要启动一个job,并且可能需要大约3-5个小时才能取回数据。</li>
<li>Glacier通过使用S3数据生命周期管理策略将数据从S3移动到Glacier，从而与Amazon S3无缝集成。<strong>（其实数据是不能直接归档到Glacier的，需要经过S3）</strong></li>
<li>AWS Import / Export可用于加速使用便携式存储设备将大量数据移动到Amazon Glacier进行存储归档。</li>
</ul>
<h2 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>Glacier是理想的长期档案解决方案，不经常访问的数据存档企业信息，媒体资产，研究和科学数据，数字保存和磁带更换的最佳替换者。（总之一句话，面向归档存储。）</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）"><a href="#Anti-Patterns（不建议模式）" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>快速变化数据<ul>
<li>频繁更新的数据，建议使用具有较低读/写延迟的存储解决方案，如Amazon EBS卷、RDS或Dynamo DB。</li>
</ul>
</li>
<li>实时数据访问<ul>
<li>无法实时访问存储在Glacier中的数据，并且需要启动用于对象检索的job，检索时间范围为3-5小时。若需要立即访问，Amazon S3是更好的选择。</li>
</ul>
</li>
</ul>
<h2 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h2><ul>
<li>Glacier是一种低成本存储服务，旨在存储不经常访问且使用寿命长的数据。</li>
<li>Glacier的工作通常在3到5个小时内完成（默认）。</li>
<li>加速检索1<del>5分钟，批量检索5</del>12H（加费用）</li>
</ul>
<h2 id="持久性和可用性"><a href="#持久性和可用性" class="headerlink" title="持久性和可用性"></a>持久性和可用性</h2><ul>
<li>Glacier将数据冗余地存储在多个基础设施中以及每个设施内的多个存储设备上</li>
<li>Glacier旨在为存档提供99.999999999％（11个9）的平均年度耐久性。</li>
<li>Glacier会在上传归档返回SUCCESS之前，将数据同步存储在多个设施中以确保数据一致性。</li>
<li>Glacier定期执行的系统数据完整性检查，并可自动进行自我修复，以确保数据完整性。</li>
</ul>
<h2 id="扩展性和弹性"><a href="#扩展性和弹性" class="headerlink" title="扩展性和弹性"></a>扩展性和弹性</h2><ul>
<li>单个存档文件上限限制为40 TB，但Glacier服务中存储的数据总量没有限制。</li>
<li>无论是存储数PB还是千兆，Glacier都可以扩展以满足不断增长且通常无法预测的存储容量要求， Glacier会根据需要自动扩展或缩小存储。</li>
</ul>
<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><ul>
<li>Glacier提供标准的原生REST Web服务接口，以及Java和.NET SDK。</li>
<li>AWS管理控制台或Glacier API可用于创建存储Vault以组织Glacier中的存档。</li>
<li>Glacier api可用于上传和检索归档文件，监视作业的状态，还可以配置Vault，以便在作业完成时通过Amazon SNS发送通知。</li>
<li>使用对象生命周期管理，从S3到Glacier提供自动，策略驱动的归档。</li>
<li>S3 api提供了一个恢复操作，检索过程同样需要3-5个小时。</li>
<li>在检索时，检索到的对象的副本将放置在S3 RRS存储中（一定的保留期）;原始存档对象仍存储在Amazon Glacier中，仍需要为存储付费，除非删除。</li>
<li>在S3中使用Amazon Glacier作为存储层（Class）时，使用Amazon S3 API，当使用“native（原生）” Glacier时使用Glacier API。</li>
<li>通过S3归档到Glacier的对象只能通过Amazon S3 api或AWS管理控制台列出和检索—它们不能作为Glacier vault中的归档文件显示。</li>
</ul>
<h1 id="为数据选择合适的S3分类"><a href="#为数据选择合适的S3分类" class="headerlink" title="为数据选择合适的S3分类"></a>为数据选择合适的S3分类</h1><p><img src="https://i.loli.net/2019/08/20/4ecOy7jliw3dHZr.jpg" alt="存储分类-S3.jpeg"></p>
<h3 id="S3-Standard"><a href="#S3-Standard" class="headerlink" title="S3 Standard"></a>S3 Standard</h3><ul>
<li>活跃且频繁访问数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1755/GB</li>
</ul>
<h3 id="S3-Intelligent-tiering-（利用了大数据技术进行分层处理）"><a href="#S3-Intelligent-tiering-（利用了大数据技术进行分层处理）" class="headerlink" title="S3 Intelligent_tiering （利用了大数据技术进行分层处理）"></a>S3 Intelligent_tiering （利用了大数据技术进行分层处理）</h3><ul>
<li>访问模式不确定数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1030/GB~0.1775/GB</li>
<li>最小存储周期</li>
</ul>
<h3 id="S3-Standard-IA"><a href="#S3-Standard-IA" class="headerlink" title="S3 Standard-IA"></a>S3 Standard-IA</h3><ul>
<li>不频繁访问数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1030/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-One-Zone-IA"><a href="#S3-One-Zone-IA" class="headerlink" title="S3 One Zone-IA"></a>S3 One Zone-IA</h3><ul>
<li>可重建数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.0824/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 Glacier</h3><ul>
<li>归档数据</li>
<li>分钟到小时级别恢复时间</li>
<li>≥3个可用区</li>
<li>￥0.0300/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-Glacier-Deep-Archive"><a href="#S3-Glacier-Deep-Archive" class="headerlink" title="S3 Glacier Deep Archive"></a>S3 Glacier Deep Archive</h3><ul>
<li>归档数据</li>
<li>小时级别恢复时间（12~48）</li>
<li>≥3个可用区</li>
<li>￥0.010800/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h1 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul>
<li>EBS为EC2实例提供持久的块级存储</li>
<li>EBS独立于EC2实例，具备生命周期、通过网络连接非依赖实例的存储</li>
<li>EBS卷通过附加到实例，可以像物理硬盘驱动器一样使用，通过文件系统格式化之后，即可用文件系统的I/O接口实现数据的存储与管理</li>
<li>EBS卷可用于引导EC2实例(仅Amazon EBS-root ami)，多个Amazon EBS卷可附加到一个EC2实例（多对一）</li>
<li>EBS卷在单一时间只能挂载一个EC2实例。（不支持1对多挂载）</li>
<li>EBS提供基于时间点快照的功能，这些快照保存在S3中。快照可用于实例化新的EC2卷并保护数据以实现长期保存</li>
<li>EBS快照也可以跨AWS区域复制，从而可以更轻松地利用多个AWS区域进行地理扩展，进行数据中心迁移和灾难恢复</li>
</ul>
<h2 id="使用范例-2"><a href="#使用范例-2" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>EBS适用于数据变化相对频繁并且需要长期持久化的场景</li>
<li>EBS卷提供对裸块级存储的访问，特别适合用作数据库或主文件系统存储</li>
<li>预配置IOPS卷特别适合与需要速度且具有数据一致性的随机磁盘读写的数据库应用程序一起使用</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）-1"><a href="#Anti-Patterns（不建议模式）-1" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>临时性数据<ul>
<li>EBS卷独立于EC2生命周期</li>
<li>对于cache、buffer、queue等数据，建议使用本地存储，SQS或Elastice cache</li>
</ul>
</li>
<li>持久性数据<ul>
<li>年持久性可达99.5～99.9%（最近一次修改数据少于20GB的EBS卷），数据修改约频繁，其持久性会下降</li>
<li>对于数据持久性有更高要求的，建议使用S3或Glacier</li>
</ul>
</li>
<li>静态数据或网站内容<ul>
<li>对于数据很少更改的静态web内容，使用EC2的EBS卷提供 web服务页面</li>
<li>S3是存储这种固定信息的更经济有效和可伸缩的解决方案，并且可以直接从S3提供服务。</li>
</ul>
</li>
</ul>
<h2 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h2><ul>
<li>EBS提供两种卷类型：标准卷和预配置IOPS卷，它们在性能和价格模型上有所不同，根据应用程序的需要的存储性能和成本进行选择</li>
<li>可以使用RAID 0或逻辑卷管理器软件在多个EBS卷之间进行条带EBS卷，从而聚合提高可用的IOPS、吞吐量和卷大小</li>
<li>标准卷可为普通或突发I / O要求的应用程序提供经济高效的数据吞吐。标准卷也非常适合用作启动卷，其中突发功能提供快速的实例启动时间</li>
<li>预配置IOPS卷旨在为I / O密集型工作负载（如数据库）提供可预测的高性能。使用预配置IOPS，在创建卷时指定IOPS， EBS在指定的生命周期提供一致数据速率</li>
<li>EBS卷是通过网络连接挂载的，实例执行的其他网络I / O以及共享网络上的负载会影响EBS卷的性能。启动EBS优化实例，在EC2和EBS之间提供专用的吞吐量，并使实例能够充分利用Amazon EBS卷上提供的IOPS</li>
<li>根据需求将EBS卷配置为EBS标准或EBS预配置IOPS。或者，也可以对数据进行条带化</li>
</ul>
<h2 id="冗余性-amp-可用性-1"><a href="#冗余性-amp-可用性-1" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>EBS卷旨在提供高可用性和可靠性</li>
<li>EBS卷数据在<strong><font color="red">可用区</font></strong>中的多个服务器之间复制，以防止任何单个组件发生故障而导致数据丢失</li>
<li>EBS卷的持久性取决于卷的大小以及自上次快照以来更改的数据量。快照是增量的时间点备份，仅包含自上次快照以来更改的数据块。自最近一次快照以来，使用20 GB或更少修改数据运行的EBS卷的年度故障率（AFR）可能在0.1％到0.2％之间。自最近一次快照以来具有超过20 GB修改数据的EBS卷预期有更高的故障率与修改数据的增加大致成比例。因此，建议创建快照的频度更大一些，以最大限度地提高其EBS数据的持久性和可用性</li>
<li>EBS快照提供更快的磁盘克隆或磁盘映像机制，常用于备份，共享和灾难恢复</li>
<li>EBS 快照与 Amazon Data Lifecycle Manager (DLM) 策略配合使用，以自动执行快照管理</li>
</ul>
<h2 id="可扩展性-amp-弹性"><a href="#可扩展性-amp-弹性" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>EBS卷可以通过修改卷的大小（增大）、IOPS，快速地进行配置和发布，以适应不断变化的存储需求</li>
<li>无法在线缩小卷的大小（不确定是否有更新）</li>
</ul>
<h2 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h2><ul>
<li>通过SOAP和REST格式为Amazon EBS提供管理API，可用于为<strong><font color="red">EC2实例</font></strong> reate, delete, describe, attach, and detach ，以及从<font color="red"><strong>EBS创建</strong></font>，删除和快照 到S3，将快照从一个区域复制到另一个区域</li>
<li>AWS管理控制台提供以上相同的功能</li>
</ul>
<h1 id="EFS"><a href="#EFS" class="headerlink" title="EFS"></a>EFS</h1><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ul>
<li>提供简单，可扩展的文件存储服务，以便与EC2实例一起使用</li>
<li>存储空间是弹性的，随着文件的添加和删除而自动增长和收缩</li>
<li>挂载在到EC2实例上时，提供标准文件系统接口和文件系统访问语义</li>
<li>在共享模式下工作，多个EC2实例可以同时访问EFS文件系统，EFS提供共享数据服务</li>
<li>可以在EC2实例上并发运行工作负载和应用程序</li>
<li>使用AWS Direct Connect连接到VPC时，可以在本地数据中心服务器挂载共享文件系统使用</li>
<li>可以挂载到本地服务器上，以便数据集迁移到EFS，将本地数据备份到EFS</li>
<li>专为高可用性和耐用性而设计，可为广泛的工作负载和应用程序提供性能，包括大数据和分析，媒体处理工作流，内容管理，Web服务和主目录</li>
<li>基于 Linux 的工作负载</li>
</ul>
<h2 id="使用范例-3"><a href="#使用范例-3" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>跨可用区、区域和 VPC 访问文件系统，并可以通过 AWS Direct Connect 或 AWS VPN 在数千个 Amazon EC2 实例与本地服务器之间共享文件</li>
<li>超高吞吐量的高度并行化的横向扩展工作负载到单线程的延迟敏感型工作负载，均适用。直接迁移企业应用程序、大数据分析、Web 服务和内容管理、应用程序开发和测试、媒体和娱乐工作流程、数据库备份和容器存储。<br>直接迁移企业应用程序、大数据分析、Web 服务和内容管理、应用程序开发和测试、媒体和娱乐工作流程、数据库备份和容器存储。</li>
</ul>
<h2 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h2><ul>
<li>提供标准和不经常访问存储类。标准存储类是为活动文件系统工作负载而设计的，EFS 不频繁访问 (EFS IA) 是一种成本较低的存储类，针对不经常访问的文件进行了成本优化。EFS 文件系统透明地提供来自两个存储类的数据转换。</li>
<li>所有文件系统的稳定基准性能为每 TB 标准类存储 50MB/s </li>
<li>EFS 支持一个到数千个EC2 实例同时连接一个文件系统</li>
<li>性能模式<ul>
<li>通用性能模式，非常适合对延迟敏感的使用案例，如 Web 服务环境、内容管理系统、主目录和一般文件服务。（默认）</li>
<li>最大 I/O 性能模式，扩展到更高级别的聚合吞吐量和每秒操作数，但代价是稍高的文件操作延迟。诸如大数据分析、媒体处理和基因组分析等高度并行化的应用程序和工作负载可以受益于这种模式。</li>
</ul>
</li>
<li>吞吐量模式<ul>
<li>突增吞吐量，Amazon EFS 上的吞吐量将随着标准存储类别中存储的文件系统的增大而增加，都能突增到 100 MB/秒的吞吐量</li>
<li>预置吞吐量使 Amazon EFS 客户能够预置文件系统的吞吐量（无需考虑存储的数据量），从而优化文件系统的吞吐性能，以满足应用程序的需求</li>
</ul>
</li>
</ul>
<h2 id="冗余性-amp-可用性-2"><a href="#冗余性-amp-可用性-2" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>每个文件系统对象（即目录、文件和链接）均会在多个可用区中进行冗余存储。此外，文件系统还可以从其所在区域中的各个可用区同时访问，这意味着在构建应用程序时，可以使其从区域中的一个可用区故障转移到其他可用区，从而确保应用程序的高可用性。挂载目标本身即具有高可用性。<br>可扩展性&amp;弹性</li>
<li>随文件系统增减文件的操作自动进行扩展和收缩，因此不需要进行存储的采购和预配置工作</li>
</ul>
<h2 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用标准 Linux 挂载命令和文件系统的 DNS 名称将文件系统挂载到基于 Linux 的 EC2 实例上</li>
<li>为了简化对 EFS 文件系统的访问，建议使用 EFS 挂载助手实用程序</li>
<li>EFS 使用网络文件系统版本 4 (NFS v4) 协议</li>
<li>DataSync 工具提供将现有文件系统与 Amazon EFS 安全同步，可借助VPN或DX。</li>
<li>通过 AWS 管理控制台、AWS 命令行界面 (CLI) 或 EFS API（以及各种语言的软件开发工具包）来管理文件系统。通过控制台、API 和软件开发工具包，可以创建和删除文件系统、配置文件系统的访问方式、创建和编辑文件系统标签、启用预置吞吐量和生命周期管理等功能，以及显示文件系统的详细信息。</li>
</ul>
<h1 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h1><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ul>
<li>Storage Gateway是一种将本地软硬件设备与基于云的存储相连接的服务，可在本地IT环境与AWS的存储基础架构之间提供无缝，安全的集成。</li>
<li>Storage Gateway可以将数据安全地存储到AWS云端，以实现可扩展且经济高效的数据存储。</li>
<li>在本地提供繁的数据访问并保障低延迟，同时还可通过加密将数据安全存储在S3中。</li>
<li>对于灾难恢复场景，可以作为云托管解决方案与EC2一起联动，镜像生产环境到云端。</li>
<li>Storage Gateway 可以配置为<ul>
<li>Gateway-cached volumes<ul>
<li>网关缓存卷利用S3进行主要数据备份，同时在本地保留经常访问的数据</li>
<li>最大限度地减少了扩展本地存储基础架构的需求，同时为应用程序提供对其频繁访问的数据的低延迟访问</li>
<li>写入卷的数据存储在S3中，只有最近写入和最近读取的数据的缓存本地存储在本地存储硬件上</li>
</ul>
</li>
<li>Gateway-stored volumes<ul>
<li>网关存储的卷在本地存储完整的主要数据，同时异步地将数据备份到AWS</li>
<li>这些卷为本地应用程序提供了对其整个数据集的低延迟访问，同时提供了持久的异地备份</li>
<li>写入网关存储卷的数据存储在本地存储硬件上，并以EBS快照的形式异步备份到S3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用范例-4"><a href="#使用范例-4" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>企业组织之间文件共享</li>
<li>将现有的本地备份应用程序备份到S3上的和灾难恢复场景，以及数据镜像到云端</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）-2"><a href="#Anti-Patterns（不建议模式）-2" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>数据库存储<ul>
<li>对于数据库存储或备份，使用EBS卷的EC2实例是数据库存储和工作负载的最佳选择</li>
</ul>
</li>
</ul>
<h2 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h2><ul>
<li>由于Storage Gateway VM介于应用程序，本地存储和S3之间，因此所遇到的性能将取决于诸多因素，包括本地磁盘的速度和配置，iSCSI initiator与网关之间的网络带宽，Gateway VM的数量，以及VM和S3的带宽</li>
<li>对于Gateway-cached volumes，为了提供对本地应用程序的低延迟读访问，重要的是提供足够的本地缓存存储来存储最近访问的数据</li>
<li>Storage Gateway有效地使用Internet带宽将数据上传到AWS</li>
<li>Storage Gateway仅传输增量更改（已更改的数据），从而最大限度地减少通过Internet发送的数据量</li>
<li>通过在AWS和AWS之间建立连接，AWS Direct Connect可用于进一步提高吞吐量并降低网络成本</li>
</ul>
<h2 id="冗余性-amp-可用性-3"><a href="#冗余性-amp-可用性-3" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>AWS Storage Gateway通过将数据传输到S3来确保其数据持久性</li>
<li>S3提供11个9的持久性</li>
<li>S3定期执行系统的数据完整性检查并自动完成自我修复</li>
</ul>
<h2 id="可扩展性-amp-弹性-1"><a href="#可扩展性-amp-弹性-1" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>AWS Storage Gateway将数据存储在Amazon S3中，借助S3提供高级别的可扩展性和弹性</li>
</ul>
<h2 id="接口-4"><a href="#接口-4" class="headerlink" title="接口"></a>接口</h2><ul>
<li>通过AWS管理控制台可用于下载AWS Storage Gateway VM映像，在网关缓存或网关存储配置之间进行选择，通过将网关与AWS账户相关联来激活部署，选择AWS区域，以及创建 AWS Storage Gateway卷并将这些卷作为iSCSI设备连接到本地应用程序服务器</li>
</ul>
<h1 id="Snow-Family"><a href="#Snow-Family" class="headerlink" title="Snow Family"></a>Snow Family</h1><p>Snow 系列是一系列物理设备，可帮助将大量数据传入和传出云，无需依赖网络。TB数据通过internet传输其稳定性、可靠性、费用、时间都无法和Snow设备相媲美。</p>
<h2 id="Snowball"><a href="#Snowball" class="headerlink" title="Snowball"></a>Snowball</h2><ul>
<li>是一种PB级数据传输服务，内置安全如手提箱大小的移动设备，，可快速高效地将数据移入和移出AWS云端</li>
<li>将数据导入到S3 </li>
<li>转移数据从开始到结束大约1周</li>
<li>通常用于传送（移动）TB量级数据，如分析数据、医疗保健和生命科学数据、视频库、图像存储库、备份和存档，作为数据中心停用，磁带数据替换者或大规模应用数据迁移</li>
</ul>
<h2 id="Snoaball-Edge"><a href="#Snoaball-Edge" class="headerlink" title="Snoaball Edge"></a>Snoaball Edge</h2><ul>
<li>设备具有更大的容量和嵌入计算平台，可执行简单的处理任务</li>
<li>这些设备可以安装在机架上并通过集群化一起使用，以便更轻松地在极其偏远的位置收集和存储数据</li>
<li>Storage Optimized 和 Compute Optimized类型</li>
<li>可以在时断时续的环境（例如制造业、工业和运输）中或在极其偏远的位置（例如军事或海事作业）使用这些设备，然后再将其运回 AWS</li>
<li>Snowball Edge 可使用 AWS Greengrass 和 Lambda 函数在网络边缘提供无服务器计算应用程序。</li>
<li>常见使用案例包括 IoT 传感器流捕获、动态媒体转码、图像压缩、指标聚合以及工业控制信令与警报。</li>
</ul>
<h2 id="Snowmobile"><a href="#Snowmobile" class="headerlink" title="Snowmobile"></a>Snowmobile</h2><ul>
<li>Snowmobile 是一个 45 英尺长的坚固集装箱，可迁移高达 100PB 的数据（相当于 1250 台 AWS Snowball 设备），非常适合数 PB 级或 EB 级数字媒体迁移和数据中心关闭的情况。</li>
<li>Snowmobile 在抵达客户站点后显示为网络连接数据存储，可实现更加安全的高速数据传输。将数据传输到 Snowmobile 后，Snowmobile 会被运回 AWS 区域，而数据会加载到 Amazon S3 中。</li>
<li>Snowmobile 防篡改、防水，具有温度控制，配备有多层逻辑和物理安全机制，包括加密、消防、专职安全人员、GPS 跟踪、警报监控、全天候视频监控以及运输过程中的护送安全车辆。</li>
</ul>
<h2 id="功能场景"><a href="#功能场景" class="headerlink" title="功能场景"></a>功能场景</h2><table>
<thead>
<tr>
<th>—</th>
<th>Snowball</th>
<th>SnowballEdge</th>
<th>Snowmobile</th>
</tr>
</thead>
<tbody><tr>
<td>使用情景</td>
<td>数据迁移</td>
<td>通过板载设备迁移数据预处理选项</td>
<td>数据迁移</td>
</tr>
<tr>
<td>存储容量</td>
<td>50TB 和 80TB</td>
<td>100TB</td>
<td>100PB</td>
</tr>
<tr>
<td>板载计算选项</td>
<td>不适用</td>
<td>AWS Lambda| AMI</td>
<td>不适用</td>
</tr>
<tr>
<td>加密</td>
<td>有，256 位</td>
<td>有，256 位</td>
<td>有，256 位</td>
</tr>
<tr>
<td>通过 NFS 传输</td>
<td>不适用</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>通过 HDFS 传输</td>
<td>是</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>通过 S3 API 传输</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>集群</td>
<td>不适用</td>
<td>是，最多 20 个节点</td>
<td>不适用</td>
</tr>
<tr>
<td>可安装机架</td>
<td>架子</td>
<td>是</td>
<td>不适用</td>
</tr>
<tr>
<td>符合 HIPAA 要求</td>
<td>是，符合要求</td>
<td>是，符合要求</td>
<td>否</td>
</tr>
<tr>
<td>常规作业生命周期</td>
<td>数天-数周</td>
<td>数据迁移：数天-数周本地计算：数周-数月</td>
<td>数周-数月</td>
</tr>
<tr>
<td>最长作业时间</td>
<td>90 天</td>
<td>数据迁移：90 天；本地计算：120 天</td>
<td>120-360 天</td>
</tr>
</tbody></table>
<h2 id="性能-5"><a href="#性能-5" class="headerlink" title="性能"></a>性能</h2><ul>
<li>Snowball 拥有 10Gbps 的网络接口，配有 RJ45、SFP+ 铜缆和 SFP+ 光学网络接口</li>
<li>Snowball 客户端将以条件允许的最快速度将数据复制到 Snowball（例如，不到一天就可以复制 48TB 的数据，具体取决于本地环境）</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>云迁移</li>
<li>灾难恢复</li>
<li>数据中心停用</li>
<li>内容分配（定期接收或需要与客户、消费者或业务伙伴共享大量数据）</li>
</ul>
<h2 id="可扩展性-amp-冗余性"><a href="#可扩展性-amp-冗余性" class="headerlink" title="可扩展性&amp;冗余性"></a>可扩展性&amp;冗余性</h2><ul>
<li>单个 Snowball 设备可以传输数 TB 的数据，并且可以并行使用多台设备将数 PB 的数据传入或传出 Amazon S3 存储桶；或者在设置生命周期管理策略时，单个 Snowball 设备可以自动将数据从 S3 分层到 Amazon Glacier </li>
<li>多台 Snowball Edge 设备可以充当一个可扩展存储与计算池，持久性更高</li>
<li>一台 Snowmobile 一次可以传输高达 100PB 的数据，这相当于大约 1250 台 AWS Snowball 设备传输的数据量</li>
<li>数据持久性借助S3或Glacier提供11个9的持久性。</li>
</ul>
<h2 id="接口-5"><a href="#接口-5" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用 AWS 管理控制台创建一项或多项任务，申请一台或多台 Snowball 设备（具体取决于需要传输的数据量），然后下载并安装 Snowball 客户端（简称“客户端”）。当设备抵达后，将其连接到本地网络，手动或使用 DHCP 设置 IP 地址，然后使用客户端确定要复制的目录。客户端会自动加密数据并将其复制到设备，然后在传输作业完成时通知。</li>
<li>Snowball 任务管理 API 提供对 Snowball 任务创建和管理功能的编程式访问。这是一种基于标准的简单 REST Web 服务接口，旨在与任何 Internet 开发环境配合使用。</li>
<li>S3 SDK Adapter for Snowball 可以为 Snowball 客户端提供兼容 S3 的接口，以便在 Snowball 上读取和写入数据。</li>
</ul>
<h1 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h1><blockquote>
<p><strong>注：此处的备份服务并不是通常意义的特定应用程序及其数据备份，AWS提供的备份服务都是基于以上存储服务自身提供的备份服务，和NBU、Commvault、Veeam等专用备份有着很大区别。</strong></p>
</blockquote>
<p>AWS Backup 是一种完全托管的备份服务，使用 AWS Storage Gateway 轻松地集中自动管理云中以及本地的各种 AWS 服务的数据备份工作。支持集中配置备份策略并监控<font color="orange" size="2"> EBS 卷（快照）、RDS 数据库（不含Aurora，快照）、DynamoDB 表、EFS 文件系统和 Storage Gateway 卷(快照)。</font></p>
<h2 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h2><ul>
<li>集中式备份管理</li>
<li>基于策略的备份（即通常意义上的备份计划）</li>
<li>基于标记的备份策略（AWS 资源进行标记来对其应用备份计划）</li>
<li>备份活动监控（提供dashboard 审核备份和还原备份活动）</li>
<li>支持生命周期策略，可以将备份存储转移到冷存储层中</li>
<li>支持独立于源数据的备份数据存储和加密，以及基于资源的访问策略</li>
</ul>
<h2 id="使用范例-5"><a href="#使用范例-5" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>业务和法规备份合规性要求</li>
<li>原生云备份</li>
<li>混合备份，云中和本地的应用程序数据备份，结合Storage Gateway集成</li>
</ul>
<h2 id="接口-6"><a href="#接口-6" class="headerlink" title="接口"></a>接口</h2><ul>
<li>AWS集中的备份控制台、备份 API 以及 AWS Command Line Interface (AWS CLI)，用于管理备份</li>
</ul>
<h1 id="Instance-Store-Volumes"><a href="#Instance-Store-Volumes" class="headerlink" title="Instance Store Volumes"></a>Instance Store Volumes</h1><h2 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h2><ul>
<li>实例存储卷（临时卷）提供临时块级存储，与EC2实例位于同一物理服务器上的预配置和连接的磁盘存储块组成</li>
<li>实例存储的存储量取决于实例类型，较大的实例同时提供更多和更大的实例存储卷。较小的实例类型(如微实例)只能用于卷启动。</li>
<li>存储优化实例提供针对例如特定用途的特殊用途实例存储。 如HI1提供非常快速的固态驱动器（SSD）支持的实例存储，能够支持超过120,000随机读取IOPS，针对非常高的随机I / O性能和低IOPS成本进行了优化。 同时，HS1实例针对非常高的存储密度，低存储成本和高顺序I / O性能进行了优化。</li>
<li>与EBS卷不同，实例存储卷不能分离或附加到另一个实例</li>
</ul>
<h2 id="使用范例-6"><a href="#使用范例-6" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>EC2本地实例存储卷提供快速，免费（即包含在EC2实例的价格中）“临时卷”最适合存储不断变化的临时数据，例如buffers，cache，暂存数据或者可重新生成数据，或者为了持久性而复制的数据</li>
<li>高I / O实例提供SSD支持的实例存储卷，非常适合许多高性能数据库工作负载。 如应用程序包括像Cassandra和MongoDB这样的NoSQL数据库。</li>
<li>高存储实例支持每个EC2实例更高的存储密度，非常适合在非常大的数据集中受益于高顺序I / O性能的应用程序。 例如应用程序包括数据仓库，Hadoop存储节点，地震分析，群集文件系统等。<br>Anti-Patterns（不建议模式）</li>
<li>持久性数据<ul>
<li>对于持久性虚拟磁盘存储，类似于物理磁盘驱动器，用于文件或其他必须持续时间超过EC2实例生命周期的数据， EBS卷或S3更合适。</li>
</ul>
</li>
<li>关系型数据库数据<ul>
<li>在大多数情况下，关系数据库要求存储在EC2实例的生命周期之后持续存在，这使得EBS卷成为更好的选择。</li>
</ul>
</li>
<li>共享数据存储<ul>
<li>实例存储卷专用于单个EC2实例，无法与其他系统或用户共享。如果需要可以从一个实例分离并连接到其他实例的存储，或者需要能够轻松共享数据，那么S3或EBS卷是更好的选择。</li>
</ul>
</li>
<li>快照<ul>
<li>如果要使用基于时间点磁盘快照的便利性，长期持久性，可用性和可共享性，则EBS卷是更好的选择。</li>
</ul>
</li>
</ul>
<h2 id="性能-6"><a href="#性能-6" class="headerlink" title="性能"></a>性能</h2><ul>
<li>在大多数EC2实例家族中，非基于ssd的实例存储卷具有与标准EBS卷类似的性能</li>
<li>EC2实例和本地实例存储卷位于同一物理服务器中，与存储的交互非常快，尤其是对于顺序访问</li>
<li>提高聚合IOPS或提高顺序磁盘吞吐量，可以使用RAID 0（磁盘条带化）软件将多个实例存储卷组合在一起</li>
<li>由于磁盘的带宽不受网络限制，因此多个实例卷的聚合顺序吞吐量可能高于相同容量的EBS卷</li>
<li>EC2高I / O实例中的SSD实例存储卷可提供数万至数十万随机IOPS，低延迟，4 KB</li>
<li>由于SSD设备的I/O特性，写性能在生命周期是是可变的</li>
<li>EC2高存储实例上的实例存储卷提供非常高的存储密度和高顺序读写性能。当使用块大小为2 MB时，高存储实例能够提供2.6 GB/秒的顺序读写性能</li>
</ul>
<h2 id="冗余性-amp-可用性-4"><a href="#冗余性-amp-可用性-4" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>不应用作持久磁盘存储，并且仅在关联EC2实例的生命周期内持续存在</li>
</ul>
<h2 id="可扩展性-amp-弹性-2"><a href="#可扩展性-amp-弹性-2" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>本地实例存储卷绑定到特定的EC2实例，并且对于给定的EC2实例类型，本地实例存储卷的数量和大小是固定的，因此该存储的可伸缩性和弹性绑定到EC2实例的规格限制</li>
</ul>
<h2 id="接口-7"><a href="#接口-7" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用EC2 API和AWS管理控制台的块设备映射功能指定实例存储卷</li>
<li>对于EC2实例，实例存储卷的显示方式与本地磁盘驱动器类似。写入实例存储卷并从中读取数据，请使用所选操作系统的本地文件系统I / O接口</li>
</ul>
<h1 id="Reffer"><a href="#Reffer" class="headerlink" title="Reffer"></a>Reffer</h1><ol>
<li><a href="http://jayendrapatil.com/" target="_blank" rel="noopener">http://jayendrapatil.com/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/21/AWS-Direct-Connect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/AWS-Direct-Connect/" itemprop="url">AWS Direct Connect</a></h1>
        

        <div class="post-meta">
          
                    <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T21:40:54+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Direct-Connect-Overview"><a href="#Direct-Connect-Overview" class="headerlink" title="Direct Connect Overview"></a>Direct Connect Overview</h2><ul>
<li>AWS Direct Connect是一种网络服务，它是一种替代Internet来利用AWS云服务的一种方案</li>
<li>通过标准的以太网光纤电缆将内部网络链接到 AWS Direct Connect 位置。电缆的一端接到用户侧路由器，另一端接到 AWS Direct Connect 路由器</li>
<li>可以使用1Gbps和10Gbps端口建立直接连接。可以从任何支持AWS Direct Connect的APN合作伙伴订购50Mbps，100Mbps，200Mbps，300Mbps，400Mbps和500Mbps的速度</li>
<li>有了此连接以后，可以创建直接连接到公共 AWS 服务（如 Amazon S3）或 Amazon VPC 的虚拟接口，从而绕过网络路径中的 Internet 服务提供商</li>
<li>AWS Direct Connect位置提供对与其关联的区域中的Amazon Web Services的访问，以及对其他美国区域的访问（如果是美国地区的Direct Connect）。例如，可以为美国的任何AWS Direct Connect位置配置单个连接，并使用它来访问所有美国区域和AWS GovCloud（美国）中的公共AWS服务。</li>
<li>每个AWS Direct Connect位置都可以连接到地理位置最近的AWS区域内的所有可用区</li>
<li>公有区域或AWS GovCloud (US)中的 AWS Direct Connect 位置可以访问任何其他公有区域（不包括中国(北京和宁夏)）中的公有服务</li>
</ul>
<p><img src="https://i.loli.net/2019/08/21/6VWEui91R57Yyjm.png" alt="direct_connect_overview.png"></p>
<h2 id="Direct-Connect-Advantages"><a href="#Direct-Connect-Advantages" class="headerlink" title="Direct Connect Advantages"></a>Direct Connect Advantages</h2><ul>
<li>降低带宽成本<ul>
<li>所有通过专用连接传输的数据均按AWS直接连接数据传输速率(而不是Internet数据传输速率)的，从而节省成本</li>
<li>在AWS之间传输数据直接减少了Internet服务提供商的带宽承诺</li>
</ul>
</li>
<li>一致的网络性能<ul>
<li>与互联网的网络变化（抖动、延迟）相比，Direct Connect提供专用连接和更一致的网络性能体验</li>
</ul>
</li>
<li>AWS 服务兼容性<ul>
<li>Direct Connect是一种网络服务，可与S3，EC2和VPC等所有AWS服务配合使用</li>
</ul>
</li>
<li>VPC的专用连接<ul>
<li>使用直接连接专用虚拟接口（Private virtual interface）可以在网络和VPC之间建立专用的专用高带宽网络连接</li>
</ul>
</li>
<li>弹性<ul>
<li>使用更高带宽的连接或建立多个连接，可以轻松扩展直接连接以满足需求</li>
</ul>
</li>
</ul>
<h2 id="Direct-Connect-vs-IPSec-VPN-Connections"><a href="#Direct-Connect-vs-IPSec-VPN-Connections" class="headerlink" title="Direct Connect vs IPSec VPN Connections"></a>Direct Connect vs IPSec VPN Connections</h2><ul>
<li>VPC VPN连接通过IPSec在Internet上建立内部网和Amazon VPC之间的加密网络连接</li>
<li>VPN连接可以在几分钟内进行配置，而对于需要一个具有低到适度的带宽需求，并能容忍在基于互联网连接的内在变化</li>
<li>AWS Direct Connect不涉及Internet; 相反，它使用Intranet和Amazon VPC之间的专用专用网络连接</li>
<li>与Direct Connect连接相比，VPN连接非常便宜，因为它需要实际的硬件和基础设施，可能需要数千个</li>
</ul>
<h2 id="Direct-Connect-Anatomy"><a href="#Direct-Connect-Anatomy" class="headerlink" title="Direct Connect Anatomy"></a>Direct Connect Anatomy</h2><p><img src="https://i.loli.net/2019/08/21/qgxn1o5FaWQEUVT.png" alt="screen-shot-2016-05-17-at-1-56-15-pm.png"></p>
<ul>
<li>亚马逊在不同地点维护AWS Direct Connect PoP（称为主机托管设施），这与AWS区域不同</li>
<li>AWS本身维护从AWS Direct Connect PoP到AWS区域的连接</li>
<li>消费者，既可以购买机架空间，也可以使用任何已在主机托管设施中拥有基础架构的AWS APN合作伙伴并配置客户网关</li>
<li>Direct Connect PoP与Colocation Facility内的Customer网关之间的连接称为Cross Connect</li>
<li>可以使用任何服务提供商网络建立从客户网关到客户数据中心的连接</li>
<li>使用AWS创建直接连接连接后，将收到LOA-CFA（授权书 - 连接设施分配）。</li>
<li>LOA-CFA可以切换到主机托管设施或APN合作伙伴以建立交叉连接</li>
<li>一旦建立了Cross Connect以及CGW和Customer DataCenter之间的连接，就可以创建虚拟接口</li>
<li>AWS Direct Connect需要VGW才能访问AWS VPC</li>
<li>虚拟接口<ol>
<li>每个AWS Direct Connect连接都需要一个虚拟接口</li>
<li>每个AWS Direct Connect连接都可以配置一个或多个虚拟接口。</li>
<li>可以创建公共虚拟接口（public virtual interface）以连接到例如公共资源。 SQS，S3，EC2，Glacier等只能公开到达</li>
<li>可以创建专用虚拟接口以连接到例如VPC私有IP地址的实例</li>
<li>每个虚拟接口都需要VLAN ID，接口IP地址，ASN和BGP密钥</li>
</ol>
</li>
<li>要将AWS Direct Connect连接与其他AWS账户一起使用，可以为该账户创建托管虚拟接口。 这些托管虚拟接口与标准虚拟接口的工作方式相同，可以连接到公共资源或VPC。</li>
</ul>
<h2 id="Direct-Connect-Redundancy"><a href="#Direct-Connect-Redundancy" class="headerlink" title="Direct Connect Redundancy"></a>Direct Connect Redundancy</h2><p><img src="https://i.loli.net/2019/08/21/y1cnTMYo63FADd5.png" alt="screen-shot-2016-05-17-at-1-57-22-pm.png"></p>
<ul>
<li>直接连接不提供冗余，并且有多个单点故障，因为每个连接都包含路由器端口和Amazon路由器之间的单个专用连接</li>
<li>冗余连接<ol>
<li>建立第二个DX，最好使用不同的路由器和AWS Direct Connect PoP在不同的主机托管设施中建立连接</li>
<li>客户DC与VGW之间的IPsec VPN连接</li>
</ol>
</li>
<li>对于在同一AWS Direct Connect位置中请求的多个端口，Amazon本身确保在冗余Amazon路由器上配置它们以防止硬件故障的影响</li>
</ul>
<h2 id="Direct-Connect-LAG"><a href="#Direct-Connect-LAG" class="headerlink" title="Direct Connect LAG"></a>Direct Connect LAG</h2><ul>
<li>链接聚合组 (LAG) 是一个逻辑接口，使用链接聚合控制协议 (LACP) 在一个 AWS Direct Connect 终端节点处聚合多个连接，从而允许将这些连接视为一个托管连接</li>
<li>可从现有连接创建 LAG，也可配置新连接</li>
<li>在创建 LAG 之后，可将现有连接 (无论是独立连接还是其他 LAG 的一部分) 与 LAG 关联</li>
<li>LAG遵循以下规则<ol>
<li>LAG 中的所有连接都必须使用相同的带宽</li>
<li>LAG 中最多可有 4 个连接。LAG 中的每个连接都会计入区域的整体连接限制</li>
<li>LAG 中的所有连接都必须终止于同一 AWS Direct Connect 终端节点</li>
</ol>
</li>
</ul>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul>
<li>AWS Direct Connect user guide</li>
<li><a href="http://jayendrapatil.com/aws-direct-connect-dx" target="_blank" rel="noopener">http://jayendrapatil.com/aws-direct-connect-dx</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">seven</p>
              <p class="site-description motion-element" itemprop="description">seven 的精神家园，学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="1988xuegang@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">seven</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




<!-- 新增访客统计代码 -->

<div class="busuanzi-count">
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户： <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数： <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
    <!-- 博客字数统计 -->
    <span class="site-pv">
      <i class="fa fa-pencil"></i>
      博客全站共： <span class="post-count"></span> 字
    </span>
</div>
<!-- 新增访客统计代码 END-->


<!-- 在网页底部添加网站运行时间 -->
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("07/21/2018 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "Run for "+dnum+" Days ";
        document.getElementById("times").innerHTML = hnum + " Hours " + mnum + " m " + snum + " s";
    }
setInterval("createtime()",250);
</script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
