<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="seven 的精神家园，学习笔记">
<meta name="keywords" content="云计算,大数据，kuberntes">
<meta property="og:type" content="website">
<meta property="og:title" content="岳阳北寒">
<meta property="og:url" content="http://sevengarden.club/index.html">
<meta property="og:site_name" content="岳阳北寒">
<meta property="og:description" content="seven 的精神家园，学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="岳阳北寒">
<meta name="twitter:description" content="seven 的精神家园，学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sevengarden.club/">





  <title>岳阳北寒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">岳阳北寒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">要有最朴素的生活和最遥远的梦想，即使明日天寒地冻，路远马亡.......</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-somrthing">
          <a href="/有料" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            somrthing
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/30/AWS-DynamoDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/30/AWS-DynamoDB/" itemprop="url">AWS DynamoDB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-30T21:23:32+08:00">
                2019-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DynamoDB</p>
<ul>
<li>Amazon DynamoDB 是一种完全托管的 NoSQL 数据库服务，提供快速且可预测的性能，同时还能够实现无缝扩展</li>
<li>DynamoDB使客户能够将操作和扩展分布式数据库的管理负担卸载到AWS，而无需担心硬件配置，设置和配置，复制，软件修补或群集扩展。</li>
<li>DynamoDB表没有固定的模式，表由项组成，每个项可能具有不同数量的属性。</li>
<li>DynamoDB在AWS区域中的三个设施之间同步复制数据，从而提供高可用性和数据持久性。</li>
<li>DynamoDB支持快速就地更新。 可以使用单个API调用连续递增或递减数字属性</li>
<li>DynamoDB使用经过验证的加密方法来安全地验证用户身份并防止未经授权的数据访问</li>
<li>内置耐用性，性能，可靠性和安全性，具有SSD（固态驱动器）存储和自动3向复制。</li>
<li>DynamoDB吞吐量和单位数毫秒级延迟使其非常适合游戏，广告技术，移动和许多其他应用程序</li>
<li>ElastiCache可以在DynamoDB之前使用，以便为非频繁更改的数据卸载大量读取</li>
</ul>
<h2 id="DynamoDB-核心组件"><a href="#DynamoDB-核心组件" class="headerlink" title="DynamoDB 核心组件"></a>DynamoDB 核心组件</h2><ul>
<li>在 DynamoDB 中，表、项目和属性是使用的核心组件。表 是项目 的集合，而每个项目是属性 的集合。</li>
<li>DynamoDB 使用主键来唯一标识表中的每个项目，并且使用二级索引来提供更大的查询灵活性。</li>
<li>可以使用 DynamoDB 流 捕获 DynamoDB 表中的数据修改事件</li>
</ul>
<h3 id="表、项目和属性"><a href="#表、项目和属性" class="headerlink" title="表、项目和属性"></a>表、项目和属性</h3><ul>
<li>表 – 类似于其他数据库系统，DynamoDB 将数据存储在表中。表 是数据的集合。例如，请参阅名为 People 的示例表，该表可用于存储有关好友、家人或关注的任何其他人的个人联系信息。也可以建立一个 Cars 表，存储有关人们所驾驶的车辆的信息。</li>
<li>项目 – 每个表包含零个或更多个项目。项目 是一组属性，具有不同于所有其他项目的唯一标识。在 People 表中，每个项目表示一位人员。在 Cars 表中，每个项目代表一种车。DynamoDB 中的项目在很多方面都类似于其他数据库系统中的行、记录或元组。在 DynamoDB 中，对表中可存储的项目数没有限制。</li>
<li>属性 – 每个项目包含一个或多个属性。属性 是基础的数据元素，无需进一步分解。例如，People 表中的一个项目包含名为 PersonID、LastName、FirstName 等的属性。对于 Department 表，项目可能包含 DepartmentID、Name、Manager 等属性。DynamoDB 中的属性在很多方面都类似于其他数据库系统中的字段或列。</li>
</ul>
<p><img src="https://i.loli.net/2019/08/30/C9BSzdZ574DRbKr.png" alt="HowItWorksPeople.png"></p>
<ul>
<li>表中的每个项目都有一个唯一的标识符或主键，用于将项目与表中的所有其他内容区分开来。在 People 表中，主键包含一个属性 (PersonID)。</li>
<li>与主键不同，People 表是无架构的，这表示属性及其数据类型都不需要预先定义。每个项目都能拥有其自己的独特属性。</li>
<li>大多数属性是标量 类型的，这表示它们只能具有一个值。字符串和数字是标量的常见示例。</li>
<li>某些项目具有嵌套属性 (Address)。DynamoDB 支持最高 32 级深度的嵌套属性。<br><img src="https://i.loli.net/2019/08/30/GSYNeTnXLj5ECK6.png" alt="HowItWorksMusic.png"></li>
<li>Music 的主键包含两个属性（Artist 和 SongTitle）。表中的每个项目必须具有这两个属性。Artist 和 SongTitle 的属性组合用于将表中的每个项目与所有其他内容区分开来。</li>
<li>与主键不同，Music 表是无架构的，这表示属性及其数据类型都不需要预先定义。每个项目都能拥有其自己的独特属性。</li>
<li>其中一个项目具有嵌套属性 PromotionInfo，该属性包含其他嵌套属性。DynamoDB 支持最高 32 级深度的嵌套属性。</li>
</ul>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>DynamoDB 支持两种不同类型的主键：</p>
<ul>
<li><p>分区键 – 由一个名为 partition key 的属性构成的简单主键。</p>
<ul>
<li>DynamoDB 使用分区键的值作为内部散列函数的输入。来自散列函数的输出决定了项目将存储到的分区 (DynamoDB 内部的物理存储)。</li>
<li>在只有分区键的表中，任何两个项目都不能有相同的分区键值。</li>
<li>表、项目和属性 中所述的 People 表是带简单主键 (PersonID) 的示例表。可以直接访问 People 表中的任何项目，方法是提供该项目的 PersonId 值。</li>
</ul>
</li>
<li><p>分区键和排序键 – 称为复合主键，此类型的键由两个属性组成。第一个属性是分区键，第二个属性是排序键。</p>
<ul>
<li>DynamoDB 使用分区键值作为对内部散列函数的输入。来自散列函数的输出决定了项目将存储到的分区 (DynamoDB 内部的物理存储)。具有相同分区键值的所有项目按排序键值的排序顺序存储在一起。</li>
<li>在具有分区键和排序键的表中，两个项目可能具有相同的分区键值。但是，这两个项目必须具有不同的排序键值。</li>
<li>表、项目和属性中所述的 Music 表是包含一个复合主键（Artist 和 SongTitle）的表的示例。可以直接访问 Music 表中的任何项目，方法是提供该项目的 Artist 和 SongTitle 值。</li>
<li>在查询数据时，复合主键可让获得额外的灵活性。例如，如果仅提供了 Artist 的值，则 DynamoDB 将检索该艺术家的所有歌曲。要仅检索特定艺术家的一部分歌曲，可以提供一个 Artist 值和一系列 SongTitle 值。</li>
</ul>
</li>
<li><p>项目的分区键也称为其哈希属性。哈希属性 一词源自 DynamoDB 中使用的内部哈希函数，以基于数据项目的分区键值实现跨多个分区的数据项目平均分布。</p>
</li>
<li><p>项目的排序键也称为其范围属性。范围属性 一词源自 DynamoDB 存储项目的方式，它按照排序键值有序地将具有相同分区键的项目存储在互相紧邻的物理位置。</p>
</li>
<li><p>每个主键属性必须为标量 (表示它只能具有一个值)。主键属性唯一允许的数据类型是字符串、数字和二进制。对于其他非键属性没有任何此类限制。</p>
</li>
</ul>
<h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><ul>
<li>DynamoDB 支持两种索引：<ul>
<li>Global secondary index – 一种带有可能与表中不同的分区键和排序键的索引。</li>
<li>本地二级索引 – 分区键与表中的相同但排序键与表中的不同的索引。</li>
</ul>
</li>
<li>DynamoDB 中的每个表具有 20 个全局二级索引（默认限制）和 5 个本地二级索引的限制。</li>
<li>在前面显示的示例 Music 表中，可以按 Artist（分区键）或按 Artist 和 SongTitle（分区键和排序键）查询数据项。如果还想要按 Genre 和 AlbumTitle 查询数据，该怎么办？ 若要达到此目的，可在 Genre 和 AlbumTitle 上创建一个索引，然后通过与查询 Music 表相同的方式查询索引。</li>
<li>下图显示了示例 Music 表，该表包含一个名为 GenreAlbumTitle 的新索引。在索引中，Genre 是分区键，AlbumTitle 是排序键。<br><img src="https://i.loli.net/2019/08/30/YkLegfJ5RuO6cI4.png" alt="HowItWorksGenreAlbumTitle.png"><ul>
<li>每个索引属于一个表（称为索引的基表）。在上述示例中，Music 是 GenreAlbumTitle 索引的基表。</li>
<li>DynamoDB 将自动维护索引。当添加、更新或删除基表中的某个项目时，DynamoDB 会添加、更新或删除属于该表的任何索引中的对应项目。</li>
<li>当创建索引时，可指定哪些属性将从基表复制或投影 到索引。DynamoDB 至少会将键属性从基表投影到索引中。对于 GenreAlbumTitle 也是如此，只不过此时只有 Music 表中的键属性会投影到索引中。</li>
<li>可以查询 GenreAlbumTitle 索引以查找某个特定流派的所有专辑（例如，所有 Rock 专辑）。还可以查询索引以查找特定流派中具有特定专辑名称的所有专辑（例如，名称以字母 H 开头的所有 Country 专辑）。</li>
</ul>
</li>
</ul>
<h2 id="DynamoDB-流"><a href="#DynamoDB-流" class="headerlink" title="DynamoDB 流"></a>DynamoDB 流</h2><ul>
<li>DynamoDB 流 是一项可选功能，用于捕获 DynamoDB 表中的数据修改事件。有关这些事件的数据将以事件发生的顺序近乎实时地出现在流中。</li>
<li>每个事件由一条流记录 表示。如果对表启用流，则每当以下事件之一发生时，DynamoDB 流 都会写入一条流记录：<ul>
<li>向表中添加了新项目：流将捕获整个项目的映像，包括其所有属性。</li>
<li>更新了项目：流将捕获项目中已修改的任何属性的“之前”和“之后”映像。</li>
<li>从表中删除了项目：流将在整个项目被删除前捕获其映像。</li>
</ul>
</li>
<li>每条流记录还包含表的名称、事件时间戳和其他元数据。流记录具有 24 个小时的生命周期；在此时间过后，它们将从流中自动删除。</li>
</ul>
<h2 id="DynamoDB-性能"><a href="#DynamoDB-性能" class="headerlink" title="DynamoDB 性能"></a>DynamoDB 性能</h2><ul>
<li>自动水平缩放</li>
<li>固态硬盘（SSD）上运行<ul>
<li>SSD有助于实现可预测的低延迟响应时间的设计目标，以便以任何规模存储和访问数据。</li>
<li>SSD高I / O性能使其能够经济高效地为大规模请求工作负载提供服务，并以低请求定价传递此效率</li>
</ul>
</li>
<li>允许配置读写速率<ul>
<li>按需扩大吞吐量</li>
<li>每个UTC日历可以缩减吞吐量</li>
</ul>
</li>
<li>自动分区，重新分配和重新分区数据，并提供额外的服务器容量<ul>
<li>随着表的增大</li>
<li>预配置吞吐量增加</li>
</ul>
</li>
<li>全局二级索引<ul>
<li>可以预先创建或稍后添加</li>
</ul>
</li>
</ul>
<h2 id="DynamDB-一致性"><a href="#DynamDB-一致性" class="headerlink" title="DynamDB 一致性"></a>DynamDB 一致性</h2><ul>
<li>每个DynamoDB表自动存储在三个分散的地理位置，以确保数据一致性；</li>
<li>读取一致性表示在同一项的后续读取操作中反映数据项的成功写入或更新的方式和时间</li>
<li>DynamoDB 支持最终一致性 和强一致性 读取。<ul>
<li>最终一致性读取<ul>
<li>最终一致性选项可最大化读取吞吐量。</li>
<li>所有副本的一致性通常在一秒钟内达到</li>
<li>但是，最终一致的读取可能不会反映最近完成的写入的结果。</li>
<li>短时间后重复读取应返回更新的数据。 </li>
</ul>
</li>
<li>强一致性读取<ul>
<li>强一致性读取返回的结果反映了在读取之前收到成功响应的所有写入</li>
</ul>
</li>
</ul>
</li>
<li>Query，GetItem和BatchGetItem操作默认执行最终一致的读取<ul>
<li>Query和GetItem操作可以强制一致</li>
<li>查询操作无法对全局二级索引执行强一致性读取</li>
<li>可以强制BatchGetItem操作在每个表的基础上强一致</li>
</ul>
</li>
</ul>
<h2 id="DynamoDB-安全"><a href="#DynamoDB-安全" class="headerlink" title="DynamoDB 安全"></a>DynamoDB 安全</h2><ul>
<li>细粒度访问控制（FGAC）可以高度控制表中的数据</li>
<li>FGAC帮助控制谁（调用者）可以访问表的哪些项或属性并执行哪些操作（读/写功能）</li>
<li>FGAC与IAM集成，后者管理安全凭证和相关权限</li>
</ul>
<h2 id="DynamoDB跨区域复制"><a href="#DynamoDB跨区域复制" class="headerlink" title="DynamoDB跨区域复制"></a>DynamoDB跨区域复制</h2><ul>
<li><p>DynamoDB跨区域复制允许在一个或多个AWS区域中维护DynamoDB表（称为主表）的相同副本（称为副本）</p>
</li>
<li><p>对表的写入将自动传播到所有副本</p>
</li>
<li><p>跨区域复制当前支持单主模式。单主具有一个主表和一个或多个副本表</p>
</li>
<li><p>读取副本将异步更新，因为一旦主表接受了写入操作，DynamoDB就会将写入操作确认为成功。然后，写入将稍微延迟地传播到每个副本</p>
</li>
<li><p>跨区域复制在一下场景中很有用</p>
<ul>
<li>如果发生数据中心故障，则进行快速灾难恢复</li>
<li>通过从最近的AWS数据中心读取DynamoDB表，更快地提供数据，从而更快地为多个地区的客户进行读取。</li>
<li>更轻松的流量管理，可以跨表分配读取工作负载，从而在主表中消耗更少的读取容量。</li>
<li>通过提升读取副本成主来轻松实现区域迁移</li>
<li>实时数据迁移，复制数据以及表同步时，切换应用程序以写入目标区域</li>
</ul>
</li>
<li><p>跨区域复制成本取决于</p>
<ul>
<li>预配置吞吐量（写入和读取）</li>
<li>存储副本表的大小</li>
<li>跨地区的数据传输</li>
<li>从DynamoDB Streams读取数据以使表保持同步</li>
<li>根据实例类型和区域配置EC2实例的成本，以承载复制过程。</li>
</ul>
<p>注意：已执行DynamoDB上的跨区域复制，定义AWS Data Pipeline作业，该作业在DynamoDB流和开箱即用跨区域复制支持之前在内部使用EMR传输数据</p>
<h2 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h2><ul>
<li>Amazon DynamoDB 全局表 为部署多区域、多主机数据库提供了完全托管的解决方案，而不必构建和维护自己的复制解决方案。</li>
<li>可支持数据访问位置和数据库工作负载的区域容错</li>
<li>应用程序现在可以在世界各地的AWS区域中对DynamoDB执行读取和写入操作，任何区域中的更改都会传播到复制表的每个区域</li>
<li>全局表有助于构建应用程序以利用数据局部性来减少总体延迟。</li>
<li>全局表确保最终的一致性</li>
<li>全局表在单个AWS账户内的区域之间复制数据，目前不支持跨账户访问</li>
</ul>
<h2 id="DynamoDB-Streams"><a href="#DynamoDB-Streams" class="headerlink" title="DynamoDB Streams"></a>DynamoDB Streams</h2><ul>
<li>AWS 为 DynamoDB 和 DynamoDB 流 维护单独的终端节点。要使用数据库表和索引，应用程序需要访问 DynamoDB 终端节点。要读取和处理 DynamoDB 流 记录，应用程序需要访问相同区域内的 DynamoDB 流 终端节点</li>
<li>DynamoDB Streams提供按时间排序的项目级更改序列，在过去24小时内对表中的数据进行更改，之后将其删除</li>
<li>DynamoDB Streams维护每个项目的有序事件序列，但不维护项目例</li>
<li>例如，假设有一个DynamoDB表跟踪游戏的高分，并且表中的每个项目代表一个单独的玩家。如果按此顺序进行以下三次更新：  <ul>
<li>更新1：将玩家1的高分改为100分  </li>
<li>更新2：将玩家2的高分改为50分</li>
<li>更新3：将玩家1的高分改为125分</li>
<li>DynamoDB Streams将维护Player 1得分事件的顺序。但是，它不会维持玩家之间的秩序。因此，在2个玩家1事件之间无法保证玩家2得分事件</li>
</ul>
</li>
<li>DynamoDB 流 确保以下内容：<ul>
<li>每个流记录仅在流中显示一次。</li>
<li>对于 DynamoDB 表中修改的每个项目，流记录将按照对该项目进行的实际修改的顺序显示</li>
</ul>
</li>
<li>DynamoDB流可用于多区域复制，以使其他数据存储与DynamoDB的最新更改保持同步，或根据对表所做的更改执行操作</li>
<li>DynamoDB Streams API可帮助开发人员在更改项目之前和之后使用更新并接收项目级数据 </li>
<li>DynamoDB Streams允许读取速度高达DynamoDB表的预配置写入容量的两倍</li>
<li>必须基于每个表启用DynamoDB Streams</li>
</ul>
<h2 id="DynamoDB-触发器"><a href="#DynamoDB-触发器" class="headerlink" title="DynamoDB 触发器"></a>DynamoDB 触发器</h2><ul>
<li>DynamoDB触发器（就像数据库trigger）是一种允许基于表上的项级更新执行自定义操作的功能</li>
<li>DynamoDB触发器可用于发送通知，更新聚合表以及将DynamoDB表连接到其他数据源等方案</li>
<li>DynamoDB触发器流程<ul>
<li>DynamoDB触发器的自定义逻辑作为代码存储在AWS Lambda函数中。</li>
<li>可以通过将AWS Lambda函数与表上的流（通过DynamoDB Streams）相关联来创建给定表的触发器。</li>
<li>更新表后，更新将发布到DynamoDB Streams。</li>
<li>反过来，AWS Lambda从关联的流中读取更新并执行函数中的代码。</li>
</ul>
</li>
</ul>
<h2 id="DynamoDB-Accelerator-DAX"><a href="#DynamoDB-Accelerator-DAX" class="headerlink" title="DynamoDB Accelerator DAX"></a>DynamoDB Accelerator DAX</h2><ul>
<li>DynamoDB Accelerator（DAX）是DynamoDB的完全托管，高可用性内存缓存，可提供高达10倍的性能提升 - 从毫秒到微秒 - 甚至可达到每秒数百万个请求。</li>
<li>DAX完成了向表中添加内存加速所需的所有繁重工作，而无需开发人员管理缓存失效，数据填充或集群管理。</li>
<li>DAX具有容错性和可扩展性。</li>
<li>DAX群集具有主节点和零个或多个读副本节点。 当主节点发生故障时，DAX将自动进行故障转移并选择新的主节点。 对于缩放，添加或删除只读副本</li>
</ul>
<h2 id="VPC端点"><a href="#VPC端点" class="headerlink" title="VPC端点"></a>VPC端点</h2><ul>
<li>DynamoDB的VPC端点通过在VPC内启用对DynamoDB的私有访问，而无需Internet网关或NAT网关，从而提高了隐私和安全性，尤其是那些处理具有合规性和审计要求的敏感工作负载的端点。</li>
<li>DynamoDB的VPC端点支持IAM策略以简化DynamoDB访问控制，其中访问可以限制为特定的VPC端点。</li>
<li>只能为与VPC位于同一AWS区域中的Amazon DynamoDB表创建VPC端点</li>
<li>无法使用DynamoDB的VPC端点访问DynamoDB Streams</li>
</ul>
<h2 id="DynamoDB-加密"><a href="#DynamoDB-加密" class="headerlink" title="DynamoDB 加密"></a>DynamoDB 加密</h2><ul>
<li>传输加密<ul>
<li>可以通过在客户端加密敏感数据或使用加密连接（TLS）来完成</li>
</ul>
</li>
<li>静态加密<ul>
<li>存储在 Amazon DynamoDB 中的所有用户数据完全处于静态加密之中</li>
<li>DynamoDB 静态加密通过在加密表中保护数据来提供额外的一层数据保护，包括其主键、本地和全局二级索引、流、全局表、备份和 DynamoDB Accelerator (DAX) 集群</li>
<li>静态加密与 AWS KMS 集成，以管理用于加密表的加密密钥。</li>
<li>只能为新表启用静态加密，而不能为现有表启用加密</li>
<li>一旦为表启用加密，就无法禁用</li>
<li>DynamoDB Streams不支持加密</li>
<li>使用S3的服务器端加密对加密的DynamoDB表的按需备份进行加密</li>
<li>静态加密使用256位AES加密对数据进行加密。</li>
</ul>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li>使用的表的数量保持最小值</li>
<li>在DynamoDB中存储元数据，在Amazon S3中存储大型BLOB</li>
<li>使用每天，每周，每月等表来存储时间序列数据</li>
<li>使用条件或乐观并发控制（OCC）更新</li>
<li>乐观并发控制就像RDMS中的乐观锁定一样</li>
<li>OCC通常用于数据争用较少的环境，冲突很少，可以完成事务而无需管理锁和事务</li>
<li>OCC假设可以经常完成多个交易而不会相互干扰</li>
<li>使用数据资源执行事务，而不获取对这些资源的锁定并等待清除其他事务锁定</li>
<li>在提交事务之前，将验证数据是否被任何其他事务修改。如果是这样，它将被回滚并需要使用更新的数据重新启动</li>
<li>与其他并发控制方法（如悲观锁定）相比，OCC导致更高的吞吐量，因为即使在避免死锁时，锁定也会极大地限制有效并发性</li>
<li>避免热键和热分区</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/30/AWS-CloudFront/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/30/AWS-CloudFront/" itemprop="url">AWS CloudFront</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-30T19:44:53+08:00">
                2019-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CloudFront-overview"><a href="#CloudFront-overview" class="headerlink" title="CloudFront overview"></a>CloudFront overview</h2><ul>
<li>Amazon CloudFront 是一个 Web 服务，它加快将静态和动态 Web 内容（如 .html、.css、.js 和图像文件）分发到用户的速度</li>
<li>CloudFront 通过全球数据中心网络传输内容，这些数据中心称为边缘站点。当用户请求用 CloudFront 提供的内容时，用户被路由到提供最低延迟 (时间延迟) 的边缘站点，从而以尽可能最佳的性能传送内容</li>
<li>CloudFront通过将每个用户请求路由到最能为内容提供服务的边缘位置来加速内容的分发，从而提供最低的延迟</li>
<li>CloudFront可显着减少用户请求必须通过的网络跃点数，从而有助于提高性能，提供更低的延迟和更高的数据传输速率</li>
<li>CloudFront是分发经常访问的静态内容的最好选择，这些内容受益于边缘交付 - 如流行的网站图像，视频，媒体文件或软件下载</li>
</ul>
<h2 id="CloudFront-Benefits"><a href="#CloudFront-Benefits" class="headerlink" title="CloudFront Benefits"></a>CloudFront Benefits</h2><ul>
<li>CloudFront消除了在互联网上多个站点中进行缓存服务器网络的费用和复杂性，以及过度配置容量的需要，以便在潜在的流量爆发中也能提供服务</li>
<li>提供数据更高的可靠性和可用性，对象的副本保存在世界各地的边缘位置</li>
<li>CloudFront与源服务器保持持久连接，以便可以尽快从源服务器获取这些文件</li>
<li>在诸如多个用户同时在边缘位置同时获取相同源文件请求中，折叠请求次数，减少对源站点的负载</li>
<li>CloudFront与AWS WAF集成，后者一种web应用程序防火墙，允许通过基于IP地址，HTTP标头和自定义URL字符串配置的规则来保护web应用</li>
</ul>
<h2 id="Configuration-amp-Content-Delivery"><a href="#Configuration-amp-Content-Delivery" class="headerlink" title="Configuration &amp; Content Delivery"></a>Configuration &amp; Content Delivery</h2><ul>
<li>Configuration<ol>
<li>指定源服务器以获取要分发的文件。源服务器将存储对象的原始最终版本。如果通过 HTTP 提供内容，源服务器将为 Amazon S3 存储桶或 HTTP 服务器；使用 Adobe Media Server RTMP 协议按需分发媒体文件，则源服务器始终为 Amazon S3 存储桶</li>
<li>添加/上载到源服务器上的文件请使用公共读取权限或限制性OAI权限</li>
<li>创建一个 CloudFront 分配，在用户通过网站或应用程序请求文件时，这会指示 CloudFront 从哪些源服务器中获取文件</li>
<li>CloudFront 将分配的配置（而不是的内容）发送到它的所有边缘站点，边缘站点是位于地理位置分散的数据中心（CloudFront 在其中缓存对象的副本）的服务器集合</li>
<li>网站可与CloudFront提供的域名或自定义备用域名一起使用</li>
<li>Origin服务器可以配置为限制访问协议，缓存行为，向文件添加标头以添加TTL或到期时间</li>
</ol>
</li>
<li>Content delivery to users<ol>
<li>当用户访问网站时，DNS将请求路由指向到CloudFront边缘站点，该位置可以最低的延迟响应用户对网站文件或对象的访问</li>
<li>如果请求对象存在于edge 位置缓存中，则cloudfront会立即返回该对象</li>
<li>如果请求对象不在edge位置缓存中，则cloudfront会从origin服务器请求对象，并在它开始接收数据事就返回给用户</li>
<li>当对象到达其TTL值时，对于任何新请求，cloudfront会向origin服务器检查任何新版本，若有则更新，若没有则继续当前版本</li>
</ol>
</li>
</ul>
<h2 id="Delivery-Methods"><a href="#Delivery-Methods" class="headerlink" title="Delivery Methods"></a>Delivery Methods</h2><h3 id="Web-分发"><a href="#Web-分发" class="headerlink" title="Web 分发"></a>Web 分发</h3><ul>
<li>支持静态或动态内容，例如使用HTTP或HTTPS的html、css、js、图像等</li>
<li>多媒体内容支持HLS或渐进式下载使用<ul>
<li>对于按需流式传输，可以使用 CloudFront 以常见格式（如 MPEG DASH、Apple HLS、Microsoft 平滑流和 CMAF）将内容流式传输到任何设备。</li>
<li>对于广播实时流，可以在边缘站点缓存媒体片段，以便将按正确顺序传输片段的清单文件的多个请求组合起来，从而减小源服务器的负载</li>
</ul>
</li>
<li>只是实时活动内容，如会议、音乐会、演唱会等。对于实时数据流，可以使用AWS Cloudformation堆栈自动创建分发</li>
<li>源站可以是S3或HTTP服务器，如web server或ELB</li>
</ul>
<h3 id="RTMP分发"><a href="#RTMP分发" class="headerlink" title="RTMP分发"></a>RTMP分发</h3><ul>
<li>支持使用Adobe Media Server和Adobe实时消息传递协议（RTMP）传输媒体文件</li>
<li>必须使用S3作为源站</li>
<li>使用cloudfront流逝传输媒体文件，需要一下支持<ul>
<li>媒体文件</li>
<li>媒体播放器，JW Player，Flowplayer或Adobe Flash</li>
</ul>
</li>
<li>最终用户使用提供的媒体播放器查看媒体文件，而不是本地安装的播放器</li>
<li>用户使用流逝传输媒体文件时，一边播放一遍下载</li>
<li>媒体文件并不存放于本地存储系统上</li>
<li>需要创建两个cloudfront分配，媒体播放器的web分发和媒体文件的RMTP分发</li>
<li>媒体播放器和媒体文件可以存储在同一个源S3或不同bucket中</li>
</ul>
<h3 id="源"><a href="#源" class="headerlink" title="源"></a>源</h3><ul>
<li>源站可以是S3或者HTTP服务器</li>
<li>HTTP服务器作为源站，需要映射其资源的域名，且文件必须是公共可读的</li>
<li>对于使用S3 作为源站，使用bucket地址或静态网址端点地址，文件需要公开读取或OAI受限保护</li>
<li>可以使用Origin Access Identity配置源限制访问（仅限S3），以防止直接访问S3对象</li>
<li>每个存储同，支持分配多个源，并将其用户请求分配到不同的缓存规则上。缓存行为中的路径模式决定哪些请求路由到与缓存行为关联的源(S3 bucket)</li>
</ul>
<h2 id="Cache-behavior"><a href="#Cache-behavior" class="headerlink" title="Cache behavior"></a>Cache behavior</h2><p>缓存行为为网站上文件的特定 URL 路径模式配置各种 CloudFront 功能</p>
<ul>
<li>路径模式。</li>
<li>如果为 CloudFront 分配配置了多个源，希望 CloudFront 将的请求转发到哪个源。</li>
<li>是否将查询字符串转发到源。</li>
<li>是否访问指定文件需要签名 URL。</li>
<li>是否要求用户使用 HTTPS 访问那些文件。</li>
<li>那些文件保留在 CloudFront 缓存中的最小时间长度，不管源添加到文件中的任何 Cache-Control 标头的值。</li>
</ul>
<h2 id="Vuewer-Protocol-Policy"><a href="#Vuewer-Protocol-Policy" class="headerlink" title="Vuewer Protocol Policy"></a>Vuewer Protocol Policy</h2><blockquote>
<p>可以配置查看器协议策略以定义允许的访问协议。 可以是HTTP和HTTPS，也可以是仅HTTPS或HTTP重定向到HTTPS</p>
</blockquote>
<h3 id="HTTPS-connection"><a href="#HTTPS-connection" class="headerlink" title="HTTPS connection"></a>HTTPS connection</h3><ul>
<li>在CloudFront和Viewers之间，可以将缓存分发配置为允许HTTP或HTTPS请求，或仅使用HTTPS，或将所有HTTP请求重定向到HTTPS</li>
<li>在CloudFront和Origin之间，可以将缓存分布配置为要求CloudFront使用HTTPS从源中提取对象，或者CloudFront使用查看器用于请求对象的协议。</li>
<li>S3 作为源站<ul>
<li>对于网站，协议必须是HTTP，因为不支持HTTPS</li>
<li>对于S3存储桶，默认的Origin协议策略是Match Viewer，无法更改。 因此，当CloudFront配置为在查看器和CloudFront之间需要HTTPS时，它会自动使用HTTPS与S3通信。</li>
</ul>
</li>
<li>通过使用以下方法，还可以将CloudFront配置为使用HTTPS处理备用域名： <ul>
<li>使用专用IP地址提供HTTPS请求</li>
<li>CloudFront将备用域名与专用IP地址相关联，并且证书与IP地址关联。 当从DNS服务器收到IP地址的请求时，</li>
<li>CloudFront使用IP地址标识分发和SSL / TLS证书以返回给查看者</li>
<li>无论用户使用何种浏览器或其他查看器，此方法都适用于每个HTTPS请求。</li>
<li>使用专用IP地址会产生额外的每月费用</li>
</ul>
</li>
<li>使用SNI提供HTTPS请求<ul>
<li>SNI自定义SSL依赖于TLS协议的SNI扩展，它允许通过包含主机名在同一IP地址上提供多个域</li>
<li>使用SNI方法，CloudFront将IP地址与备用域名相关联，但IP地址不是专用的</li>
<li>CloudFront无法根据IP地址确定请求所针对的域，因为IP地址不是专用的 </li>
<li>支持SNI的浏览器会自动从请求URL获取域名，并将其添加到请求标头中的新字段。</li>
<li>当CloudFront从支持SNI的浏览器收到HTTPS请求时，它会在请求标头中找到域名，并使用适用的SSL / TLS证书响应该请求。</li>
<li>Viewer和CloudFront执行SSL协商，CloudFront将请求的内容返回给查看器。</li>
<li>较旧的浏览器不支持它</li>
<li>除标准CloudFront数据传输和请求费用外，SNI Custom SSL无需额外费用</li>
</ul>
</li>
<li>对于端到端HTTPS连接，需要在Viewers和CloudFront＆CloudFront和Origin之间应用证书，并满足以下要求<ul>
<li>查看者和CloudFront之间的HTTPS<ul>
<li>由受信任的证书颁发机构（CA）（如Comodo，DigiCert或Symantec）颁发的证书;</li>
<li>由AWS Certificate Manager（ACM）提供的证书;</li>
<li>自签名证书。</li>
<li>CloudFront与自定义源之间的HTTPS</li>
<li>如果源不是ELB负载平衡器，则证书必须由受信任的CA（如Comodo，DigiCert或Symantec）颁发。</li>
<li>对于ELB负载平衡器，可以使用ACM提供的证书</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="允许的HTTP-方法"><a href="#允许的HTTP-方法" class="headerlink" title="允许的HTTP 方法"></a>允许的HTTP 方法</h3><ul>
<li>CloudFront支持GET，HEAD，OPTIONS，PUT，POST，PATCH，DELETE来获取，添加，更新和删除对象，以及获取对象标头。</li>
<li>GET，HEAD，OPTIONS方法仅使用CloudFront获取对象，对象标题或检索从源支持的选项列表</li>
<li>POST，PUT操作也可以用于加速，例如PUT操作，从Web表单提交数据，这些数据直接代理回原始服务器</li>
<li>CloudFront仅缓存对GET和HEAD请求以及（可选）OPTIONS请求的响应。 CloudFront不会缓存对PUT，POST，PATCH，DELETE请求方法的响应，并且这些请求将定向到源</li>
<li>PUT，POST http方法也有助于加速内容上传，因为这些操作将被发送到源，例如S3通过CloudFront边缘位置，提高效率，减少延迟，并允许应用程序受益于CloudFront从边缘位置到源服务器维护的受监视的持久连接</li>
</ul>
<h3 id="优化缓存和可用性"><a href="#优化缓存和可用性" class="headerlink" title="优化缓存和可用性"></a>优化缓存和可用性</h3><ul>
<li>控制cache max-age<ul>
<li>要增加缓存命中率，可以将origin配置为向对象添加Cache-Control max-age指令。</li>
<li>间隔越长，从原点检索的频率越低</li>
</ul>
</li>
<li>针对查询字符串参数进行缓存<ul>
<li>对于Web分发，可以将CloudFront配置为基于查询参数进行缓存</li>
<li>缓存性能可以提高<ul>
<li>将CloudFront配置为仅转发源将返回唯一对象的查询字符串。</li>
<li>对于例如参数值使用相同的情况。 参数值A或a，即使返回的响应或对象相同，CloudFront也会将相同的请求缓存两次</li>
<li>使用相同的参数顺序，例如 对于请求a = x＆b = y和b = y＆a = x，即使返回的响应或对象相同，CloudFront也会缓存相同的请求两次</li>
<li>对于RTMP分发，当CloudFront从源服务器请求对象时，它会删除任何查询字符串参数。</li>
</ul>
</li>
</ul>
</li>
<li>基于Cookie值的缓存<ul>
<li>对于Web分发，可以将CloudFront配置为基于cookie值进行缓存。</li>
<li>默认情况下，它在边缘位置缓存时不考虑cookie</li>
<li>缓存性能可以通过以下提高<ul>
<li>将 CloudFront 配置为仅转发指定的 Cookie 而不是转发所有 Cookie。对于配置 CloudFront 以转发到源的 Cookie，CloudFront 转发 Cookie 名称和值的所有组合，并分别缓存源返回的对象，即使这些对象完全相同。例如，如果请求包含2个包含3个可能值的cookie，则即使响应考虑了单个cookie，CloudFront也会缓存所有可能的组合，Cookie名称和值都区分大小写，因此最好坚持使用相同的大小写<ul>
<li>为静态和动态内容创建单独的缓存行为，并将CloudFront配置为仅将Cookie转发到源，例如用于动态内容。对于css文件，cookie没有意义，因为对象不会随cookie值而改变</li>
</ul>
</li>
<li>如果可能，为动态内容创建单独的缓存行为，对于每个用户，cookie值是唯一的（例如用户ID），动态内容根据较少数量的唯一值而变化，从而减少组合的数量</li>
</ul>
</li>
<li>对于RTMP分发，无法配置CloudFront进行处理cookie<ul>
<li>当CloudFront从源服务器请求对象时，它会在将请求转发到源之前删除所有cookie。 如果源返回任何cookie以及对象CloudFront在将对象返回给查看器之前删除它们。</li>
</ul>
</li>
</ul>
</li>
<li>请求标头进行缓存<ul>
<li>默认情况下，CloudFront在边缘位置缓存对象时不考虑标头。</li>
<li>CloudFront配置为基于请求标头进行缓存，不会更改CloudFront转发的标头，只会更改CloudFront是否根据标头值缓存对象</li>
<li>通过以下方式提高缓存性能<ul>
<li>将 CloudFront 配置为仅基于指定标头进行转发和缓存，而不是基于所有标头转发和缓存</li>
<li>尝试避免基于具有大量唯一值的请求标头进行缓存</li>
<li>CloudFront配置为将所有标头转发到源，CloudFront不会缓存与此缓存行为关联的对象。 相反，它将每个请求发送到原点</li>
<li>CloudFront基于标头值进行缓存，它不考虑标题名称的情况，但考虑标题值的情况</li>
</ul>
</li>
<li>对于RTMP分发，无法将CloudFront配置为基于标头值进行缓存。</li>
</ul>
</li>
</ul>
<h3 id="对象缓存和过期"><a href="#对象缓存和过期" class="headerlink" title="对象缓存和过期"></a>对象缓存和过期</h3><ul>
<li>对象到期时间即对象在从Origin再次获取之前保留在CloudFront缓存中的时间</li>
<li>低过期时间有助于提供频繁更改的内容，长过期时间有助于提高性能并减少原始负载</li>
<li>到期时间后，CloudFront会检查它是否仍具有最新版本</li>
<li>到期时间后，CloudFront会检查它是否仍具有最新版本<ul>
<li>如果缓存已具有最新版本，则origin返回304状态代码（未修改）。</li>
<li>如果CloudFront缓存没有最新版本，则原点返回200状态代码（OK）和对象的最新版本</li>
</ul>
</li>
<li>如果不经常请求边缘位置中的对象，CloudFront可能会逐出该对象，在其到期日期之前删除该对象，以便为最近请求的对象腾出空间。</li>
<li>默认情况下，每个对象在24小时后自动过期</li>
<li>对于Web分发，可以通过更改默认行为<ul>
<li>对于整个路径模式，可以通过设置Minimum TTL，Maximum TTL和Default TTL值来配置缓存行为</li>
<li>对于单个对象，可以将origin配置为向对象添加Cache-Control max-age或Cache-Control s-maxage指令或Expires头字段。</li>
<li>AWS建议在Expires标头上使用Cache-Control max-age指令来控制对象缓存行为</li>
<li>如果同时指定了Cache-Control max-age指令和Expires标头，则CloudFront仅使用<strong>Cache-Control max-age</strong>的值</li>
<li>来自查看器的GET请求中的HTTP Cache-Control或Pragma标头字段不能用于强制CloudFront返回到对象的源服务器</li>
<li>默认情况下，当原始返回HTTP 4xx或5xx状态代码时，CloudFront会将这些错误响应缓存五分钟，然后将该对象的下一个请求提交到原点以查看是否请求的对象可用</li>
</ul>
</li>
<li>对于RTMP分发<ul>
<li>可以将Cache-Control或Expires标头添加到对象，以更改CloudFront在将另一个请求转发到源之前将对象保留在边缓存中的时间。</li>
<li>最短持续时间为3600秒（一小时）。如果指定较低的值，CloudFront将使用3600秒。  </li>
</ul>
</li>
</ul>
<h2 id="配置安全访问和限制对内容的访问"><a href="#配置安全访问和限制对内容的访问" class="headerlink" title="配置安全访问和限制对内容的访问"></a>配置安全访问和限制对内容的访问</h2><h3 id="提供私有内容"><a href="#提供私有内容" class="headerlink" title="提供私有内容"></a>提供私有内容</h3><ul>
<li>可采用两种方式控制用户对私有内容的访问，如下图所示：<ul>
<li>限制对 CloudFront 边缘缓存中的文件的访问</li>
<li>通过执行下列操作之一，限制对源中文件的访问：<ul>
<li>为 Amazon S3 存储桶（除非已将其配置为网站终端节点）设置源访问身份 (OAI)</li>
<li>为私有 HTTP 服务器配置自定义标头或者将 Amazon S3 存储桶配置作为网站终端节点<br><img src="https://i.loli.net/2019/08/30/d2QlFRyZ4nkm6c8.png" alt="001.png"></li>
</ul>
</li>
</ul>
</li>
<li>创建签名 URL 或签名 Cookie 以控制对文件的访问时，可以指定以下限制：<ul>
<li>结束日期和时间，在此之后，URL 不再有效</li>
<li>（可选）URL 生效的日期和时间</li>
<li>（可选）可用于访问内容的 IP 地址或计算机的地址范围</li>
</ul>
</li>
<li>选择保护 Amazon S3 存储桶中的内容，以便用户可以通过 CloudFront 访问内容，但无法使用 Amazon S3 URL 直接访问内容。这可防止其他人绕过 CloudFront 并使用 Amazon S3 URL 访问希望限制访问的内容。虽然此步骤未要求使用签名 URL，但我们建议使用。</li>
<li>签名URL或签名Cookie可以使用HTTP服务器作为源，与CloudFront一起使用。 它要求内容可公开访问，并且应注意不要共享内容的直接URL</li>
<li>源端限制可适用于<ul>
<li>对于S3，使用Origin Access Identity仅使用Bucket策略或Object ACL授予CloudFront访问权限，以及删除任何其他访问权限</li>
<li>对于HTTP服务器，可以通过CloudFront添加自定义标头，可以在Origin使用它来验证请求来自CloudFront</li>
</ul>
</li>
</ul>
<h3 id="可信签署人"><a href="#可信签署人" class="headerlink" title="可信签署人"></a>可信签署人</h3><ul>
<li>要创建签名 URL 或签名 Cookie，至少需要一个具有有效 CloudFront 密钥对的 AWS 账户。该账户被称为可信签署人。</li>
<li>只要将可信签署人的 AWS 账户 ID 添加到分配中，CloudFront 就会立即开始要求用户使用签名 URL 或签名 Cookie 访问文件</li>
<li>创建签名 URL 或签名 Cookie 时，使用可信签署人的私有密钥来签署 URL 或 Cookie 的一部分。当某人请求限制的文件时，CloudFront 会比较 URL 或 Cookie 的已签名部分与未签名部分，以确认 URL 或 Cookie 未被篡改。CloudFront 还会验证 URL 或 Cookie 是否有效，例如是否未超过过期日期和时间</li>
<li>指定可信签署人时，还会间接指定要求签名 URL 或签名 Cookie 的文件：<ul>
<li>Web 分配 – 将可信签署人添加到缓存行为中。如果分配只有一个缓存行为，用户则必须使用签名 URL 或签名 Cookie 访问与该分配关联的任何文件。如果创建了多个缓存行为，并将可信签署人添加到某些缓存行为中而没有添加到其他缓存行为中，则可要求用户使用签名 URL 或签名 Cookie 访问某些文件而不是其他文件。</li>
<li>RTMP 分配（仅签名 URL） – 将可信签署人添加到分配中。在将可信签署人添加到 RTMP 分配后，用户必须使用签名 URL 访问与该分配相关联的任何文件。</li>
</ul>
</li>
<li>用于创建CloudFront签名URL或签名cookie的每个可信签署者AWS账户必须拥有自己的活动CloudFront密钥对，应该经常轮换</li>
<li>每个缓存行为或RTMP分配最多可以分配5个可信签名者</li>
</ul>
<h3 id="签名URL-vs-签名cookie"><a href="#签名URL-vs-签名cookie" class="headerlink" title="签名URL vs 签名cookie"></a>签名URL vs 签名cookie</h3><ul>
<li>在以下情况下使用签名 URL：<ul>
<li>希望使用 RTMP 分配。RTMP 分配不支持签名 Cookie。</li>
<li>希望限制对单个文件的访问，例如应用程序的安装程序下载。</li>
<li>用户使用不支持 Cookie 的客户端 (例如，自定义 HTTP 客户端)。</li>
</ul>
</li>
<li>在以下情况下使用签名 Cookie：<ul>
<li>希望提供对多个限制文件的访问，例如，HLS 格式视频的所有文件或者网站订户区域中的所有文件。</li>
<li>不希望更改当前 URL。</li>
</ul>
</li>
</ul>
<h3 id="标准策略-vs-自定义策略"><a href="#标准策略-vs-自定义策略" class="headerlink" title="标准策略 vs 自定义策略"></a>标准策略 vs 自定义策略</h3><ul>
<li>创建签名 URL 时，需要编写 JSON 格式的策略声明，以指定对签名 URL 的限制，例如，URL 的有效期。可以使用标准策略或自定义策略。以下是标准策略和自定义策略的比较</li>
</ul>
<table>
<thead>
<tr>
<th>描述</th>
<th>标准策略</th>
<th>自定义策略</th>
</tr>
</thead>
<tbody><tr>
<td>可对多个文件重复使用策略声明。要重复使用策略声明，必须在 Resource 对象中使用通配符。有关更多信息，请参阅 在使用自定义策略的签名 URL 的策略声明中指定的值。)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>可指定用户开始访问内容的日期和时间。</td>
<td>否</td>
<td>是（可选）</td>
</tr>
<tr>
<td>可指定用户无法再访问内容的日期和时间。</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可指定能够访问内容的用户的 IP 地址或 IP 地址范围。</td>
<td>否</td>
<td>是（可选）</td>
</tr>
<tr>
<td>签名 URL 包括策略的 Base64 编码版本，这会导致更长的 URL。</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<ul>
<li>CloudFront 何时检查签名 URL 中的过期日期和时间来确定该 URL 是否仍有效，取决于该 URL 是用于 Web 分配还是用于 RTMP 分配<ul>
<li>Web 分配 – 在发出 HTTP 请求时，CloudFront 检查签名 URL 中的过期日期和时间。如果客户端刚好在过期时间之前开始下载大型文件，即使在下载过程中到了过期时间，该下载也应该完成。如果客户端使用 Range GET 来获取较小的文件，在过期时间到期后发生的任何 GET 请求将会失败。</li>
<li>RTMP分配 - 播放事件开始时，CloudFront 检查签名 URL 中的过期时间。如果客户端在过期时间到期之前开始播放媒体文件，CloudFront 将允许播放整个媒体文件。然而，根据媒体播放器，暂停和重新开始可能触发另一个播放事件。跳到媒体文件中另一个位置将触发另一个播放事件。如果在过期时间到期后发生播放事件，CloudFront 不会提供媒体文件。</li>
</ul>
</li>
</ul>
<h3 id="提供压缩"><a href="#提供压缩" class="headerlink" title="提供压缩"></a>提供压缩</h3><ul>
<li>将 CloudFront 配置为在查看器请求的请求标头中包含 Accept-Encoding: gzip 时自动压缩某些类型的文件，并提供压缩文件</li>
<li>在压缩内容时，由于文件更小，因此下载速度更快，在某些情况下，大小不到原件的四分之一。—特别是对于 JavaScript 和 CSS 文件，更快的下载转化为向用户更快地提供网页。</li>
<li>查看器请求必须在请求标头中包含 Accept-Encoding: gzip，否则，CloudFront 不会压缩请求的文件</li>
<li>如果使用自定义或 Amazon S3 源，可以将源配置为使用或不使用 CloudFront 压缩功能压缩文件。源可以压缩 CloudFront 无法压缩的文件类型。</li>
<li>如果源向 CloudFront 返回压缩文件，CloudFront 将根据 Content-Encoding 标头值检测到已压缩该文件，而不会再次压缩该文件。</li>
<li>使用 CloudFront 压缩内容<ol>
<li>创建或更新 CloudFront 分配，并配置 CloudFront 以压缩内容。</li>
<li>查看器请求文件。查看器将 Accept-Encoding: gzip 标头添加到请求中。这表示查看器支持压缩的内容。</li>
<li>在边缘站点，CloudFront 将在缓存中检查请求中引用的文件的压缩版本。</li>
<li>如果压缩的文件已在缓存中，则 CloudFront 将文件返回到查看器并跳过剩余步骤。</li>
<li>如果压缩文件没有位于缓存中，则 CloudFront 将请求转发到源服务器，它可以是 Amazon S3 存储桶或自定义源。</li>
<li>源服务器将请求文件的未压缩版本返回到 CloudFront。</li>
<li>CloudFront 确定文件是否可压缩：<ul>
<li>文件必须是 CloudFront 可压缩的类型。</li>
<li>文件大小必须介于 1000 和 10000000 字节之间。</li>
<li>响应必须包含 Content-Length 标头，以便 CloudFront 可以确定文件大小是否在 CloudFront 压缩的范围内。如果缺少    </li>
<li>Content-Length 标头，则 CloudFront 不会压缩文件。</li>
<li>该响应不得包含 Content-Encoding 标头。</li>
</ul>
<ol start="8">
<li>如果文件是可压缩的，则 CloudFront 将压缩文件，将压缩后的文件返回到查看器并将它添加到缓存中。</li>
<li>查看器将解压缩文件。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="Distribution-Details"><a href="#Distribution-Details" class="headerlink" title="Distribution Details"></a>Distribution Details</h2><h3 id="替代域名（CNAME）"><a href="#替代域名（CNAME）" class="headerlink" title="替代域名（CNAME）"></a>替代域名（CNAME）</h3><ul>
<li>默认情况下，CloudFront为分发分配域名，例如d111111abcdef8.cloudfront.net</li>
<li>备用域名（也称为CNAME）可用于将自己的自定义域名用于指向对象的链接</li>
<li>Web和RTMP分发都支持备用域名。</li>
<li>CloudFront在域名开头支持*通配符，而不是单独指定子域。</li>
<li>但是，通配符不能替换部分子域名，例如， * domain.example.com，或者不能替换域名中间的子域名，例如子域.*.example.com</li>
</ul>
<h3 id="限制内容的地理分配"><a href="#限制内容的地理分配" class="headerlink" title="限制内容的地理分配"></a>限制内容的地理分配</h3><ul>
<li>当用户请求内容时，CloudFront 通常会提供请求的内容，而不考虑用户所在的位置。如果需要阻止特定国家/地区的用户访问内容，可以使用 CloudFront 地理限制功能来执行下列操作之一：<ul>
<li>仅当用户位于批准的国家/地区白名单中的某个国家/地区时，才允许他们访问内容。</li>
<li>当用户位于阻止的国家/地区黑名单中的某个国家/地区时，阻止他们访问内容。<blockquote>
<p>CloudFront 使用第三方 GeoIP 数据库确定用户的位置。IP 地址和国家/地区之间映射的准确性因区域而异。根据最近的测试，整体准确性为 99.8%。请注意，如果 CloudFront 无法确定用户的位置，CloudFront 将提供用户请求的内容。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="CloudFront与Amazon-S3"><a href="#CloudFront与Amazon-S3" class="headerlink" title="CloudFront与Amazon S3"></a>CloudFront与Amazon S3</h3><ul>
<li>CloudFront可用于分发S3存储桶中的内容</li>
<li>对于RTMP分发，S3存储区是唯一受支持的源，并且不能使用自定义源</li>
<li>在S3上使用CloudFront具有以下优势<ul>
<li>如果在更高的使用频率下频繁访问对象，则可以更具成本效益，CloudFront数据传输的价格远低于S3数据传输的价格。</li>
<li>CloudFront的下载速度比单独使用S3更快，因为对象存储的距离更接近用户</li>
<li>当使用S3作为分发的原点并将存储桶移动到其他区域时，如果满足以下两个条件，则CloudFront最多可能需要一个小时来更新其记录以包括区域更改：<ul>
<li>源访问标识（OAI）用于限制对存储桶的访问</li>
<li>存储桶被移动到需要签名版本4进行身份验证的S3区域</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="源站访问识别"><a href="#源站访问识别" class="headerlink" title="源站访问识别"></a>源站访问识别</h3><ul>
<li>以S3为源站，S3中的对象必须被授予公共读取权限，因此可以从S3和CloudFront访问对象</li>
<li>尽管CloudFront不公开底层S3 URL，但如果直接共享或由应用程序使用，则可以为用户所知</li>
<li>要使用CloudFront签名URL或签名cookie来提供对对象的访问，有必要阻止用户直接访问S3对象</li>
<li>直接访问S3对象会导致 <ul>
<li>绕过CloudFront签名URL或签名cookie提供的控制，例如，控制用户无法再访问内容的日期时间，并且IP地址可用于访问内容</li>
<li>CloudFront访问日志不太有用，因为它们不完整。</li>
</ul>
</li>
<li>源访问标识（OAI）可用于防止用户直接从S3访问对象</li>
<li>可以创建原始访问标识（一种特殊的CloudFront用户）并将其与分发相关联。</li>
<li>需要将S3存储桶/对象权限配置为仅提供对源访问标识的访问</li>
<li>当用户从CloudFront访问该对象时，它使用OAI代表用户获取内容，同时限制对S3对象的直接访问</li>
</ul>
<h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><ul>
<li>CloudFront可以配置为包括自定义标头或修改现有标头，只要它将请求转发到源</li>
<li>验证用户没有直接访问源，绕过CDN</li>
<li>如果用户使用不支持CORS的查看器，请配置CloudFront以将Origin标头转发到源。 这将导致origin为每个请求返回Access-Control-Allow-Origin标头</li>
</ul>
<h3 id="添加和更新对象"><a href="#添加和更新对象" class="headerlink" title="添加和更新对象"></a>添加和更新对象</h3><ul>
<li>只需要将对象添加爱到Origin，CloudFront将在访问时开发分发他们</li>
<li>通过以下方式更新<ul>
<li>覆盖原始对象</li>
<li>创建不同的版本并更新向用户公开的链接</li>
</ul>
</li>
<li>为了更新对象，建议使用版本控制，例如拥有文件或带有版本的整个文件夹，因此在更新对象时强制刷新可以更改链接</li>
<li>版本控制<ul>
<li>在CloudFront开始提供新版本之前，没有时间等待对象过期</li>
<li>从边缘提供的对象的一致性没有差异</li>
<li>支付对象失效不涉及任何费用。</li>
</ul>
</li>
</ul>
<h3 id="删除-使对象无效"><a href="#删除-使对象无效" class="headerlink" title="删除/使对象无效"></a>删除/使对象无效</h3><ul>
<li>默认情况下，对象将在到期时被删除（TTL），并且最新的对象将从Origin获取</li>
<li>对象也可以在到期之前从边缘缓存中删除<ul>
<li>更改对象名称（版本控制）已提供具有不同名称的对象的不同版本</li>
<li>在边缘缓存中使对象失效，对于下一个请求，cloudfront返回到Origin以获取对象</li>
</ul>
</li>
<li>Web分发<ul>
<li>如果需要频繁更新对象，则建议更改对象名称（版本控制），而不是像对象那样更改对象<ul>
<li>即使用户在本地或在缓存代理后面缓存了版本，也可以控制请求返回的对象。如果对象无效，则用户可能会继续查看旧版本，直到它们从这些缓存过期。</li>
<li>由于CloudFront访问日志包含对象的名称，因此可以更轻松地分析对象更改的结果</li>
<li>提供了向不同用户提供不同版本的方法。</li>
<li>简化了对象修订之间的前滚和后退。</li>
<li>更便宜，因为没有收取使对象无效的费用。</li>
<li>例如将header-v1.jpg更改为header-v2.jpg</li>
</ul>
</li>
<li>使缓存中的对象失效<ul>
<li>缓存中的对象可以在它们到期之前显式无效以强制刷新</li>
<li>允许使所选对象无效</li>
<li>允许使多个对象无效，例如如果目录中的对象或名称以相同字符开头的所有对象，则可以在失效路径的末尾包含*通配符</li>
<li>无效路径可以用于例如单个对象。 /js/ab.js或多个对象，例如： / js / <em>并且即使</em>通配符请求可能使数千个对象无效，也会被计为单个请求</li>
</ul>
</li>
</ul>
</li>
<li>对于RTMP分发，对象不能无效</li>
</ul>
<h3 id="Range-GETS"><a href="#Range-GETS" class="headerlink" title="Range GETS"></a>Range GETS</h3><ul>
<li>在GET请求中使用Range标头的部分请求有助于以较小的单位下载对象，从而提高部分下载的效率和部分失败的传输的恢复。</li>
<li>对于partial get 请求，cloudfront <ul>
<li>检查边缘位置中的缓存是否包含请求的范围或整个对象，如果存在，则立即提供</li>
<li>如果请求的范围不存在，它会将请求转发到源，并且可能请求比客户端请求更大的范围以优化性能</li>
<li>如果origin支持范围标头，则返回请求的对象范围，CloudFront将其返回给查看器</li>
<li>如果原点不支持范围标题，则返回完整对象，CloudFront将为整个对象提供服务并将其缓存以备将来使用。</li>
<li>CloudFront使用缓存的整个对象来提供任何未来范围的GET标头请求</li>
</ul>
</li>
</ul>
<h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><ul>
<li>可以将CloudFront配置为创建包含有关CloudFront接收的每个用户请求的详细信息的日志文件</li>
<li>可用于Web和RTMP分发</li>
<li>启用日志记录后，可以指定一个S3存储桶，CloudFront将保存文件</li>
<li>CloudFront定期为分发提供访问日志，最多可达一小时几次</li>
<li>CloudFront通常会在日志中显示的事件的一小时内将该时间段的日志文件传递到S3存储桶。 但请注意，某段时间内的某些或所有日志文件条目有时可能会延迟最多24小时</li>
</ul>
<h2 id="CloudFront-费用"><a href="#CloudFront-费用" class="headerlink" title="CloudFront 费用"></a>CloudFront 费用</h2><ol>
<li>数据传输到Internet<ul>
<li>对于从CloudFront边缘位置传输的数据量，将收取费用，以GB为单位</li>
<li>不再收取从AWS源（例如，S3，EC2等）到CloudFront的数据传输。</li>
<li>适用于从所有AWS区域到所有全球CloudFront边缘位置的数据传输</li>
</ul>
</li>
<li>HTTP/HTTPS 请求<ul>
<li>为内容进行的HTTP / HTTPS请求数</li>
</ul>
</li>
<li>失效请求<ul>
<li>无效请求中的每个路径</li>
<li>失效请求中列出的路径表示要从CloudFront缓存中失效的对象的URL（如果路径包含通配符，则为多个URL）</li>
</ul>
</li>
<li>与Cloudfront分配相关联的专用IP 自定义SSL证书</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/28/AWS-Elastic-LoadBalancer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/AWS-Elastic-LoadBalancer/" itemprop="url">AWS Elastic LoadBalancer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T21:08:05+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Elastic Load Balancing 在多个目标（如 Amazon EC2 实例、容器、IP 地址和 Lambda 函数）之间自动分配传入的应用程序流量</li>
<li>ELB作为客户侧访问的单一入口</li>
<li>ELB通过允许在一个或多个可用区域中添加或删除多个EC2实例来帮助透明并提高应用程序可用性，而不会中断业务流量</li>
<li>ELB的优势<ul>
<li>自身设计是一个高度容错和自动监控的分布式系统</li>
<li>简化管理、维护和扩展负载均衡的复杂性</li>
<li>可以是抵御网络攻击的第一道防线</li>
<li>可以卸载加密和解密（SSL终止）的工作，以便于EX2实例专注于自身负载</li>
<li>与Auto Scaling集成，可确保有足够的后端容量，以满足不同的流量压力</li>
<li>非单点故障</li>
</ul>
</li>
<li>默认情况下，Elastic Load Balancer将每个请求独立地路由到具有最小负载的已注册实例。</li>
<li>如果EC2实例失败，ELB会自动将流量重新路由到剩余正在运行的健康EC2实例。 如果还原失败的EC2实例，Elastic Load Balancing将恢复该实例的流量。</li>
<li>负载均衡器仅适用于区域内的AZ</li>
</ul>
<p><img src="https://i.loli.net/2019/08/28/bieqrjDdSkMzvo6.png" alt="screen-shot-2016-04-05-at-7-54-34-am.png"></p>
<h1 id="AWS-ELB-Application-Load-Balancer"><a href="#AWS-ELB-Application-Load-Balancer" class="headerlink" title="AWS ELB Application Load Balancer"></a>AWS ELB Application Load Balancer</h1><blockquote>
<p>Application Load Balancer 运行于请求级别（第 7 层），可根据请求的内容将流量路由至 EC2 实例、容器、IP 地址和 Lambda 函数等目标。Application Load Balancer 最适合 HTTP 和 HTTPS 流量的高级负载均衡，面向交付包括微服务和基于容器的应用程序在内的现代应用程序架构，提供高级请求路由功能。Application Load Balancer 通过确保始终使用最新的 SSL/TLS 密码和协议，简化并提高应用程序的安全性。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/08/28/S57BoUwFTL2Rpcn.png" alt="img2.png"></p>
<h2 id="Application-Load-Balancer-Benefits"><a href="#Application-Load-Balancer-Benefits" class="headerlink" title="Application Load Balancer Benefits"></a>Application Load Balancer Benefits</h2><ul>
<li>支持基于路径的路由，可以根据请求中的URL将侦听器规则配置为转发请求。</li>
<li>通过使用多个端口注册实例，支持将请求路由到单个EC2实例上的多个服务。</li>
<li>支持容器化应用程序。 EC2容器服务（ECS）可以在计划任务时选择未使用的端口，并使用此端口向目标组注册任务，从而有效地使用群集。</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查，并在目标组级别报告了许多CloudWatch指标。 通过将目标组附加到Auto Scaling组，可以根据需求动态扩展每个服务。</li>
</ul>
<h2 id="Application-Load-Balancer-Features"><a href="#Application-Load-Balancer-Features" class="headerlink" title="Application Load Balancer Features"></a>Application Load Balancer Features</h2><ul>
<li>支持使用HTTP和HTTPS协议对应用程序进行负载平衡</li>
<li>支持HTTP/2，本机启用。支持HTTP/2的客户端可以通过TLS连接</li>
<li>支持WebSockets和Secure WebSockets</li>
<li>默认情况下，支持请求追踪</li>
<li>支持使用负载均衡器生成的cookie的粘滞会话（会话关联），将来自同一客户端的请求路由到同一目标</li>
<li>支持SSL终止，在将请求发送到后端目标之前解密ALB上的请求</li>
<li>支持第7层特​​定功能，如X-Forwarded-For标头，以帮助确定实际的客户端IP，端口和协议</li>
<li>随着请求容量自动伸缩调整其负载大小</li>
<li>支持跨AZ部署，提高高可用性和传入流量分布</li>
<li>与ACM集成以提供SSL / TLS证书并将其绑定到负载均衡器，从而使整个SSL卸载过程变得非常容易</li>
<li>支持IPv6,面向internet的负载均衡</li>
<li>支持请求追踪，自定义标识符“X-Amzn-Trace-Id”HTTP头标注在所有请求上，以帮助跟踪各种服务的请求流</li>
<li>支持安全组来控制允许进出负载均衡器的流量</li>
<li>提供访问日志，记录发送到负载均衡器的所有请求，并将日志存储在S3中，以便以压缩格式进行后续分析</li>
<li>支持连接空闲超时 -  ALB为每个请求维护两个连接，一个连接客户端（前端），另一个连接目标实例（后端）。如果在空闲超时时间过去之前没有发送或接收数据，则ALB关闭前端连接</li>
<li>支持使用循环算法的慢启动模式，允许添加新目标但不会用大量请求占用新目标</li>
<li>与CloudWatch集成以提供请求计数，错误计数，错误类型和请求延迟等指标</li>
<li>与AWS WAF集成，这是一种Web应用程序防火墙，允许通过允许基于IP地址，HTTP标头和自定义URI字符串的规则配置来保护Web应用程序免受攻击</li>
<li>与CloudTrail集成以接收在AWS账户上进行的ALB API调用的历史记录</li>
</ul>
<h2 id="Application-Load-Balancer-Listeners"><a href="#Application-Load-Balancer-Listeners" class="headerlink" title="Application Load Balancer Listeners"></a>Application Load Balancer Listeners</h2><ul>
<li>侦听器是使用配置的协议和端口检查连接请求的进程</li>
<li>支持HTTP和HTTPS协议，端口好范围1-65535</li>
<li>ALB支持HTTPS侦听器的SSL终止，这有助于卸载加密和解密工作，以便目标可以专注于其主要工作。</li>
<li>HTTPS侦听器在侦听器上仅支持一个SSL服务器证书。</li>
<li>具有HTTP和HTTPS侦听器的WebSockets（安全WebSockets）</li>
<li>支持HTTP/2和HTTPS侦听器<ul>
<li>一个HTTP/2连接可以并发128个请求</li>
<li>ALB将这些请求转换为单独的HTTP / 1.1请求，并使用循环路由算法将它们分布到目标组中的健康目标上。</li>
<li>HTTP / 2更有效地使用前端连接，从而减少客户端与负载均衡器之间的连接。</li>
<li>不支持HTTP / 2的服务器推送功能</li>
</ul>
</li>
<li>侦听器都有一个默认规则，可以自定义其他规则</li>
<li>每个规则都包含优先级，动作，可选主机条件和可选路径条件<ul>
<li>优先级——按优先级顺序评估规则，从最低值到最高值。 默认规则具有最低优先级</li>
<li>动作——每个规则操作都有一个类型和一个目标组。 目前，唯一支持的类型是forward，它将请求转发给目标组。 可以随时更改规则的目标组。</li>
<li>条件——有两种类型的规则条件：主机和路径。 当满足规则的条件时，则采取其行动</li>
</ul>
</li>
<li>主机条件或基于主机的路由<ul>
<li>主机条件可用于定义根据主机头中的主机名将请求转发到不同目标组的规则</li>
<li>这使得能够使用单个ALB支持多个域，例如， orders.example.com，images.example.com，registration.example.com</li>
<li>每个主机条件都有一个主机名。</li>
</ul>
</li>
<li>路径条件或基于路径的路由<ul>
<li>路径条件可用于定义根据请求中的URL将请求转发到不同目标组的规则 </li>
<li>每个路径条件具有一个路径模式，例如， example.com/orders,example.com/images,example.com/registration</li>
<li>如果请求中的URL与侦听器规则中的路径模式完全匹配，则使用该规则路由请求。</li>
</ul>
</li>
</ul>
<h2 id="相比CLB的优势"><a href="#相比CLB的优势" class="headerlink" title="相比CLB的优势"></a>相比CLB的优势</h2><ul>
<li>支持基于路径的路由，其中​​可以配置规则以使侦听器基于URL转发请求</li>
<li>支持基于主机的路由，其中​​可以为侦听器配置规则，以根据HTTP标头中的主机字段转发请求。</li>
<li>支持将请求路由到单个EC2实例上的多个应用程序。可以使用多个端口向同一目标组注册每个实例或IP地址</li>
<li>支持按IP地址注册目标，包括负载均衡器的VPC外部目标。</li>
<li>使用动态端口映射为ECS支持容器化应用程序</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查和许多CloudWatch指标</li>
<li>将目标组附加到Auto Scaling组可以根据需求动态扩展每个服务</li>
<li>访问日志包含其他信息并以压缩格式存储</li>
<li>提高负载均衡器性能</li>
</ul>
<h1 id="AWS-ELB-Network-Load-Balancer"><a href="#AWS-ELB-Network-Load-Balancer" class="headerlink" title="AWS ELB Network Load Balancer"></a>AWS ELB Network Load Balancer</h1><ul>
<li>网络负载均衡器运行于连接级别（第 4 层），可根据 IP 协议数据将连接路由至Amazon VPC内的不同目标（Amazon EC2 实例、微服务和容器）</li>
<li>网络负载均衡器最适合 TCP 和 UDP 流量的负载均衡，能够在保持超低延迟的同时每秒处理数百万个请求</li>
<li>网络负载均衡器还经过了优化，能够处理突发的和不稳定的流量模式，同时在每个可用区使用单个静态 IP 地址</li>
<li>集成了其他常见的 AWS 服务，例如 Auto Scaling、Amazon EC2 Container Service (ECS)、Amazon CloudFormation 和 Amazon AWS Certificate Manager (ACM)</li>
</ul>
<h2 id="Network-Load-Balancer-Features"><a href="#Network-Load-Balancer-Features" class="headerlink" title="Network Load Balancer Features"></a>Network Load Balancer Features</h2><h3 id="基于连接的负载均衡"><a href="#基于连接的负载均衡" class="headerlink" title="基于连接的负载均衡"></a>基于连接的负载均衡</h3><ul>
<li>可以对 TCP 和 UDP 流量执行负载均衡，将连接路由到不同的目标 – Amazon EC2 实例、微服务和容器。</li>
</ul>
<h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><ul>
<li>网络负载均衡器具有高可用性。</li>
<li>它接受来自客户端的传入流量，并在同一可用区内的目标之间分配此流量。</li>
<li>负载均衡器还监控其已注册目标的运行状况，并确保它仅将流量路由到正常运行的目标。</li>
<li>当负载均衡器检测到无法正常运行的目标时，它会停止将流量路由到该目标，并将流量重新路由到剩余的正常运行的目标。如果一个可用区中的所有目标全都无法正常运行，但已在另一个可用区中设置了目标，则网络负载均衡器将自动进行故障转移以将流量路由到其他可用区中正常运行的目标。</li>
</ul>
<h3 id="高吞吐量"><a href="#高吞吐量" class="headerlink" title="高吞吐量"></a>高吞吐量</h3><ul>
<li>网络负载均衡器旨在处理不断增长的流量，并可以对每秒数百万个请求进行负载均衡。它还可以处理突发的不稳定流量模式。</li>
</ul>
<h3 id="低延迟"><a href="#低延迟" class="headerlink" title="低延迟"></a>低延迟</h3><ul>
<li>网络负载均衡器为延迟敏感的应用程序提供极低的延迟。</li>
</ul>
<h3 id="保留源-IP-地址"><a href="#保留源-IP-地址" class="headerlink" title="保留源 IP 地址"></a>保留源 IP 地址</h3><ul>
<li>网络负载均衡器保留客户端源 IP，允许后端查看客户端的 IP 地址。然后，应用程序可以将其用于进一步处理。</li>
</ul>
<h3 id="静态-IP-支持"><a href="#静态-IP-支持" class="headerlink" title="静态 IP 支持"></a>静态 IP 支持</h3><ul>
<li>网络负载均衡器自动提供每个可用区（子网）的静态 IP，应用程序可将其用作负载均衡器的前端 IP。</li>
</ul>
<h3 id="弹性-IP-支持"><a href="#弹性-IP-支持" class="headerlink" title="弹性 IP 支持"></a>弹性 IP 支持</h3><ul>
<li>网络负载均衡器还允许为每个可用区（子网）分配弹性 IP，从而提供自己的固定 IP。</li>
</ul>
<h3 id="TLS-卸载"><a href="#TLS-卸载" class="headerlink" title="TLS 卸载"></a>TLS 卸载</h3><ul>
<li>网络负载均衡器支持在客户端和负载均衡器之间终止 TLS。</li>
<li>除了为在完成客户端与负载均衡器之间的 TLS 握手时首选的密码和协议提供灵活性的预定义安全策略外，网络负载均衡器还提供通过 AWS Identity and Access Management (IAM) 和 AWS Certificate Manager 管理 SSL 证书的功能。</li>
<li>在网络负载均衡器上终止 TLS 后，源 IP 地址将继续保留在的后端应用程序中。</li>
</ul>
<h3 id="运行状况检查"><a href="#运行状况检查" class="headerlink" title="运行状况检查"></a>运行状况检查</h3><ul>
<li>网络负载均衡器支持网络和应用程序目标运行状况检查。</li>
<li>网络级健康检查<ul>
<li>基于底层目标（实例或容器）对正常流量的总体响应。</li>
<li>如果目标很慢或无法响应新的连接请求，则标记为不可用</li>
</ul>
</li>
<li>应用程序级健康检查<ul>
<li>通过定期探测给定目标上的特定 URL，它可以集成实际应用程序的运行状况</li>
</ul>
</li>
</ul>
<h3 id="DNS-故障转移"><a href="#DNS-故障转移" class="headerlink" title="DNS 故障转移"></a>DNS 故障转移</h3><ul>
<li>如果没有向网络负载均衡器注册的正常运行的目标，或者给定区域中的网络负载均衡器节点无法正常运行，则 Amazon Route 53 会将流量定向到其他可用区中的负载均衡器节点。</li>
</ul>
<h3 id="与-Amazon-Route-53-集成"><a href="#与-Amazon-Route-53-集成" class="headerlink" title="与 Amazon Route 53 集成"></a>与 Amazon Route 53 集成</h3><ul>
<li>如果的网络负载均衡器无法响应，则与 Route 53 的集成将从服务中删除不可用的负载均衡器 IP 地址，并将流量定向到另一个区域中的备用网络负载均衡器。</li>
</ul>
<h3 id="与-AWS-服务集成"><a href="#与-AWS-服务集成" class="headerlink" title="与 AWS 服务集成"></a>与 AWS 服务集成</h3><ul>
<li>网络负载均衡器已与其他 AWS 服务集成，例如 Auto Scaling、Elastic Container Service (ECS)、CloudFormation、Elastic BeanStalk、CloudWatch、Config、CloudTrail、CodeDeploy 和 AWS Certificate Manager (ACM)。</li>
</ul>
<h3 id="长时间运行的-TCP-连接"><a href="#长时间运行的-TCP-连接" class="headerlink" title="长时间运行的 TCP 连接"></a>长时间运行的 TCP 连接</h3><p>网络负载均衡器支持长时间运行的 TCP 连接，这是 WebSocket 类型的应用程序的理想选择。</p>
<h3 id="集中-API-支持"><a href="#集中-API-支持" class="headerlink" title="集中 API 支持"></a>集中 API 支持</h3><ul>
<li>网络负载均衡器使用与 Application Load Balancer 相同的 API。这将使能够在同一 Amazon EC2 实例上的多个端口之间使用目标组、运行状况检查和负载均衡，以支持容器化应用程序。</li>
</ul>
<h3 id="可靠的监控和审核"><a href="#可靠的监控和审核" class="headerlink" title="可靠的监控和审核"></a>可靠的监控和审核</h3><ul>
<li>Amazon CloudWatch 报告网络负载均衡器指标。CloudWatch 提供诸如活动流计数、正常运行的主机计数、新流计数、已处理的字节等指标。网络负载均衡器还与 AWS CloudTrail 集成。CloudTrail 跟踪对网络负载均衡器的 API 调用。</li>
</ul>
<h3 id="增强的日志记录"><a href="#增强的日志记录" class="headerlink" title="增强的日志记录"></a>增强的日志记录</h3><ul>
<li>可以使用流日志功能记录发送到负载均衡器的所有请求。</li>
<li>流日志捕获有关进出 VPC 中网络接口的 IP 流量的信息。流日志数据使用 Amazon CloudWatch Logs 进行存储。</li>
<li>在的网络负载均衡器上添加 TLS 侦听器后，可以选择启用“访问日志”功能，这些访问日志将发送到选择的 S3 存储桶中。“访问日志”会捕获有关侦听器接收的每个 TLS 连接的信息，可从中了解成功和失败的 TLS 握手情况。</li>
</ul>
<h3 id="区域隔离"><a href="#区域隔离" class="headerlink" title="区域隔离"></a>区域隔离</h3><ul>
<li>网络负载均衡器专为单个区域中的应用程序架构而设计。</li>
<li>如果可用区中的某些内容失败，我们将自动故障转移到其他正常运行的可用区。</li>
<li>虽然我们建议客户在多个可用区中配置负载均衡器和目标以实现高可用性，但可以在单个可用区中启用网络负载均衡器，以支持需要区域隔离的架构。</li>
</ul>
<h3 id="使用IP地址作为目标进行负载平衡"><a href="#使用IP地址作为目标进行负载平衡" class="headerlink" title="使用IP地址作为目标进行负载平衡"></a>使用IP地址作为目标进行负载平衡</h3><ul>
<li>允许使用应用程序后端的IP地址作为目标，对AWS或本地托管的任何应用程序进行负载平衡。</li>
<li>允许负载平衡到托管在任何IP地址和实例上任何接口上的应用程序后端。</li>
<li>跨AWS和本地资源实现负载均衡的能力有助于迁移到云，突发到云或故障转移到云</li>
<li>托管在本地位置的应用程序可用作Direct Connect连接和EC2-Classic（使用ClassicLink）的目标。</li>
</ul>
<h2 id="相比CLB的优势-1"><a href="#相比CLB的优势-1" class="headerlink" title="相比CLB的优势"></a>相比CLB的优势</h2><ul>
<li>能够处理不稳定的工作负载并扩展到每秒数百万个请求，而无需预热</li>
<li>支持负载均衡器的静态IP /弹性IP地址</li>
<li>支持按IP地址注册目标，包括负载均衡器的VPC（内部部署）之外的目标。</li>
<li>支持将请求路由到单个EC2实例上的多个应用程序。 可以使用多个端口向同一目标组注册单个实例或IP地址。</li>
<li>支持容器化应用程序。 使用动态端口映射，ECS可以在计划任务时选择未使用的端口，并使用此端口向目标组注册任务。</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查，并在目标组级别报告了许多CloudWatch指标。 将目标组附加到Auto Scaling组可以根据需求动态扩展每个服务</li>
</ul>
<h1 id="ELB-主要功能"><a href="#ELB-主要功能" class="headerlink" title="ELB 主要功能"></a>ELB 主要功能</h1><h2 id="Scaling-ELB"><a href="#Scaling-ELB" class="headerlink" title="Scaling ELB"></a>Scaling ELB</h2><ul>
<li>每个ELB都分配并配置了默认容量</li>
<li>ELB Controller 存储了所有配置信息，还监视负载均衡器并管理用于处理客户端请求的容量</li>
<li>随着流量配置文件的更改，控制器服务会扩展负载平衡器以处理更多请求，并在所有AZ中进行相同的扩展</li>
<li>ELB通过利用更大的资源（向上扩展 - 具有更高性能特征的资源）或更多独立资源（向外扩展）来增加其容量</li>
<li>AWS本身处理ELB容量的扩展，并且此扩展与ELB将其请求路由到的EC2实例的扩展不同，这由Auto Scaling处理</li>
<li>Elastic Load Balancing扩展所需的时间范围为1到7分钟，具体取决于流量配置文件中的更改</li>
</ul>
<h2 id="预热-ELB"><a href="#预热-ELB" class="headerlink" title="预热 ELB"></a>预热 ELB</h2><ul>
<li>ELB最适合逐渐增加流量</li>
<li>AWS能够自动扩展并处理绝大多使用场景</li>
<li>但是，在某些情况下，如果预计存在流量峰值或无法将负载测试配置为逐渐增加流量，建议联系AWS支持以使负载均衡器“预热”</li>
<li>AWS将通过将负载均衡器配置为具有基于预期流量的适当容量级别来帮助预热ELB</li>
<li>AWS需要有关开始日期，结束日期和每秒预期请求率的信息以及请求/响应的总大小</li>
</ul>
<h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><ul>
<li>ELB根据流量配置文件自动缩放</li>
<li>缩放时，Elastic Load Balancing服务将更新负载均衡器的域名系统（DNS）记录，以便新资源在DNS中注册其各自的IP地址。</li>
<li>创建的DNS记录包括60秒的生存时间（TTL）设置</li>
<li>默认情况下，当客户端执行DNS解析时，ELB将返回多个IP地址，并在每个DNS解析请求上随机排序记录。</li>
<li>建议客户端至少每60秒重新查找DNS，以利用增加的容量</li>
</ul>
<h2 id="负载均衡类型"><a href="#负载均衡类型" class="headerlink" title="负载均衡类型"></a>负载均衡类型</h2><ul>
<li>面向internet（具有公共IP地址）<ul>
<li>面向Internet的负载均衡器通过Internet从客户端接收请求，并将这些请求分发到使用负载均衡器注册的EC2实例</li>
</ul>
</li>
<li>内部负载均衡（只有私有IP地址）<ul>
<li>将流量路由到私有子网中的EC2实例</li>
</ul>
</li>
</ul>
<h2 id="可用区-子网"><a href="#可用区-子网" class="headerlink" title="可用区/子网"></a>可用区/子网</h2><ul>
<li>Elastic Load Balancing允许添加子网，并在子网所在的每个可用区中创建负载均衡器节点</li>
<li>ELB至少连接一个子网</li>
<li>每个AZ只能有一个子网连接到ELB。 连接已附加AZ的子网将替换现有子网</li>
<li>每个子网必须具有至少具有/ 27位掩码的CIDR块，并且至少具有8个空闲IP地址，ELB使用这些IP地址与后端实例建立连接</li>
<li>对于高可用性，建议为每个AZ附加一个子网，至少两个AZ，即使实例位于一个子网中</li>
<li>子网可以与ELB连接或分离，它将启动或停止向子网中的实例发送请求</li>
</ul>
<h2 id="安全组和NACL"><a href="#安全组和NACL" class="headerlink" title="安全组和NACL"></a>安全组和NACL</h2><ul>
<li>安全组和NACL应允许来自客户端的负载均衡器侦听器端口上的入站流量用于Internet ELB或VPC CIDR用于内部ELB</li>
<li>安全组和NACL应允许实例侦听器端口和运行状况检查端口上的后端实例的出站流量</li>
<li>此外，nacl应该允许在临时端口上响应</li>
<li>所有EC2实例都应该允许来自ELB的传入流量</li>
</ul>
<h2 id="SSL协商配置"><a href="#SSL协商配置" class="headerlink" title="SSL协商配置"></a>SSL协商配置</h2><ul>
<li>对于HTTPS负载平衡器，Elastic Load Balancing使用安全套接字层（SSL）协商配置（称为安全策略）来协商客户端和负载均衡器之间的SSL连接。<br>安全策略是SSL协议，SSL密码和服务器顺序首选项选项的组合</li>
<li>Elastic Load Balancing支持以下版本的SSL协议TLS 1.2，TLS 1.1，TLS 1.0，SSL 3.0，SSL 2.0（现已弃用）<br>SSL协议使用多个SSL密码来加密Internet上的数据。</li>
<li>Elastic Load Balancing支持Server Order Preference选项，用于协商客户端和负载均衡器之间的连接。<br>在SSL连接协商过程中，这允许负载均衡器控制并选择其列表中位于客户端密码列表中的第一个密码，而不是检查客户端列表中的第一个密码与服务器列表匹配的默认行为。</li>
<li>Elastic Load Balancer允许使用预定义的安全策略或为特定需求创建自定义安全策略。如果未指定，则ELB选择最新的预定义安全策略。</li>
</ul>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><ul>
<li>负载均衡对所有已注册的实例执行运行状况检查，无论实例处于健康状态还是不健康状态</li>
<li>负载均衡器执行运行状况检查以发现EC2实例的可用性，负载均衡器定期发送ping，尝试连接或向健康状况发送请求以检查EC2实例。</li>
<li>运行状况检查是健康实例状态的InService和不健康实例的OutOfService</li>
<li>负载均衡器每隔几秒向Ping协议、Ping端口和Ping路径上的每个注册实例发送一个请求。它等待实例在响应超时期间内响应。如果健康检查超过连续失败响应的不健康阈值，负载平衡器将该实例退出服务。当健康检查超过连续成功响应的健康阈值时，负载平衡器将实例重新投入服务。</li>
<li>负载均衡器仅向健康的EC2实例发送请求，并停止将请求路由到不健康的实例</li>
</ul>
<h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><ul>
<li>侦听器是检查来自客户端的连接请求的进程</li>
<li>侦听器配置有用于前端（客户端到负载平衡器）连接的协议和端口，以及用于后端（负载平衡器到后端实例）连接的协议和端口</li>
<li>监听器支持HTTP，HTTPS，SSL，TCP协议</li>
<li>HTTPS或SSL连接需要X.509证书，负载均衡器使用证书终止连接，然后在将请求发送到后端实例之前解密来自客户端的请求。<br>如果要使用SSL，但不想终止负载均衡器上的连接，请使用TCP进行从客户端到负载均衡器的连接，使用SSL协议进行从负载均衡器到后端应用程序的连接，并在处理请求的后端实例上部署证书。</li>
<li>如果为后端使用HTTPS / SSL连接，则可以在后端实例上启用身份验证。此身份验证可用于确保后端实例仅接受加密通信，并确保后端实例具有正确的证书。</li>
<li>ELB HTTPS侦听器不支持客户端SSL证书</li>
</ul>
<h2 id="空闲连接超时"><a href="#空闲连接超时" class="headerlink" title="空闲连接超时"></a>空闲连接超时</h2><ul>
<li>对于客户端通过负载均衡器发出的每个请求，它为每个客户端请求维护两个连接，一个与客户端的连接，另一个连接到后端实例。</li>
<li>对于每个连接，负载均衡器管理在指定时间段内没有数据通过连接发送时触发的空闲超时。 如果未发送或接收数据，则在空闲超时时间（默认为60秒）过后，它将关闭连接</li>
<li>对于冗长的操作（例如文件上载），应调整连接的空闲超时设置，以确保冗长的操作有时间完成</li>
</ul>
<h2 id="X-Forwarded标头和代理协议支持"><a href="#X-Forwarded标头和代理协议支持" class="headerlink" title="X-Forwarded标头和代理协议支持"></a>X-Forwarded标头和代理协议支持</h2><ul>
<li>由于Elastic Load Balancer拦截客户端和后端服务器之间的流量，后端服务器不知道客户端和负载均衡器之间使用的IP地址，协议和端口。<br>ELB提供X-Forwarded标头支持，以帮助后端服务器在使用HTTP协议时跟踪相同的内容</li>
<li>X-Forwarded-For请求标头，用于在使用HTTP或HTTPS负载均衡器时帮助后端服务器识别客户端的IP地址</li>
<li>X-Forwarded-Proto请求标头，用于帮助后端服务器识别客户端用于连接服务器的协议（HTTP/S）</li>
<li>X-Forwarded-Port请求标头，用于帮助后端服务器识别HTTP或HTTPS负载均衡器用于连接客户端的端口</li>
<li>ELB提供代理协议支持，以帮助后端服务器在使用非HTTP协议或使用HTTPS时不跟踪负载平衡器上的SSL连接。</li>
<li>代理协议是一种Internet协议，用于从请求连接的源传送连接到请求连接的目标的连接信息。</li>
<li>Elastic Load Balancing使用代理协议版本1，它使用可读的头格式，其中包含源IP地址，目标IP地址和端口号等连接信息</li>
<li>如果ELB已经在启用了代理协议的代理服务器后面，则在ELB上启用代理协议将添加两次头</li>
</ul>
<h2 id="块区域负载均衡"><a href="#块区域负载均衡" class="headerlink" title="块区域负载均衡"></a>块区域负载均衡</h2><ul>
<li>默认情况下，负载均衡器会在其启用的可用区域内均匀分配传入请求，例如 如果AZ-a有5个实例且AZ-b有2个实例，则每个AZ的负载仍将分配50％</li>
<li>启用跨区域负载平衡允许ELB在所有后端实例上均匀分配传入请求，而不管AZ包含多少个实例</li>
<li>跨区域负载平衡器减少了在每个可用区中维护相同数量的后端实例的需要，并提高了应用程序处理一个或多个后端实例丢失的能力</li>
<li>建议在每个可用区中保持大致相等数量的实例，以获得更高的容错能力</li>
</ul>
<h2 id="连接耗尽"><a href="#连接耗尽" class="headerlink" title="连接耗尽"></a>连接耗尽</h2><ul>
<li>默认情况下，如果注册的带有ELB的EC2实例已取消注册或变得不健康，则负载均衡器会立即关闭连接</li>
<li>连接耗尽可以帮助负载均衡器在保持现有连接打开的同时完成正在进行的请求，并防止任何新请求被发送到取消注册或不健康的实例</li>
<li>连接耗尽有助于执行维护，例如部署软件升级或替换后端实例，而不会影响客户体验</li>
<li>连接耗尽允许指定最大时间（介于1到3,600秒之间，默认为300秒），以便在将实例报告为取消注册之前保持连接处于活动状态。最大超时限制不适用于与不健康实例的连接</li>
<li>如果实例是Auto Scaling组的一部分并且已为负载均衡器启用了连接耗尽，则Auto Scaling会在由于扩展事件或运行状况而终止实例之前等待正在进行的请求完成，或等待最大超时到期检查更换</li>
</ul>
<h2 id="粘性会话"><a href="#粘性会话" class="headerlink" title="粘性会话"></a>粘性会话</h2><ul>
<li>ELB可以配置为使用粘性会话功能（也称为会话关联），使其能够将用户的会话绑定到实例，并确保将所有请求发送到同一实例</li>
<li>粘性保持一段时间，可以通过应用程序的会话cookie（如果存在）或通过名为AWSELB的cookie（通过Elastic Load balancer创建）来控制</li>
<li>默认情况下，禁用ELB的粘性会话</li>
</ul>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>HTTP / HTTPS负载均衡器。</li>
<li>SSL流量应该在ELB上终止。 ELB通过使用HTTP cookie在HTTP / HTTPS侦听器上执行会话粘性。 如果SSL流量未在ELB上终止并在后端实例上终止，则ELB无法查看HTTP标头，因此无法设置或读取任何来回传递的HTTP标头。</li>
<li>每个可用区中至少有一个健康实例。</li>
</ul>
<h3 id="基于持续时间的粘性会话"><a href="#基于持续时间的粘性会话" class="headerlink" title="基于持续时间的粘性会话"></a>基于持续时间的粘性会话</h3><ul>
<li>基于持续时间的会话粘性由ELB维护，使用创建的特殊cookie来跟踪每个请求到每个侦听器的实例。</li>
<li>当负载均衡器收到请求时，它首先检查请求中是否存在此cookie。 如果是，则将请求发送到cookie中指定的实例。</li>
<li>如果没有cookie，ELB会根据现有的负载平衡算法选择一个实例，并在响应中插入一个cookie，用于绑定来自同一用户的后续请求。</li>
<li>粘性策略配置定义了cookie过期，它确定了每个cookie的有效期。 Cookie会在有效期到期后自动更新。</li>
</ul>
<h3 id="应用程序控制粘性会话"><a href="#应用程序控制粘性会话" class="headerlink" title="应用程序控制粘性会话"></a>应用程序控制粘性会话</h3><ul>
<li>负载均衡器仅使用特殊cookie将会话与处理初始请求的实例相关联，但遵循策略配置中指定的应用程序cookie的生命周期。</li>
<li>如果应用程序响应包含新的应用程序cookie，则负载均衡器仅插入新的粘性cookie。 负载均衡器粘性cookie不会随每个请求更新。</li>
<li>如果明确删除或过期应用程序cookie，则在发出新的应用程序cookie之前，会话将停止粘滞。</li>
<li>如果实例失败或变得不健康，负载均衡器会停止将路由请求发送到该实例，而是根据现有的负载均衡算法选择新的健康实例。 负载均衡器将会话视为现在“卡住”到新的正常实例，并继续将请求路由到该实例，即使失败的实例返回。</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><ul>
<li><strong><font color="red">对于 Application Load Balancer，用于接收请求的负载均衡器节点会按照优先级顺序评估侦听器规则以确定应用哪个规则，然后使用轮询路由算法从目标组中选择一个目标以实施规则操作。每个目标组的路由都是单独进行的，即使某个目标已在多个目标组中注册。</font></strong></li>
<li><strong><font color="red">对于 Network Load Balancer，用于接收连接的负载均衡器节点会根据协议、源 IP 地址、源端口、目标 IP 地址、目标端口和 TCP 序列号，使用流式哈希算法从目标组中为默认规则选择一个目标。来自客户端的 TCP 连接具有不同的源端口和序列号，可以路由到不同的目标。每个单独的 TCP 连接在连接的有效期内路由到单个目标。</font></strong></li>
<li><font color="red"><strong>对于 Classic Load Balancer，接受请求的负载均衡器节点将利用不同算法来选择已注册的实例。它对 TCP 侦听器使用轮询路由算法，对 HTTP 和 HTTPS 侦听器使用最少未完成请求路由算法。<br></strong></font></li>
</ul>
<h2 id="ALB-vs-NLB-vs-CLB"><a href="#ALB-vs-NLB-vs-CLB" class="headerlink" title="ALB vs NLB vs CLB"></a>ALB vs NLB vs CLB</h2><table>
<thead>
<tr>
<th align="left"><strong>功能</strong></th>
<th align="center"><strong>Application Load Balancer</strong></th>
<th align="center"><strong>Network Load Balancer</strong></th>
<th align="center"><strong>Classic Load Balancer</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议</td>
<td align="center">HTTP、HTTPS</td>
<td align="center">TCP、UDP、TLS</td>
<td align="center">TCP、SSL/TLS、HTTP、HTTPS</td>
</tr>
<tr>
<td align="left">平台</td>
<td align="center">VPC</td>
<td align="center">VPC</td>
<td align="center">EC2-Classic、VPC</td>
</tr>
<tr>
<td align="left">运行状况检查</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">CloudWatch 指标</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">日志记录</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">区域故障转移</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">Connection Draining（注销延迟）</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">负载均衡到同一实例上的多个端口</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">IP 地址即目标</td>
<td align="center">✔</td>
<td align="center">✔（TCP、TLS）</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">负载均衡器删除保护</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">可配置的空闲连接超时</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">跨区负载均衡</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">粘性会话</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">静态 IP</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">弹性 IP 地址</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">保留源 IP 地址</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于资源的 IAM 权限</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">基于标签的 IAM 权限</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">慢启动</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">WebSocket</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">PrivateLink 支持</td>
<td align="center"></td>
<td align="center">✔（TCP、TLS）</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于源 IP 地址 CIDR 的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">第 7 层</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于路径的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于主机的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">本机 HTTP/2</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">重定向</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">固定响应</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Lambda 函数即目标</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于 HTTP 标头的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于 HTTP 方法的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于查询字符串参数的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">安全性</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">SSL 卸载</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">服务器名称指示 (SNI)</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">后端服务器加密</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">用户身份验证</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">自定义安全策略</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
</tbody></table>
<h1 id="AutoScaling-amp-ELB"><a href="#AutoScaling-amp-ELB" class="headerlink" title="AutoScaling &amp; ELB"></a>AutoScaling &amp; ELB</h1><ul>
<li>Auto Scaling动态添加和删除EC2实例，而Elastic Load Balancing通过优化路由流量来管理传入请求，这样就不会有任何一个实例超负荷运行</li>
<li>AUto Scaling有助于在用户需求增加时自动增加EC2实例的数量，并在需求下降时减少EC2实例的数量</li>
<li>ELB服务有助于在所有正在运行的EC2实例之间自动分配传入的Web流量</li>
<li>ELB使用负载平衡器来监控流量并处理来自Internet的请求</li>
<li>使用ELB和Auto Scaling<ul>
<li>可以轻松地在动态变化的EC2实例中路由流量</li>
<li>负载均衡器充当Auto Scaling组中实例的所有传入流量的单一连接点<br><img src="https://i.loli.net/2019/08/28/47J6cRxMrObEjwY.png" alt="Screen-Shot-2016-06-07-at-4.13.10-PM.png"></li>
</ul>
</li>
</ul>
<h2 id="Attaching-Detaching-ELB-with-Auto-Scaling-Group"><a href="#Attaching-Detaching-ELB-with-Auto-Scaling-Group" class="headerlink" title="Attaching/Detaching ELB with Auto Scaling Group"></a>Attaching/Detaching ELB with Auto Scaling Group</h2><ul>
<li>Auto Scaling与Elastic Load Balancing集成，可以将一个或多个负载均衡器连接到现有的Auto Scaling组。</li>
<li>ELB使用其IP地址注册EC2实例，并将请求路由到实例的主接口（eth0）的主IP地址。</li>
<li>连接ELB后，它会自动在组中注册实例，并在实例之间分配传入流量</li>
<li>分离ELB时，它会在取消注册组中的实例时进入“删除”状态。</li>
<li>如果启用了连接耗尽，ELB将在取消注册实例之前等待正在进行的请求完成。</li>
<li>从ELB注销实例后，实例仍在运行</li>
<li>Auto Scaling会在启动时向ELB添加实例，但这可以暂停。 在暂停期间启动的实例在恢复后不会添加到负载均衡器，并且必须手动注册。</li>
</ul>
<h2 id="High-Availability-amp-Redundancy"><a href="#High-Availability-amp-Redundancy" class="headerlink" title="High Availability &amp; Redundancy"></a>High Availability &amp; Redundancy</h2><ul>
<li>Auto Scaling可以跨越同一区域内的多个AZ</li>
<li>当一个AZ变得不健康或不可用时，Auto Scaling会在未受影响的AZ中启动新实例</li>
<li>当不健康的AZ恢复时，Auto Scaling会在所有健康的AZ中重新分配流量</li>
<li>可以设置Elastic Load balancer以在区域内的单个AZ或多个AZ中跨EC2实例分发传入请求</li>
<li>建议通过跨区域内多个AZ的Auto Scaling组使用Auto Scaling和ELB，然后设置ELB以在这些AZ之间分配传入流量，来利用地理冗余的安全性和可靠性。</li>
<li>在为ELB启用的所有AZ中，传入流量均衡负载到AZ中</li>
</ul>
<h2 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h2><ul>
<li>Auto Scaling组通过定期检查EC2实例状态检查的结果来确定每个实例的运行状况</li>
<li>如果实例未通过EC2实例状态检查，Auto Scaling会将实例标记为运行状况不佳并替换实例</li>
<li>ELB还对在其上注册的EC2实例执行健康检查，例如 ping和健康检查页面提供应用程序</li>
<li>如果ELB运行状况检查失败，则默认情况下，Auto Scaling不会替换实例</li>
<li>应使用实例的ELB运行状况检查来确保流量仅路由到正常运行的实例</li>
<li>向Auto Scaling组注册负载均衡器后，除了EC2实例状态检查之外，还可以将其配置为使用ELB运行状况检查的结果来确定Auto Scaling组中EC2实例的运行状况。</li>
</ul>
<h2 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h2><ul>
<li>Elastic Load Balancing将有关负载均衡器和EC2实例的数据发送到Amazon CloudWatch。 CloudWatch收集有关资源性能的数据，并将其显示为指标。</li>
<li>在使用Auto Scaling组注册一个或多个负载均衡器后，可以将Auto Scaling组配置为使用ELB指标（例如请求延迟或请求计数）自动扩展应用程序</li>
</ul>
<h1 id="AWS-ELB-Monitoring"><a href="#AWS-ELB-Monitoring" class="headerlink" title="AWS ELB Monitoring"></a>AWS ELB Monitoring</h1><h2 id="Cloud-Watch-Metrics"><a href="#Cloud-Watch-Metrics" class="headerlink" title="Cloud Watch Metrics"></a>Cloud Watch Metrics</h2><ul>
<li>Elastic Load Balancing向Amazon CloudWatch发布有关负载均衡器和后端实例的数据采集信息</li>
<li>仅当请求流经负载均衡器时，Elastic Load Balancing才会将指标报告给CloudWatch。 如果有请求流经负载均衡器，Elastic Load Balancing将以60秒的间隔测量并发送其指标。 如果没有请求流经负载均衡器或没有指标数据，则不会报告该指标。</li>
</ul>
<p>监控指标包含如下</p>
<ul>
<li>HealthyHostCount，UnHealthyHostCount<ul>
<li>使用负载均衡器注册的健康和不健康实例的数量</li>
<li>统计数据是平均值，最小值和最大值</li>
</ul>
</li>
<li>RequestCount<ul>
<li>在指定的时间间隔内（1或5分钟）完成的请求数或连接数</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>latency<ul>
<li>请求离开负载均衡器之后经过的时间（以秒为单位），直到收到响应的标头</li>
<li>统计数据是平均值</li>
</ul>
</li>
<li>SurgeQueueLength<ul>
<li>待处理路由的请求总数</li>
<li>如果请求无法与正常实例建立连接以便路由请求，则负载均衡器会对请求进行排队</li>
<li>队列的最大大小为1,024。队列已满时，将拒绝其他请求。</li>
<li>统计信息是max，因为它表示排队请求的峰值</li>
</ul>
</li>
<li>SpilloverCount<ul>
<li>由于浪涌队列已满而被拒绝的请求总数。理想情况下应为0</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>HTTPCode_ELB_4XX，HTTPCode_ELB_5XX<ul>
<li>负载均衡器生成的客户端和服务器错误代码</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>HTTPCode_Backend_2XX，HTTPCode_Backend_3XX，HTTPCode_Backend_4XX，HTTPCode_Backend_5XX<ul>
<li>已注册实例生成的HTTP响应代码数</li>
<li>统计数据是总和</li>
</ul>
</li>
</ul>
<h2 id="ELB-访问日志"><a href="#ELB-访问日志" class="headerlink" title="ELB 访问日志"></a>ELB 访问日志</h2><ul>
<li>Elastic Load Balancing提供访问日志，可捕获有关发送到负载均衡器的所有请求的详细信息</li>
<li>每个日志都包含诸如接收请求的时间，客户端的IP地址，延迟，请求路径和服务器响应之类的信息。<br>Elastic Load Balancing捕获日志并将其存储在Amazon S3存储桶中</li>
<li>默认情况下禁用访问日志记录，无需任何额外费用即可启用。 只需支付S3存储费用</li>
</ul>
<h2 id="Cloud-Trail-日志"><a href="#Cloud-Trail-日志" class="headerlink" title="Cloud Trail 日志"></a>Cloud Trail 日志</h2><ul>
<li>AWS CloudTrail可用于捕获由AWS账户或代表AWS账户制作的Elastic Load Balancing API的所有调用，并且可以直接使用Elastic Load Balancing API，也可以通过AWS管理控制台或AWS CLI间接调用</li>
<li>CloudTrail将信息作为日志文件存储在指定的Amazon S3存储桶中。</li>
<li>CloudTrail收集的日志可用于监控负载均衡器的活动，并确定进行的API调用，使用的源IP地址，拨打电话的人员，拨打电话的时间等等。</li>
</ul>
<h1 id="Classic-Load-Balancer-vs-Application-Load-Balancer"><a href="#Classic-Load-Balancer-vs-Application-Load-Balancer" class="headerlink" title="Classic Load Balancer vs Application Load Balancer"></a>Classic Load Balancer vs Application Load Balancer</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>CLB是跨多个EC2实例的流量的简单负载平衡的理想选择，</li>
<li>ALB是微服务或基于容器的体系结构的理想选择，在这种体系结构中，需要将流量路由到多个服务或在同一EC2实例上的多个端口之间进行负载平衡。</li>
</ul>
<p><img src="https://i.loli.net/2019/08/28/oiZSxfG1CDlRYVb.png" alt="AWS-ELB-Classic-Load-Balancer-vs-Application-Load-Balancer.png"></p>
<h2 id="支持协议"><a href="#支持协议" class="headerlink" title="支持协议"></a>支持协议</h2><ul>
<li>CLB在第4层运行，支持HTTP，HTTPS，TCP，SSL，而Application Load Balancer在第7层运行，支持HTTP，HTTPS，HTTP / 2，WebSockets</li>
<li>如果需要第4层功能，则应使用CLB</li>
</ul>
<h2 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h2><ul>
<li>CLB 支持EC2-Classic和EC2-VPC，而ALB仅支持EC2-VPC</li>
</ul>
<h2 id="Stick-Sessions（Cookies）"><a href="#Stick-Sessions（Cookies）" class="headerlink" title="Stick Sessions（Cookies）"></a>Stick Sessions（Cookies）</h2><ul>
<li>Stick Sessions（粘性会话）使负载均衡器能够将用户的会话绑定到特定实例，从而确保会话期间来自用户的所有请求都发送到同一个实例</li>
<li>Classic和Application Load Balancer都支持粘性会话以保持会话亲和性</li>
</ul>
<h2 id="空闲连接超时-1"><a href="#空闲连接超时-1" class="headerlink" title="空闲连接超时"></a>空闲连接超时</h2><ul>
<li>空闲连接超时有助于指定一个时间段，如果在空闲超时时间过去之前没有数据发送或接收，ELB将使用该时间段来关闭连接</li>
<li>Classic和Application Load Balancer都支持空闲连接超时</li>
</ul>
<h2 id="连接耗尽-1"><a href="#连接耗尽-1" class="headerlink" title="连接耗尽"></a>连接耗尽</h2><ul>
<li>连接耗尽使负载均衡器能够完成对取消注册或不健康的实例的正在进行的请求</li>
<li>Classic和Application Load Balancer都支持连接耗尽</li>
</ul>
<h2 id="SSL终止"><a href="#SSL终止" class="headerlink" title="SSL终止"></a>SSL终止</h2><ul>
<li>CLB和ALB都支持SSL终端，以便在将客户端发送到目标之前对其进行解密，从而减轻负载。 必须在负载均衡器上安装SSL证书。</li>
</ul>
<h2 id="后端服务器身份验证"><a href="#后端服务器身份验证" class="headerlink" title="后端服务器身份验证"></a>后端服务器身份验证</h2><ul>
<li>后端服务器身份验证允许对实例进行身份验证。 仅当实例提供给负载均衡器的公钥与负载均衡器的身份验证策略中的公钥匹配时，负载均衡器才与实例通信。</li>
<li>CLB器支持，而应用程序负载均衡器不支持后端服务器身份验证 </li>
</ul>
<h2 id="跨区域负载平衡"><a href="#跨区域负载平衡" class="headerlink" title="跨区域负载平衡"></a>跨区域负载平衡</h2><ul>
<li>跨区域负载平衡有助于在其启用的AZ中的所有实例之间均匀分配传入请求。 默认情况下，Load Balancer将在其启用的AZ上均匀分布请求，而不管其承载的实例如何。</li>
<li>Classic和Application Load Balancer都支持跨区域负载平衡，但是对于Classic，需要启用它，而对于ALB，它始终启用</li>
</ul>
<h2 id="健康检查-1"><a href="#健康检查-1" class="headerlink" title="健康检查"></a>健康检查</h2><ul>
<li>Classic和Application Load Balancer都支持运行状况检查，以确定实例是健康的还是不健康的<br>ALB提供运行状况检查改进，允许配置200-399的详细错误代码</li>
</ul>
<h2 id="CloudWatch指标"><a href="#CloudWatch指标" class="headerlink" title="CloudWatch指标"></a>CloudWatch指标</h2><ul>
<li>Classic和Application Load Balancer都与CloudWatch集成以提供指标，ALB提供额外的指标</li>
</ul>
<h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><ul>
<li>访问日志捕获有关发送到负载均衡器的请求的详细信息。 每个日志都包含诸如接收请求的时间，客户端的IP地址，延迟，请求路径和服务器响应之类的信息</li>
<li>Classic和Application Load Balancer都提供访问日志，ALB提供其他属性</li>
</ul>
<h2 id="基于主机的路由和基于路径的路由"><a href="#基于主机的路由和基于路径的路由" class="headerlink" title="基于主机的路由和基于路径的路由"></a>基于主机的路由和基于路径的路由</h2><ul>
<li>基于主机的路由使用主机条件来定义根据主机头中的主机名将请求转发到不同目标组的规则。 这使ALB能够使用单个负载均衡器支持多个域。</li>
<li>基于路径的路由使用路径条件来定义基于请求中的URL将请求转发到不同目标组的规则。 每个路径条件都有一个路径模式。 如果请求中的URL与侦听器规则中的路径模式完全匹配，则使用该规则路由请求。<br>只有ALB支持基于主机和路径的路由。</li>
</ul>
<h2 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h2><ul>
<li>只有ALB支持使用ECS进行动态端口映射，这允许两个服务容器在动态端口上的单个服务器上运行，ALB自动检测并重新配置自身。</li>
</ul>
<h2 id="删除保护"><a href="#删除保护" class="headerlink" title="删除保护"></a>删除保护</h2><ul>
<li>只有ALB支持删除保护，如果启用了删除保护，则无法删除负载均衡器</li>
</ul>
<h2 id="请求跟踪"><a href="#请求跟踪" class="headerlink" title="请求跟踪"></a>请求跟踪</h2><ul>
<li>只有ALB支持请求跟踪来跟踪从客户端到目标或其他服务的HTTP请求。</li>
</ul>
<h2 id="VPC中的IPv6"><a href="#VPC中的IPv6" class="headerlink" title="VPC中的IPv6"></a>VPC中的IPv6</h2><ul>
<li>只有ALB在VPC中支持IPv6</li>
</ul>
<h2 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h2><ul>
<li>只有ALB支持AWS WAF，可以直接在VPC中的ALB（内部和外部）上使用，以保护网站和Web服务</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/26/札记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/札记/" itemprop="url">札记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T19:23:57+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数字化转型（金融）"><a href="#数字化转型（金融）" class="headerlink" title="数字化转型（金融）"></a>数字化转型（金融）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="left"><strong>信息化模型</strong></th>
<th align="left"><strong>数字化模型</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用模式</td>
<td align="left">专线支持的网点、ATM、POS机等客户场景</td>
<td align="left">互联网生态及自有APP的用户场景、无人银行</td>
</tr>
<tr>
<td align="center">人员思维</td>
<td align="left">项目经理思维，架构师思维</td>
<td align="left">产品思维、数据思维</td>
</tr>
<tr>
<td align="center">产品形态</td>
<td align="left">以金融机构为视角的专业化产品</td>
<td align="left">以客户体验为核心的生态化产品</td>
</tr>
<tr>
<td align="center">开发模式</td>
<td align="left">基于完整需求进行瀑布式开发</td>
<td align="left">基于体验点进行敏捷开发</td>
</tr>
<tr>
<td align="center">合作模式</td>
<td align="left">业务部门定义产品，科技部门实现产品</td>
<td align="left">业务部门和科技部门共同定义产品</td>
</tr>
<tr>
<td align="center">团队组织</td>
<td align="left">由项目经理、架构师、领域开发人员组成的开发中心、测试中心、数据中心</td>
<td align="left">包含项目经理、产品经理、全栈开发组成</td>
</tr>
<tr>
<td align="center">技术平台</td>
<td align="left">自建、私有云</td>
<td align="left">自建+ 租用 私有云+公有云</td>
</tr>
<tr>
<td align="center">数据架构</td>
<td align="left">大数据</td>
<td align="left">数据湖</td>
</tr>
<tr>
<td align="center">应用架构</td>
<td align="left">MVC/三层</td>
<td align="left">现代化应用</td>
</tr>
<tr>
<td align="center">开发运维工具</td>
<td align="left">开发工具/运维工具</td>
<td align="left">DevOps、AIoPS</td>
</tr>
<tr>
<td align="center">自动化程度</td>
<td align="left">实现“人管机器”的技术自动化</td>
<td align="left">业务自动化</td>
</tr>
</tbody></table>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><ul>
<li>I/O路经长</li>
<li>latency 大（网络抖动、多副本处理）</li>
</ul>
<p>优化时延主要方法：</p>
<ul>
<li>硬件升级，诸如NVME、RDMA</li>
<li>优化I/O路径，通信框架</li>
<li>优化每个模块的处理时间</li>
<li>优化磁盘布局</li>
<li>增加数据缓存层</li>
</ul>
<h4 id="数据仓库-vs-数据湖"><a href="#数据仓库-vs-数据湖" class="headerlink" title="数据仓库 vs 数据湖"></a>数据仓库 vs 数据湖</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据</td>
<td align="left">来自食物系统、运营数据库、业务应用程序</td>
<td align="left">IoT设备、网络、移动应用程序、社交媒体（非关系）</td>
</tr>
<tr>
<td align="center">Schema</td>
<td align="left">写入型Schema</td>
<td align="left">写入分析时（读取型 Schema）</td>
</tr>
<tr>
<td align="center">性价比</td>
<td align="left">更快查询结果成本高</td>
<td align="left">更快查询结果较低存储成本</td>
</tr>
<tr>
<td align="center">数据质量</td>
<td align="left">可作为重要事实依据的高度监管数据</td>
<td align="left">任何可以或无法进行监管数据</td>
</tr>
<tr>
<td align="center">用户</td>
<td align="left">业务分析师</td>
<td align="left">数据科学家、数据开发人员和业务分析师</td>
</tr>
<tr>
<td align="center">分析</td>
<td align="left">批处理、BI、可视化</td>
<td align="left">机器学习、预测成本、数据发现和分析</td>
</tr>
</tbody></table>
<blockquote>
<p>数据湖概念：</p>
</blockquote>
<p> <em>在保障数据持久性和安全性的前提下，存储任何量级的各种数据（结构化、非结构化、半结构化），并对其运用不同的分析手段（查询、统计、挖掘），以获得数据内在价值并指导业务发展</em></p>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><ul>
<li>InnoDB的行锁匙实现在索引上的</li>
<li>并发控制保证数据一致性常见手段<ul>
<li>锁（locking）</li>
<li>数据多版本（multi versioning）</li>
</ul>
</li>
<li>共享锁（share lock ）,读数据枷锁</li>
<li>排他锁（exclusive lock），修改数据加X锁</li>
<li>写事务未提交，读相关数据select阻塞</li>
<li>由锁机制延伸出数据多版本</li>
</ul>
<p>核心原理</p>
<ul>
<li>写任务发生时，将数据克隆一份，以版本号区别</li>
<li>写人物操作新克隆的数据，直至提交</li>
<li>并发读可以继续读取旧版本数据，不至于阻塞</li>
</ul>
<ul>
<li>普通锁串行，读写锁读读并行，数据多版本读写并行</li>
<li>Redo日志保证已提交事务的ACID特性，设计思路是通过顺序写代替随机写，提高并发</li>
<li>redo 日志保证未提交事务的ACID特性，存储在回滚段中</li>
<li>InnoDB是基于MVCC的存储引擎，利用存储在回滚段里undo日志，即数据的旧版本提高并发 </li>
<li>InnoDB 之所以并发高，快照读不加锁</li>
<li>InnoDB 所有的普通Select 都是快照读</li>
</ul>
<p>InnoDB 存储引擎</p>
<ol>
<li>重做日志 redo log 用于实力故障恢复是，继续那些已经commit 但尚未完全回写到磁盘的事务</li>
<li>回滚日志 undo log 用于在实例故障恢复时，借助undo log将尚未commit的食物，回滚到事务开始前的状态</li>
</ol>
<p>总结：redo log 可以保证事务的原子性和持久性，undo log可以保证事务的一致性（事务的隔离性是由锁来实现的）<br>redo和undo 都可以视作一种恢复操作，redo恢复提交事务修改的页操作，记录的内容是物理日志，记录的是页的物理修改操作；而undo回滚行记录到某个特定的版本，记录的是逻辑日志，根据每行记录进行记录。</p>
<p>数据库索引</p>
<ol>
<li>B+ 树 数据结构：高度平衡的多叉树，叶子节点保存所有数据。（注意B+树的非聚集索引的叶子节点并不是直接存放的给定键值的行，而是数据行所在的页，然后数据库通过把页读入内存，再在内存中查找）</li>
<li>B+ 树数据结构应用在数据库的索引实现中，具有高度的扇出性，一般B+树的高度都在2～4层，也就是说查找某一键值的行记录时最多只需要2～4此IO</li>
</ol>
<p>B+树索引可以分为聚集索引（主键索引，已主键作为key的索引）和辅助索引（非聚集索引）。</p>
<ul>
<li>聚集索引的叶子节点保存的是数据，即行记录；</li>
<li>InnoDB的主键索引的排序查找和范围查找非常快；</li>
</ul>
<p>InnoDB的数据文件本身就是索引文件。MyISAM索引文件爱你和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引仅够，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引data域存储相应记录主键的值而不是地址，InnoDB的所有辅助索引引用主键作为data域。<br>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两边索引：首先检索辅助索引获得主键，然后哦用主键到主索引中检索获得记录。</p>
<p>数据库事务隔离级别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>隔离级别</strong></td>
<td align="left"><strong>脏读（Dirty Read）</strong></td>
<td align="left"><strong>不可重复读（NonRepeattable Read）</strong></td>
<td align="left"><strong>幻读（Phantom Read）</strong></td>
</tr>
<tr>
<td align="left">未提交读 （Read uncommited）</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">已提交读（Read commited）</td>
<td align="left">不可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可重复读（Repeatable read）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可串行化（Serializable）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
</tr>
</tbody></table>
<ul>
<li>未提交读（Read Uncommited）：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读（Read Committed）：只能读取到已经提交的数据。Oracle等多数据默认都是该级别（不重复读）</li>
<li>可重复读（RepeatedRead）：可重复读。在同一个事务内的查询都是事务开始时刻是一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻想读。</li>
<li>串行读（Serializable）：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<p>MySQL尽量避免使用NULL（空值）列，其使得索引、索引统计和值都比较复杂</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/26/AWS-Route-53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/AWS-Route-53/" itemprop="url">AWS Route 53</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T19:15:38+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Amazon Route 53 是一种具有很高可用性和可扩展性的域名系统 (DNS) Web 服务。可以使用 Route 53 以任意组合执行三个主要功能：域注册、DNS 路由和运行状况检查。</p>
<ol>
<li><p>域名注册</p>
</li>
<li><p>将Internet路由到域名</p>
<ul>
<li>域名解析到正确的IP地址</li>
<li>使用权威DNS服务器的全局网络响应DNS查询，从而减少延迟</li>
<li>将Internet流量路由到CloudFront，Elastic Beanstalk，ELB或S3。 对这些资源进行DNS查询是免费的</li>
</ul>
</li>
<li><p>检查资源的运行状况</p>
<ul>
<li>可以监控Web和电子邮件服务器等资源的运行状况。</li>
<li>通过Internet向应用程序发送自动请求</li>
<li>验证它是否可访问，可用且功能正常</li>
<li>可以为运行状况检查配置CloudWatch警报，以便在资源不可用时发送通知。</li>
<li>可以配置为将Internet流量路由远离不可用的资源</li>
</ul>
<h2 id="支持的DNS记录类型"><a href="#支持的DNS记录类型" class="headerlink" title="支持的DNS记录类型"></a>支持的DNS记录类型</h2></li>
</ol>
<ul>
<li><p>A（IPv4地址记录）</p>
</li>
<li><p>AAAA（IPv6 地址记录）</p>
</li>
<li><p>CNAME（规范名称记录）</p>
<ul>
<li>格式与域名相同</li>
<li>DNS协议不允许为DNS命名空间的顶级节点创建CNAME记录，也称为区域顶点（例如，区域顶点）。 DNS名称example.com注册，区域顶点是example.com，无法创建example.com的CNAME记录，但可以为<a href="http://www.example.com，newproduct.example.com等创建CNAME记录。" target="_blank" rel="noopener">www.example.com，newproduct.example.com等创建CNAME记录。</a></li>
<li>如果为子域创建了CNAME记录，则无法为该子域创建该子域的任何其他资源记录集。如果为<a href="http://www.example.com创建了CNAME，而不是可以创建名称字段值为www.example.com的其他资源记录集" target="_blank" rel="noopener">www.example.com创建了CNAME，而不是可以创建名称字段值为www.example.com的其他资源记录集</a></li>
</ul>
</li>
<li><p>CAA (认证机构授权)</p>
</li>
<li><p>MX (邮件交换记录)</p>
</li>
<li><p>NAPTR（命名授权指针记录）</p>
</li>
<li><p>NS（名称服务器记录）</p>
<ul>
<li>NS记录标识托管区域的名称服务器。 NS记录的值是名称服务器的域名。</li>
</ul>
</li>
<li><p>PTR（指针记录）</p>
</li>
<li><p>SOA（起始授权记录）</p>
</li>
<li><p>SPF（发件人策略框架）</p>
</li>
<li><p>SRV（服务定位器）</p>
</li>
<li><p>TXT（文本记录）</p>
</li>
<li><p>Amazon Route 53 还提供别名记录，这些记录是 Amazon Route 53 专用的 DNS 扩展。</p>
</li>
</ul>
<h2 id="Alias-记录类型"><a href="#Alias-记录类型" class="headerlink" title="Alias 记录类型"></a>Alias 记录类型</h2><ul>
<li>Route　53支持别名资源记录集，可以将查询路由到CloudFront分配，Elastic Beanstalk，ELB，配置为静态网站的S3存储桶或其他Route 53资源记录集</li>
<li>别名记录不是DNS RFC的标准，是Route 53的扩展功能</li>
<li>别名记录类似于CNAME记录，但可以为根域或顶点域、子域创建别名记录，而cname只能用于记录子域</li>
<li>Route 53自动识别别名记录资源所引用的资源记录的变化，如对于指向ELB的指导年，若负载均衡的IP发生变化，则Route 53将自动在DNS的回应中反映这些变化，而不对包含资源记录集的托管区域进行任何更改</li>
<li>若alias记录集指向CloudFront、ELB或S3，则无法设置TTL；Route 53使用cloudfront、LB或者S3的TTL</li>
</ul>
<table>
<thead>
<tr>
<th>NAME 记录</th>
<th>别名记录</th>
</tr>
</thead>
<tbody><tr>
<td>CNAME 记录可以将 DNS 查询重定向到任何 DNS 记录。例如，可以创建一条 CNAME 记录，该记录将查询从 acme.example.com 重定向到 zenith.example.com 或 acme.example.org。不需要使用 Route 53 作为您要将查询重定向到的域的 DNS 服务。</td>
<td>别名记录只能将查询重定向到选定的 AWS 资源，例如：Amazon S3 存储桶 ;CloudFront 分配;其中创建别名记录的 Route 53 托管区域中的其他记录;例如，可以创建一个名为 acme.example.com 的别名记录，该记录将查询重定向到 Amazon S3 存储桶（也称为 acme.example.com.）。还可以创建一个 acme.example.com 别名记录，该记录将查询重定向到 example.com 托管区域中名为 zenith.example.com 的记录。</td>
</tr>
<tr>
<td>不能创建与托管区域（区域 APEX）同名的 CNAME 记录。对于域名 (example.com) 的托管区域和子域 (zenith.example.com) 的托管区域都是如此。</td>
<td>在大多数配置中，您可以创建一个与托管区域（区域 APEX）同名的别名记录。一个例外情况是，当您要将来自区域 APEX（如 example.com）的查询重定向到具有类型 CNAME（如 zenith.example.com）的同一托管区域中的记录时。别名记录必须与您要将流量路由到的目标记录具有相同的类型，而为顶级域名创建 CNAME 记录的做法不受支持，即使对于别名记录也是如此。</td>
</tr>
<tr>
<td>Route 53 收取 CNAME 查询费用。</td>
<td>对于 AWS 资源的别名查询，Route 53 不收费。有关更多信息，请参阅 Amazon Route 53 定价。</td>
</tr>
<tr>
<td>无论记录类型如何，CNAME 记录都会重定向对记录名称（如 A 或 AAAA）的 DNS 查询。</td>
<td>仅当别名记录的名称（如 acme.example.com）和别名记录的类型（如 A 或 AAAA）与 DNS 查询中的名称和类型匹配时，Route 53 才响应 DNS 查询。</td>
</tr>
<tr>
<td>CNAME 记录在响应 dig 或 nslookup 查询时显示为 CNAME 记录。</td>
<td>别名记录显示为您在创建记录时指定的记录类型，例如 A 或 AAAA。别名属性仅在 Route 53 控制台中或在响应以编程方式发出的请求时可见，例如 AWS CLI list-resource-record-sets 命令。</td>
</tr>
</tbody></table>
<h2 id="托管区域"><a href="#托管区域" class="headerlink" title="托管区域"></a>托管区域</h2><ul>
<li>托管区域是一个记录容器，记录中包含的信息说明您希望如何路由特定域（如 example.com）及其子域（acme.example.com、zenith.example.com）的流量。</li>
<li>管区域与相应域具有相同的名称。</li>
<li>有两种类型的托管区域：<ul>
<li>公有托管区域 包含指定了如何路由 Internet 流量的记录。</li>
<li>私有托管区域 包含指定了如何在 Amazon VPC 中路由流量的记录。</li>
</ul>
</li>
<li>在托管区域中创建记录<ul>
<li>记录定义了为每个域名或子域名路由路由的位置。</li>
<li>托管区域中每条记录的名称必须以托管区域的名称结尾。</li>
</ul>
</li>
</ul>
<h2 id="Route-53-Split-view-Split-horizon-DNS"><a href="#Route-53-Split-view-Split-horizon-DNS" class="headerlink" title="Route 53 Split-view(Split-horizon) DNS"></a>Route 53 Split-view(Split-horizon) DNS</h2><ul>
<li>允许公开使用的相同域名访问网站的内部版本</li>
<li>使用Route 53 Spilt-view 为DNS维护具有相同域名的私有和公共托管区域</li>
<li>确保在VPC上启用DNS解析和DNS主机名</li>
<li>DNS查询将根据请求的来源回答答案。 在VPC内，答案将来自私有托管区域，而公共查询将从公共托管区域返回答案。</li>
</ul>
<h1 id="DNS-路由策略"><a href="#DNS-路由策略" class="headerlink" title="DNS 路由策略"></a>DNS 路由策略</h1><h2 id="简单路由策略"><a href="#简单路由策略" class="headerlink" title="简单路由策略"></a>简单路由策略</h2><ul>
<li>简单路由策略是一种简单的循环策略，可以在有单个资源为域执行功能时应用。如为网站提供内容的服务器</li>
<li>AWS Route 53基于资源记录集中的值来响应DNS查询。 如A记录中的IP地址</li>
</ul>
<h2 id="加权轮询（WRR）"><a href="#加权轮询（WRR）" class="headerlink" title="加权轮询（WRR）"></a>加权轮询（WRR）</h2><ul>
<li>加权路由策略使路由53能够以指定的比例（权重）将流量路由到不同的资源，例如，75％的一个服务器和25％的另一个服务器</li>
<li>可以为权重指定0到255之间的任何数字</li>
<li>当存在多个执行相同功能的资源（例如，服务于相同站点的web服务器）时，可以应用加权路由策略</li>
<li>加权资源记录集允许您将多个资源与单个DNS名称相关联</li>
<li>常见用例包括<ul>
<li>负载均衡</li>
<li>A / B测试和试用新版软件</li>
</ul>
</li>
<li>创建一组加权资源记录集，可以创建具有相同DNS名称和类型组合的两个或更多资源记录集，并且为每个资源记录集分配唯一标识符和相对权重</li>
<li>处理DNS查询时，Route 53搜索具有指定名称和类型的资源记录集或一组资源记录集</li>
<li>Route 53从组中选择一个。选择任何一个资源记录集的概率取决于其权重作为该组中所有资源记录集的总权重的比例，例如，假设<a href="http://www.example.com具有三个权重为1的资源记录集（20％）" target="_blank" rel="noopener">www.example.com具有三个权重为1的资源记录集（20％）</a> ），1（20％）和3（60％）（总和= 5）。平均而言，Route 53在五分之一的时间中选择前两个资源记录集中的每一个，并且返回三分之三的时间的第三资源记录集。</li>
</ul>
<h2 id="基于延迟的路由（LBR）"><a href="#基于延迟的路由（LBR）" class="headerlink" title="基于延迟的路由（LBR）"></a>基于延迟的路由（LBR）</h2><ul>
<li>基于延迟的路由策略使Route 53能够根据哪个数据中心为用户提供最低的网络延迟来响应DNS查询</li>
<li>当有多个资源执行相同的功能时，可以使用基于延迟的路由策略，并且Route 53需要配置为使用提供最快响应和最低延迟的资源来响应DNS查询</li>
<li>可以为托管应用程序的每个区域中的EC2资源创建延迟资源记录集。当Route 53收到对应域的查询时，它会选择为EC2区域设置的延迟资源记录，为用户提供最低延迟。然后，Route 53以与该资源记录集相关联的值进行响应，例如，您能在爱尔兰和东京的EC2数据中心中具有example.com的Web服务器。当用户从新加坡浏览example.com时，Route 53将从用户位置获取具有最低延迟的数据中心（东京）</li>
<li><strong>由于网络连接和路由的变化，Internet上主机之间的延迟可能会随着时间的推移而发生变化。基于延迟的路由基于在一段时间内执行的等待时间测量，并且测量结果反映了这些变化。</strong>如果新加坡用户到爱尔兰的延迟有所改善，用户可以路由到爱尔兰</li>
<li>基于延迟的路由不能保证来自相同地理位置的用户出于任何合规性原因将从同一位置提供服务</li>
<li>可以使用Route 53支持的除NS或SOA之外的任何记录类型来创建延迟资源记录集</li>
</ul>
<h2 id="故障转移策略（Failover）"><a href="#故障转移策略（Failover）" class="headerlink" title="故障转移策略（Failover）"></a>故障转移策略（Failover）</h2><ul>
<li>故障转移路由策略允许主动 - 被动故障转移配置，其中一个资源在可用时占用所有流量，而另一个资源在第一个资源不可用时占用所有流量。</li>
<li>Route 53运行状况检查代理将监视应用程序的每个位置/端点以确定可用性。</li>
<li>故障转移路由策略仅适用于公共托管区域</li>
</ul>
<h2 id="地理位置路由策略（Geo-DNS）"><a href="#地理位置路由策略（Geo-DNS）" class="headerlink" title="地理位置路由策略（Geo DNS）"></a>地理位置路由策略（Geo DNS）</h2><ul>
<li>地理位置路由策略使路由53能够根据用户的地理位置（即DNS查询源自的位置）响应DNS查询</li>
<li>常见用例包括<ul>
<li>内容的本地化和以用户语言呈现部分或全部网站</li>
<li>限制内容的分发仅限于您拥有发行权的位置。</li>
<li>以可预测，易于管理的方式平衡端点之间的负载，以便每个用户位置始终路由到同一端点。</li>
</ul>
</li>
<li>地理位置路由策略允许按洲，国家或州（仅在美国）指定地理位置</li>
<li>地理定位记录集，如果创建的话，用于例如重叠的地理区域。非洲大陆，然后是同一大洲的国家，优先考虑最小的地理区域，这允许将一个大陆的一些查询路由到一个资源，并查询该大陆上的选定国家的不同资源</li>
<li>地理定位的工作原理是将IP地址映射到位置，这些位置可能未映射到确切的地理位置</li>
<li>可以创建默认资源记录集来处理这些查询，也可以创建没有创建显式记录集的查询</li>
<li>如果未创建默认资源记录集，则Route 53对来自这些位置的查询返回“无应答”响应</li>
<li>无法创建指定相同地理位置的两个地理位置资源记录集</li>
<li>Route 53支持EDNS0的edns-client-subnet扩展（EDNS0为DNS协议添加了几个可选扩展。）以提高地理定位路由的准确性</li>
</ul>
<h1 id="AWS-Route-53-Resolver"><a href="#AWS-Route-53-Resolver" class="headerlink" title="AWS Route 53 Resolver"></a>AWS Route 53 Resolver</h1><h2 id="解析VPC和本地网络之间的DNS查询"><a href="#解析VPC和本地网络之间的DNS查询" class="headerlink" title="解析VPC和本地网络之间的DNS查询"></a>解析VPC和本地网络之间的DNS查询</h2><ul>
<li>Route 53 Resolver在VPC内提供自动DNS解析</li>
<li>默认情况下，Resolver会回答VPC域名的DNS查询，例如EC2实例或ELB负载均衡器的域名</li>
<li>Resolver对所有其他域名的公共名称服务器执行递归查找</li>
<li>但是，本地实例无法解析Route 53 DNS条目，而Route 53无法解析本地DNS条目</li>
<li>可以通过Direct Connect或VPN连接配置AWS VPC与本地网络之间的DNS解析</li>
<li>Route 53 Resolver是区域性的</li>
<li>要使用入站或出站转发，请在VPC中创建解析器端点</li>
<li>作为端点定义的一部分，指定要将入站DNS查询转发到的IP地址或要从其发出的出站查询的IP地址。 对于指定的每个IP地址，Resolver会自动创建VPC弹性网络接口</li>
</ul>
<h2 id="将-DNS-查询从网络上的解析程序转发到-Route-53-解析程序"><a href="#将-DNS-查询从网络上的解析程序转发到-Route-53-解析程序" class="headerlink" title="将 DNS 查询从网络上的解析程序转发到 Route 53 解析程序"></a>将 DNS 查询从网络上的解析程序转发到 Route 53 解析程序</h2><p><img src="https://i.loli.net/2019/08/26/7PEZxyOBLbNWR3h.png" alt="Resolver-inbound-endpoint.png"></p>
<ul>
<li>本地网络上的DNS解析器可以将DNS查询转发到指定VPC中的解析器。</li>
<li>这使DNS解析器能够轻松解析AWS资源的域名，例如EC2实例或Route 53私有托管区域中的记录。</li>
</ul>
<h2 id="将查询从-VPC-有条件地转发到您网络上的解析程序"><a href="#将查询从-VPC-有条件地转发到您网络上的解析程序" class="headerlink" title="将查询从 VPC 有条件地转发到您网络上的解析程序"></a>将查询从 VPC 有条件地转发到您网络上的解析程序</h2><p><img src="https://i.loli.net/2019/08/26/UPLo5bKJQHVxmIw.png" alt="Resolver-outbound-endpoint.png"></p>
<ul>
<li>配置解析程序，将它从 VPC中EC2实例收到的查询转发到您网络上的 DNS 解析程序</li>
<li>要转发选定的查询，可以创建解析程序规则，指定要转发的 DNS 查询的域名（例如 example.com），以及希望将查询转发到网络上的 DNS 解析程序的 IP 地址</li>
<li>如果查询与多个规则匹配（example.com、acme.example.com），解析程序会选择匹配最具体的规则 (acme.example.com) 并将查询转发到该规则中指定的IP地址</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/22/AWS-Storage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/AWS-Storage/" itemprop="url">AWS Storage</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T21:21:37+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://i.loli.net/2019/08/20/S5pGc6xsHIB8MlZ.jpg" alt="AWS——Storage (2).jpeg"></p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><blockquote>
<p>AWS提供多种基于云的存储选择，每个服务都具有独特的性能、持久性、可用性、成本和接口，以及其他特性(如可伸缩性和弹性)。在选择存储服务请考虑其适应场景和Anti-Patterns（不推荐）模式。（可参考下图）</p>
</blockquote>
<p><img src="https://i.loli.net/2019/08/20/17jtOg8lUSsuWQH.png" alt="002.png"><br><em>本文以下内容不涉及EC2 Instancestore、CloudFront、RDS、ElasticeCache等有关数据的存储，主要是以独立的存储服务提供数据存储与管理的服务组件，因为如instancestore是临时性的，在EC2的生命周期结束之后数据就会被删除，而RDS数据库的数据处理引擎和存储有着比较紧密的耦合度（不是指不可分离），不在这里阐述.</em></p>
<h1 id="S3-对象存储"><a href="#S3-对象存储" class="headerlink" title="S3(对象存储)"></a>S3(对象存储)</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>高度可扩展，可靠且低延迟的数据存储基础架构，成本极低。</li>
<li>通过一个简单的Web服务接口，可以在<font color="red">任何时间</font>从EC2内或Web上的<font color="red">任何位置</font>存储和检索<font color="red">任何数量</font>的数据。</li>
<li>write、read、delete等操作，每个对象大小1byte~5TB之间。</li>
<li>S3 bucket中的对象数量可以理解为无限的。</li>
<li>强安全控制，支持静态加密，并提供多种机制来提供对Amazon S3资源访问的细粒度控制（ACL、Policy、IAM）。</li>
<li>可扩展，允许许多单独的客户端或应用程序线程对Amazon S3数据进行并发读取或写入访问。</li>
<li>提供数据生命周期管理功能，允许用户定义规则以自动将Amazon S3数据存档到Amazon Glacier，或者在生命周期结束时删除数据。</li>
</ul>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>存储和分发静态web内容和媒体<ul>
<li>静态网站托管，并仅为具有静态内容的网站提供高度可用、可扩展的解决方案，支持HTML、图像、视频和客户端脚本（如javascript）。</li>
<li>适用于快速增长的互联网网站，托管密集型数据，如视频、照片共享网站（Instagram，不需要考虑存储的供给问题）</li>
<li>每一个content都可以通过对象的唯一HTTP URL访问。</li>
<li>作为CDN溯源（Origin）站点，如搭配CloudFront会有更好的效果</li>
<li>借助S3的弹性设计，非常适合承载带宽要求极高的web内容</li>
</ul>
</li>
<li>大型对象数据存储<ul>
<li>可以与RDS或NoSQL数据库配合，用于存储大型对象，例如 文件或对象，而关联的元数据例（如名称，标签，注释等）可以存储在RDS或NoSQL数据库中，可以对其进行索引和查询，从而更快地访问相关数据。（对象存储系统并不像文件系统一样有自己的索引机制，所以其访问实际是由独立的URL实现的。）</li>
</ul>
</li>
<li>计算和大规模分析的数据存储（计算之后）<ul>
<li>通常用作计算和大规模分析的数据存储，例如金融交易分析，点击流分析（网站）和媒体转码数据。</li>
<li>借助其水平伸缩性，同时从多个计算节点访问数据而不受单个连接的限制。</li>
</ul>
</li>
<li>关键数据的备份和归档<ul>
<li>借助其数据高度持久性、架构可扩展性、数据安全方案，可用作数据备份和归档领域，并未业务连续性提供灾难恢复解决方案</li>
<li>数据冗余的存储region范围内（即覆盖AZ之间，）提供以上场景所需的高度持久的存储基础设施。</li>
<li>提供版本控制功能，用于关键数据意外删除。(need enable version  feature)</li>
</ul>
</li>
</ul>
<h2 id="Anti-Patterns（不建议）"><a href="#Anti-Patterns（不建议）" class="headerlink" title="Anti-Patterns（不建议）"></a>Anti-Patterns（不建议）</h2><ul>
<li>动态网站<ul>
<li>S3非常适合托管静态网站，但是无法托管需要服务器端交互，脚本或数据库交互的动态网站，而应该托管在Amazon EC2上。（也就是其本质是WORM属性，适合读场景，并不适合数据变化快的场景）</li>
</ul>
</li>
<li>备份和归档存储<ul>
<li>不频繁读取访问权限的长期归档存储的数据可以在Glacier中更经济有效地存储。</li>
</ul>
</li>
<li>结构化数据查询<ul>
<li>Amazon S3不提供查询功能，因此要读取对象，必须知道对象名称和键。相反，将S3与RDS或Dynamo DB配合，以存储、索引和查询关于Amazon S3对象的元数据</li>
<li>注意:S3现在提供了查询功能，也可以使用Athena（一种交互式查询服务，可使用此服务通过标准 SQL 在 Amazon S3 中轻松分析数据）</li>
</ul>
</li>
<li>快速变化的数据<ul>
<li>频繁更新的数据，建议使用具有较低读/写延迟的存储解决方案，如Amazon EBS卷、RDS或Dynamo DB。</li>
</ul>
</li>
<li>文件系统<ul>
<li>S3使用扁平的命名空间，不能作为独立的或通过POSIX兼容文件系统。但是可以通过使用分隔符（通常是’/‘或’’字符），可以构造键值模拟给定存储桶中文件系统的分层文件夹结构。（对象存储系统是扁平的结构，而文件系统是树状结构）</li>
</ul>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>在同一region内，EC2访问S3速度很快。</li>
<li>S3在设计上，相较于Internet网络访问在服务器端延迟是相对很低的。</li>
<li>S3在扩展性，请求数和用户访问数，支持几乎无限数量的Web级应用程序。</li>
<li>对于多线程、多应用程序或多客户访问S3，则S3的总吞吐量通常是以线性增加的方式提供服务或响应需求。</li>
</ul>
<h2 id="冗余性-amp-可用性"><a href="#冗余性-amp-可用性" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>S3在所选地理范围内，通过多设备和多设施之间自动化、同步机制实现数据存储最高级别的数据持久性和可用性。</li>
<li>内置数据的纠错机制（Daemon模式）和高可用架构（没有单点故障）。</li>
<li>设计目标：每个对象99.999999999％（11个9）的持久性和一年内（使用周期内，每个region可能有差异）99.99％的可用性。</li>
<li>提供版本控制功能，以防意外删除或覆盖。</li>
<li>支持MFA（多重身份验证）模式控制存储桶的版本控制功能。（双重身份验证）</li>
<li>非关键和可重复的数据，例如缩略图，转码媒体等，可使用S3 Reduced Redundancy Storage（RRS），以较低的存储成本提供较低的耐用性。</li>
<li>RRS的设计目标是在给定的一年内为每个对象提供99.99%的耐久性。虽然RRS不如标准的Amazon S3耐用，但它的耐用性仍然是典型磁盘驱动器的400倍。</li>
</ul>
<h2 id="扩展性-amp-弹性"><a href="#扩展性-amp-弹性" class="headerlink" title="扩展性&amp;弹性"></a>扩展性&amp;弹性</h2><p>注：Elasticity and Scalability 对比，英文原文如下（个人觉得比较好的解释）</p>
<ul>
<li>Scalability is the ability of a system to handle the increased load on its current hardware and software resources. In a highly scalable system it is possible to increase the workload without increasing the resource capacity. Scalability supports any sudden surge in the demand/traffic with current set of resources.（可伸缩性是系统处理其当前硬件和软件资源上增加的负载的能力。 在高度可扩展的系统中，可以在不增加资源容量的情况下增加工作量。 可扩展性支持使用当前资源集的任何突然的需求/流量激增。）</li>
<li>Elasticity is the ability of a system to increase the workload by increasing the hardware/software resources dynamically. Highly elastic systems can handle the increased demand and traffic by dynamically commission and decommission resources. Elasticity is an important characteristic of Cloud Computing applications. Elasticity means how well your architecture is adaptable to workload in real time.（弹性是系统通过动态增加硬件/软件资源来增加工作负载的能力。 高弹性系统可以通过动态调试和停用资源来处理增加的需求和流量。 弹性是云计算应用程序的一个重要特征，意味着架构能够实时适应工作负载。）</li>
<li>S3旨在自动提供非常高的伸缩性、弹性。</li>
<li>S3 bucket几乎可以无限数量的存储对象数据和文件。</li>
<li>S3将自动管理扩展并将数据的冗余副本分发到同一区域中其他AZ中的存储设备上，所有这些都使用AWS的高性能基础架构。</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>S3为管理和数据操作提供标准的REST和SOAP Web服务API。（注 -不推荐使用HTTP上的SOAP支持，但仍可通过HTTPS使用它。 SOAP不支持新的Amazon S3功能。建议使用REST API或AWS SDK。）</li>
<li>S3提供易于使用的高级别的工具包或SDK，封装了包含底层API的不同语言（如Java，.NET，PHP和Ruby）。</li>
<li>S3命令行界面（CLI）提供一组常见操作的类高级Linux Amazon S3文件命令，例如ls，cp，mv，sync等。还提供执行递归上载和下载的功能使用文件夹级别的S3命令，并支持并行传输。</li>
<li>管理控制台提供简单的基于Web的用户界面轻松创建和管理Amazon S3存储桶，上载和下载对象以及浏览Amazon S3存储桶内容的功能。</li>
<li>所有接口都能够将S3对象（文件）存储在唯一命名的存储桶（top-level folders）中，每个对象在该存储桶中的都具有唯一对象标识符（key id）。</li>
</ul>
<h1 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>极低成本的存储服务，为数据备份和存档提供高度安全，持久和灵活的存储。</li>
<li>可靠地存储数据，并且每月只需0.01美元每千兆字节。（价格可能变动）</li>
<li>将操作和扩展存储的管理负担转移到AWS，例如容量规划、硬件供应、数据复制、硬件故障检测和修复，或耗时的硬件迁移等。（用户只需关注其归档服务即可，其他一概不需要care）</li>
<li>数据作为归档文件存储在Glacier中，归档文件可以表示单个文件，也可以表示多个文件合成一个归档文件。</li>
<li>通过IAM控制访问存储在Vault中的存档文件。</li>
<li>从Vaults检索存档需要启动一个job,并且可能需要大约3-5个小时才能取回数据。</li>
<li>Glacier通过使用S3数据生命周期管理策略将数据从S3移动到Glacier，从而与Amazon S3无缝集成。<strong>（其实数据是不能直接归档到Glacier的，需要经过S3）</strong></li>
<li>AWS Import / Export可用于加速使用便携式存储设备将大量数据移动到Amazon Glacier进行存储归档。</li>
</ul>
<h2 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>Glacier是理想的长期档案解决方案，不经常访问的数据存档企业信息，媒体资产，研究和科学数据，数字保存和磁带更换的最佳替换者。（总之一句话，面向归档存储。）</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）"><a href="#Anti-Patterns（不建议模式）" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>快速变化数据<ul>
<li>频繁更新的数据，建议使用具有较低读/写延迟的存储解决方案，如Amazon EBS卷、RDS或Dynamo DB。</li>
</ul>
</li>
<li>实时数据访问<ul>
<li>无法实时访问存储在Glacier中的数据，并且需要启动用于对象检索的job，检索时间范围为3-5小时。若需要立即访问，Amazon S3是更好的选择。</li>
</ul>
</li>
</ul>
<h2 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h2><ul>
<li>Glacier是一种低成本存储服务，旨在存储不经常访问且使用寿命长的数据。</li>
<li>Glacier的工作通常在3到5个小时内完成（默认）。</li>
<li>加速检索1<del>5分钟，批量检索5</del>12H（加费用）</li>
</ul>
<h2 id="持久性和可用性"><a href="#持久性和可用性" class="headerlink" title="持久性和可用性"></a>持久性和可用性</h2><ul>
<li>Glacier将数据冗余地存储在多个基础设施中以及每个设施内的多个存储设备上</li>
<li>Glacier旨在为存档提供99.999999999％（11个9）的平均年度耐久性。</li>
<li>Glacier会在上传归档返回SUCCESS之前，将数据同步存储在多个设施中以确保数据一致性。</li>
<li>Glacier定期执行的系统数据完整性检查，并可自动进行自我修复，以确保数据完整性。</li>
</ul>
<h2 id="扩展性和弹性"><a href="#扩展性和弹性" class="headerlink" title="扩展性和弹性"></a>扩展性和弹性</h2><ul>
<li>单个存档文件上限限制为40 TB，但Glacier服务中存储的数据总量没有限制。</li>
<li>无论是存储数PB还是千兆，Glacier都可以扩展以满足不断增长且通常无法预测的存储容量要求， Glacier会根据需要自动扩展或缩小存储。</li>
</ul>
<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><ul>
<li>Glacier提供标准的原生REST Web服务接口，以及Java和.NET SDK。</li>
<li>AWS管理控制台或Glacier API可用于创建存储Vault以组织Glacier中的存档。</li>
<li>Glacier api可用于上传和检索归档文件，监视作业的状态，还可以配置Vault，以便在作业完成时通过Amazon SNS发送通知。</li>
<li>使用对象生命周期管理，从S3到Glacier提供自动，策略驱动的归档。</li>
<li>S3 api提供了一个恢复操作，检索过程同样需要3-5个小时。</li>
<li>在检索时，检索到的对象的副本将放置在S3 RRS存储中（一定的保留期）;原始存档对象仍存储在Amazon Glacier中，仍需要为存储付费，除非删除。</li>
<li>在S3中使用Amazon Glacier作为存储层（Class）时，使用Amazon S3 API，当使用“native（原生）” Glacier时使用Glacier API。</li>
<li>通过S3归档到Glacier的对象只能通过Amazon S3 api或AWS管理控制台列出和检索—它们不能作为Glacier vault中的归档文件显示。</li>
</ul>
<h1 id="为数据选择合适的S3分类"><a href="#为数据选择合适的S3分类" class="headerlink" title="为数据选择合适的S3分类"></a>为数据选择合适的S3分类</h1><p><img src="https://i.loli.net/2019/08/20/4ecOy7jliw3dHZr.jpg" alt="存储分类-S3.jpeg"></p>
<h3 id="S3-Standard"><a href="#S3-Standard" class="headerlink" title="S3 Standard"></a>S3 Standard</h3><ul>
<li>活跃且频繁访问数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1755/GB</li>
</ul>
<h3 id="S3-Intelligent-tiering-（利用了大数据技术进行分层处理）"><a href="#S3-Intelligent-tiering-（利用了大数据技术进行分层处理）" class="headerlink" title="S3 Intelligent_tiering （利用了大数据技术进行分层处理）"></a>S3 Intelligent_tiering （利用了大数据技术进行分层处理）</h3><ul>
<li>访问模式不确定数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1030/GB~0.1775/GB</li>
<li>最小存储周期</li>
</ul>
<h3 id="S3-Standard-IA"><a href="#S3-Standard-IA" class="headerlink" title="S3 Standard-IA"></a>S3 Standard-IA</h3><ul>
<li>不频繁访问数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1030/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-One-Zone-IA"><a href="#S3-One-Zone-IA" class="headerlink" title="S3 One Zone-IA"></a>S3 One Zone-IA</h3><ul>
<li>可重建数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.0824/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 Glacier</h3><ul>
<li>归档数据</li>
<li>分钟到小时级别恢复时间</li>
<li>≥3个可用区</li>
<li>￥0.0300/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-Glacier-Deep-Archive"><a href="#S3-Glacier-Deep-Archive" class="headerlink" title="S3 Glacier Deep Archive"></a>S3 Glacier Deep Archive</h3><ul>
<li>归档数据</li>
<li>小时级别恢复时间（12~48）</li>
<li>≥3个可用区</li>
<li>￥0.010800/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h1 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul>
<li>EBS为EC2实例提供持久的块级存储</li>
<li>EBS独立于EC2实例，具备生命周期、通过网络连接非依赖实例的存储</li>
<li>EBS卷通过附加到实例，可以像物理硬盘驱动器一样使用，通过文件系统格式化之后，即可用文件系统的I/O接口实现数据的存储与管理</li>
<li>EBS卷可用于引导EC2实例(仅Amazon EBS-root ami)，多个Amazon EBS卷可附加到一个EC2实例（多对一）</li>
<li>EBS卷在单一时间只能挂载一个EC2实例。（不支持1对多挂载）</li>
<li>EBS提供基于时间点快照的功能，这些快照保存在S3中。快照可用于实例化新的EC2卷并保护数据以实现长期保存</li>
<li>EBS快照也可以跨AWS区域复制，从而可以更轻松地利用多个AWS区域进行地理扩展，进行数据中心迁移和灾难恢复</li>
</ul>
<h2 id="使用范例-2"><a href="#使用范例-2" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>EBS适用于数据变化相对频繁并且需要长期持久化的场景</li>
<li>EBS卷提供对裸块级存储的访问，特别适合用作数据库或主文件系统存储</li>
<li>预配置IOPS卷特别适合与需要速度且具有数据一致性的随机磁盘读写的数据库应用程序一起使用</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）-1"><a href="#Anti-Patterns（不建议模式）-1" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>临时性数据<ul>
<li>EBS卷独立于EC2生命周期</li>
<li>对于cache、buffer、queue等数据，建议使用本地存储，SQS或Elastice cache</li>
</ul>
</li>
<li>持久性数据<ul>
<li>年持久性可达99.5～99.9%（最近一次修改数据少于20GB的EBS卷），数据修改约频繁，其持久性会下降</li>
<li>对于数据持久性有更高要求的，建议使用S3或Glacier</li>
</ul>
</li>
<li>静态数据或网站内容<ul>
<li>对于数据很少更改的静态web内容，使用EC2的EBS卷提供 web服务页面</li>
<li>S3是存储这种固定信息的更经济有效和可伸缩的解决方案，并且可以直接从S3提供服务。</li>
</ul>
</li>
</ul>
<h2 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h2><ul>
<li>EBS提供两种卷类型：标准卷和预配置IOPS卷，它们在性能和价格模型上有所不同，根据应用程序的需要的存储性能和成本进行选择</li>
<li>可以使用RAID 0或逻辑卷管理器软件在多个EBS卷之间进行条带EBS卷，从而聚合提高可用的IOPS、吞吐量和卷大小</li>
<li>标准卷可为普通或突发I / O要求的应用程序提供经济高效的数据吞吐。标准卷也非常适合用作启动卷，其中突发功能提供快速的实例启动时间</li>
<li>预配置IOPS卷旨在为I / O密集型工作负载（如数据库）提供可预测的高性能。使用预配置IOPS，在创建卷时指定IOPS， EBS在指定的生命周期提供一致数据速率</li>
<li>EBS卷是通过网络连接挂载的，实例执行的其他网络I / O以及共享网络上的负载会影响EBS卷的性能。启动EBS优化实例，在EC2和EBS之间提供专用的吞吐量，并使实例能够充分利用Amazon EBS卷上提供的IOPS</li>
<li>根据需求将EBS卷配置为EBS标准或EBS预配置IOPS。或者，也可以对数据进行条带化</li>
</ul>
<h2 id="冗余性-amp-可用性-1"><a href="#冗余性-amp-可用性-1" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>EBS卷旨在提供高可用性和可靠性</li>
<li>EBS卷数据在<strong><font color="red">可用区</font></strong>中的多个服务器之间复制，以防止任何单个组件发生故障而导致数据丢失</li>
<li>EBS卷的持久性取决于卷的大小以及自上次快照以来更改的数据量。快照是增量的时间点备份，仅包含自上次快照以来更改的数据块。自最近一次快照以来，使用20 GB或更少修改数据运行的EBS卷的年度故障率（AFR）可能在0.1％到0.2％之间。自最近一次快照以来具有超过20 GB修改数据的EBS卷预期有更高的故障率与修改数据的增加大致成比例。因此，建议创建快照的频度更大一些，以最大限度地提高其EBS数据的持久性和可用性</li>
<li>EBS快照提供更快的磁盘克隆或磁盘映像机制，常用于备份，共享和灾难恢复</li>
<li>EBS 快照与 Amazon Data Lifecycle Manager (DLM) 策略配合使用，以自动执行快照管理</li>
</ul>
<h2 id="可扩展性-amp-弹性"><a href="#可扩展性-amp-弹性" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>EBS卷可以通过修改卷的大小（增大）、IOPS，快速地进行配置和发布，以适应不断变化的存储需求</li>
<li>无法在线缩小卷的大小（不确定是否有更新）</li>
</ul>
<h2 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h2><ul>
<li>通过SOAP和REST格式为Amazon EBS提供管理API，可用于为<strong><font color="red">EC2实例</font></strong> reate, delete, describe, attach, and detach ，以及从<font color="red"><strong>EBS创建</strong></font>，删除和快照 到S3，将快照从一个区域复制到另一个区域</li>
<li>AWS管理控制台提供以上相同的功能</li>
</ul>
<h1 id="EFS"><a href="#EFS" class="headerlink" title="EFS"></a>EFS</h1><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ul>
<li>提供简单，可扩展的文件存储服务，以便与EC2实例一起使用</li>
<li>存储空间是弹性的，随着文件的添加和删除而自动增长和收缩</li>
<li>挂载在到EC2实例上时，提供标准文件系统接口和文件系统访问语义</li>
<li>在共享模式下工作，多个EC2实例可以同时访问EFS文件系统，EFS提供共享数据服务</li>
<li>可以在EC2实例上并发运行工作负载和应用程序</li>
<li>使用AWS Direct Connect连接到VPC时，可以在本地数据中心服务器挂载共享文件系统使用</li>
<li>可以挂载到本地服务器上，以便数据集迁移到EFS，将本地数据备份到EFS</li>
<li>专为高可用性和耐用性而设计，可为广泛的工作负载和应用程序提供性能，包括大数据和分析，媒体处理工作流，内容管理，Web服务和主目录</li>
<li>基于 Linux 的工作负载</li>
</ul>
<h2 id="使用范例-3"><a href="#使用范例-3" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>跨可用区、区域和 VPC 访问文件系统，并可以通过 AWS Direct Connect 或 AWS VPN 在数千个 Amazon EC2 实例与本地服务器之间共享文件</li>
<li>超高吞吐量的高度并行化的横向扩展工作负载到单线程的延迟敏感型工作负载，均适用。直接迁移企业应用程序、大数据分析、Web 服务和内容管理、应用程序开发和测试、媒体和娱乐工作流程、数据库备份和容器存储。<br>直接迁移企业应用程序、大数据分析、Web 服务和内容管理、应用程序开发和测试、媒体和娱乐工作流程、数据库备份和容器存储。</li>
</ul>
<h2 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h2><ul>
<li>提供标准和不经常访问存储类。标准存储类是为活动文件系统工作负载而设计的，EFS 不频繁访问 (EFS IA) 是一种成本较低的存储类，针对不经常访问的文件进行了成本优化。EFS 文件系统透明地提供来自两个存储类的数据转换。</li>
<li>所有文件系统的稳定基准性能为每 TB 标准类存储 50MB/s </li>
<li>EFS 支持一个到数千个EC2 实例同时连接一个文件系统</li>
<li>性能模式<ul>
<li>通用性能模式，非常适合对延迟敏感的使用案例，如 Web 服务环境、内容管理系统、主目录和一般文件服务。（默认）</li>
<li>最大 I/O 性能模式，扩展到更高级别的聚合吞吐量和每秒操作数，但代价是稍高的文件操作延迟。诸如大数据分析、媒体处理和基因组分析等高度并行化的应用程序和工作负载可以受益于这种模式。</li>
</ul>
</li>
<li>吞吐量模式<ul>
<li>突增吞吐量，Amazon EFS 上的吞吐量将随着标准存储类别中存储的文件系统的增大而增加，都能突增到 100 MB/秒的吞吐量</li>
<li>预置吞吐量使 Amazon EFS 客户能够预置文件系统的吞吐量（无需考虑存储的数据量），从而优化文件系统的吞吐性能，以满足应用程序的需求</li>
</ul>
</li>
</ul>
<h2 id="冗余性-amp-可用性-2"><a href="#冗余性-amp-可用性-2" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>每个文件系统对象（即目录、文件和链接）均会在多个可用区中进行冗余存储。此外，文件系统还可以从其所在区域中的各个可用区同时访问，这意味着在构建应用程序时，可以使其从区域中的一个可用区故障转移到其他可用区，从而确保应用程序的高可用性。挂载目标本身即具有高可用性。<br>可扩展性&amp;弹性</li>
<li>随文件系统增减文件的操作自动进行扩展和收缩，因此不需要进行存储的采购和预配置工作</li>
</ul>
<h2 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用标准 Linux 挂载命令和文件系统的 DNS 名称将文件系统挂载到基于 Linux 的 EC2 实例上</li>
<li>为了简化对 EFS 文件系统的访问，建议使用 EFS 挂载助手实用程序</li>
<li>EFS 使用网络文件系统版本 4 (NFS v4) 协议</li>
<li>DataSync 工具提供将现有文件系统与 Amazon EFS 安全同步，可借助VPN或DX。</li>
<li>通过 AWS 管理控制台、AWS 命令行界面 (CLI) 或 EFS API（以及各种语言的软件开发工具包）来管理文件系统。通过控制台、API 和软件开发工具包，可以创建和删除文件系统、配置文件系统的访问方式、创建和编辑文件系统标签、启用预置吞吐量和生命周期管理等功能，以及显示文件系统的详细信息。</li>
</ul>
<h1 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h1><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ul>
<li>Storage Gateway是一种将本地软硬件设备与基于云的存储相连接的服务，可在本地IT环境与AWS的存储基础架构之间提供无缝，安全的集成。</li>
<li>Storage Gateway可以将数据安全地存储到AWS云端，以实现可扩展且经济高效的数据存储。</li>
<li>在本地提供繁的数据访问并保障低延迟，同时还可通过加密将数据安全存储在S3中。</li>
<li>对于灾难恢复场景，可以作为云托管解决方案与EC2一起联动，镜像生产环境到云端。</li>
<li>Storage Gateway 可以配置为<ul>
<li>Gateway-cached volumes<ul>
<li>网关缓存卷利用S3进行主要数据备份，同时在本地保留经常访问的数据</li>
<li>最大限度地减少了扩展本地存储基础架构的需求，同时为应用程序提供对其频繁访问的数据的低延迟访问</li>
<li>写入卷的数据存储在S3中，只有最近写入和最近读取的数据的缓存本地存储在本地存储硬件上</li>
</ul>
</li>
<li>Gateway-stored volumes<ul>
<li>网关存储的卷在本地存储完整的主要数据，同时异步地将数据备份到AWS</li>
<li>这些卷为本地应用程序提供了对其整个数据集的低延迟访问，同时提供了持久的异地备份</li>
<li>写入网关存储卷的数据存储在本地存储硬件上，并以EBS快照的形式异步备份到S3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用范例-4"><a href="#使用范例-4" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>企业组织之间文件共享</li>
<li>将现有的本地备份应用程序备份到S3上的和灾难恢复场景，以及数据镜像到云端</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）-2"><a href="#Anti-Patterns（不建议模式）-2" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>数据库存储<ul>
<li>对于数据库存储或备份，使用EBS卷的EC2实例是数据库存储和工作负载的最佳选择</li>
</ul>
</li>
</ul>
<h2 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h2><ul>
<li>由于Storage Gateway VM介于应用程序，本地存储和S3之间，因此所遇到的性能将取决于诸多因素，包括本地磁盘的速度和配置，iSCSI initiator与网关之间的网络带宽，Gateway VM的数量，以及VM和S3的带宽</li>
<li>对于Gateway-cached volumes，为了提供对本地应用程序的低延迟读访问，重要的是提供足够的本地缓存存储来存储最近访问的数据</li>
<li>Storage Gateway有效地使用Internet带宽将数据上传到AWS</li>
<li>Storage Gateway仅传输增量更改（已更改的数据），从而最大限度地减少通过Internet发送的数据量</li>
<li>通过在AWS和AWS之间建立连接，AWS Direct Connect可用于进一步提高吞吐量并降低网络成本</li>
</ul>
<h2 id="冗余性-amp-可用性-3"><a href="#冗余性-amp-可用性-3" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>AWS Storage Gateway通过将数据传输到S3来确保其数据持久性</li>
<li>S3提供11个9的持久性</li>
<li>S3定期执行系统的数据完整性检查并自动完成自我修复</li>
</ul>
<h2 id="可扩展性-amp-弹性-1"><a href="#可扩展性-amp-弹性-1" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>AWS Storage Gateway将数据存储在Amazon S3中，借助S3提供高级别的可扩展性和弹性</li>
</ul>
<h2 id="接口-4"><a href="#接口-4" class="headerlink" title="接口"></a>接口</h2><ul>
<li>通过AWS管理控制台可用于下载AWS Storage Gateway VM映像，在网关缓存或网关存储配置之间进行选择，通过将网关与AWS账户相关联来激活部署，选择AWS区域，以及创建 AWS Storage Gateway卷并将这些卷作为iSCSI设备连接到本地应用程序服务器</li>
</ul>
<h1 id="Snow-Family"><a href="#Snow-Family" class="headerlink" title="Snow Family"></a>Snow Family</h1><p>Snow 系列是一系列物理设备，可帮助将大量数据传入和传出云，无需依赖网络。TB数据通过internet传输其稳定性、可靠性、费用、时间都无法和Snow设备相媲美。</p>
<h2 id="Snowball"><a href="#Snowball" class="headerlink" title="Snowball"></a>Snowball</h2><ul>
<li>是一种PB级数据传输服务，内置安全如手提箱大小的移动设备，，可快速高效地将数据移入和移出AWS云端</li>
<li>将数据导入到S3 </li>
<li>转移数据从开始到结束大约1周</li>
<li>通常用于传送（移动）TB量级数据，如分析数据、医疗保健和生命科学数据、视频库、图像存储库、备份和存档，作为数据中心停用，磁带数据替换者或大规模应用数据迁移</li>
</ul>
<h2 id="Snoaball-Edge"><a href="#Snoaball-Edge" class="headerlink" title="Snoaball Edge"></a>Snoaball Edge</h2><ul>
<li>设备具有更大的容量和嵌入计算平台，可执行简单的处理任务</li>
<li>这些设备可以安装在机架上并通过集群化一起使用，以便更轻松地在极其偏远的位置收集和存储数据</li>
<li>Storage Optimized 和 Compute Optimized类型</li>
<li>可以在时断时续的环境（例如制造业、工业和运输）中或在极其偏远的位置（例如军事或海事作业）使用这些设备，然后再将其运回 AWS</li>
<li>Snowball Edge 可使用 AWS Greengrass 和 Lambda 函数在网络边缘提供无服务器计算应用程序。</li>
<li>常见使用案例包括 IoT 传感器流捕获、动态媒体转码、图像压缩、指标聚合以及工业控制信令与警报。</li>
</ul>
<h2 id="Snowmobile"><a href="#Snowmobile" class="headerlink" title="Snowmobile"></a>Snowmobile</h2><ul>
<li>Snowmobile 是一个 45 英尺长的坚固集装箱，可迁移高达 100PB 的数据（相当于 1250 台 AWS Snowball 设备），非常适合数 PB 级或 EB 级数字媒体迁移和数据中心关闭的情况。</li>
<li>Snowmobile 在抵达客户站点后显示为网络连接数据存储，可实现更加安全的高速数据传输。将数据传输到 Snowmobile 后，Snowmobile 会被运回 AWS 区域，而数据会加载到 Amazon S3 中。</li>
<li>Snowmobile 防篡改、防水，具有温度控制，配备有多层逻辑和物理安全机制，包括加密、消防、专职安全人员、GPS 跟踪、警报监控、全天候视频监控以及运输过程中的护送安全车辆。</li>
</ul>
<h2 id="功能场景"><a href="#功能场景" class="headerlink" title="功能场景"></a>功能场景</h2><table>
<thead>
<tr>
<th>—</th>
<th>Snowball</th>
<th>SnowballEdge</th>
<th>Snowmobile</th>
</tr>
</thead>
<tbody><tr>
<td>使用情景</td>
<td>数据迁移</td>
<td>通过板载设备迁移数据预处理选项</td>
<td>数据迁移</td>
</tr>
<tr>
<td>存储容量</td>
<td>50TB 和 80TB</td>
<td>100TB</td>
<td>100PB</td>
</tr>
<tr>
<td>板载计算选项</td>
<td>不适用</td>
<td>AWS Lambda| AMI</td>
<td>不适用</td>
</tr>
<tr>
<td>加密</td>
<td>有，256 位</td>
<td>有，256 位</td>
<td>有，256 位</td>
</tr>
<tr>
<td>通过 NFS 传输</td>
<td>不适用</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>通过 HDFS 传输</td>
<td>是</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>通过 S3 API 传输</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>集群</td>
<td>不适用</td>
<td>是，最多 20 个节点</td>
<td>不适用</td>
</tr>
<tr>
<td>可安装机架</td>
<td>架子</td>
<td>是</td>
<td>不适用</td>
</tr>
<tr>
<td>符合 HIPAA 要求</td>
<td>是，符合要求</td>
<td>是，符合要求</td>
<td>否</td>
</tr>
<tr>
<td>常规作业生命周期</td>
<td>数天-数周</td>
<td>数据迁移：数天-数周本地计算：数周-数月</td>
<td>数周-数月</td>
</tr>
<tr>
<td>最长作业时间</td>
<td>90 天</td>
<td>数据迁移：90 天；本地计算：120 天</td>
<td>120-360 天</td>
</tr>
</tbody></table>
<h2 id="性能-5"><a href="#性能-5" class="headerlink" title="性能"></a>性能</h2><ul>
<li>Snowball 拥有 10Gbps 的网络接口，配有 RJ45、SFP+ 铜缆和 SFP+ 光学网络接口</li>
<li>Snowball 客户端将以条件允许的最快速度将数据复制到 Snowball（例如，不到一天就可以复制 48TB 的数据，具体取决于本地环境）</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>云迁移</li>
<li>灾难恢复</li>
<li>数据中心停用</li>
<li>内容分配（定期接收或需要与客户、消费者或业务伙伴共享大量数据）</li>
</ul>
<h2 id="可扩展性-amp-冗余性"><a href="#可扩展性-amp-冗余性" class="headerlink" title="可扩展性&amp;冗余性"></a>可扩展性&amp;冗余性</h2><ul>
<li>单个 Snowball 设备可以传输数 TB 的数据，并且可以并行使用多台设备将数 PB 的数据传入或传出 Amazon S3 存储桶；或者在设置生命周期管理策略时，单个 Snowball 设备可以自动将数据从 S3 分层到 Amazon Glacier </li>
<li>多台 Snowball Edge 设备可以充当一个可扩展存储与计算池，持久性更高</li>
<li>一台 Snowmobile 一次可以传输高达 100PB 的数据，这相当于大约 1250 台 AWS Snowball 设备传输的数据量</li>
<li>数据持久性借助S3或Glacier提供11个9的持久性。</li>
</ul>
<h2 id="接口-5"><a href="#接口-5" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用 AWS 管理控制台创建一项或多项任务，申请一台或多台 Snowball 设备（具体取决于需要传输的数据量），然后下载并安装 Snowball 客户端（简称“客户端”）。当设备抵达后，将其连接到本地网络，手动或使用 DHCP 设置 IP 地址，然后使用客户端确定要复制的目录。客户端会自动加密数据并将其复制到设备，然后在传输作业完成时通知。</li>
<li>Snowball 任务管理 API 提供对 Snowball 任务创建和管理功能的编程式访问。这是一种基于标准的简单 REST Web 服务接口，旨在与任何 Internet 开发环境配合使用。</li>
<li>S3 SDK Adapter for Snowball 可以为 Snowball 客户端提供兼容 S3 的接口，以便在 Snowball 上读取和写入数据。</li>
</ul>
<h1 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h1><blockquote>
<p><strong>注：此处的备份服务并不是通常意义的特定应用程序及其数据备份，AWS提供的备份服务都是基于以上存储服务自身提供的备份服务，和NBU、Commvault、Veeam等专用备份有着很大区别。</strong></p>
</blockquote>
<p>AWS Backup 是一种完全托管的备份服务，使用 AWS Storage Gateway 轻松地集中自动管理云中以及本地的各种 AWS 服务的数据备份工作。支持集中配置备份策略并监控<font color="orange" size="2"> EBS 卷（快照）、RDS 数据库（不含Aurora，快照）、DynamoDB 表、EFS 文件系统和 Storage Gateway 卷(快照)。</font></p>
<h2 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h2><ul>
<li>集中式备份管理</li>
<li>基于策略的备份（即通常意义上的备份计划）</li>
<li>基于标记的备份策略（AWS 资源进行标记来对其应用备份计划）</li>
<li>备份活动监控（提供dashboard 审核备份和还原备份活动）</li>
<li>支持生命周期策略，可以将备份存储转移到冷存储层中</li>
<li>支持独立于源数据的备份数据存储和加密，以及基于资源的访问策略</li>
</ul>
<h2 id="使用范例-5"><a href="#使用范例-5" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>业务和法规备份合规性要求</li>
<li>原生云备份</li>
<li>混合备份，云中和本地的应用程序数据备份，结合Storage Gateway集成</li>
</ul>
<h2 id="接口-6"><a href="#接口-6" class="headerlink" title="接口"></a>接口</h2><ul>
<li>AWS集中的备份控制台、备份 API 以及 AWS Command Line Interface (AWS CLI)，用于管理备份</li>
</ul>
<h1 id="Instance-Store-Volumes"><a href="#Instance-Store-Volumes" class="headerlink" title="Instance Store Volumes"></a>Instance Store Volumes</h1><h2 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h2><ul>
<li>实例存储卷（临时卷）提供临时块级存储，与EC2实例位于同一物理服务器上的预配置和连接的磁盘存储块组成</li>
<li>实例存储的存储量取决于实例类型，较大的实例同时提供更多和更大的实例存储卷。较小的实例类型(如微实例)只能用于卷启动。</li>
<li>存储优化实例提供针对例如特定用途的特殊用途实例存储。 如HI1提供非常快速的固态驱动器（SSD）支持的实例存储，能够支持超过120,000随机读取IOPS，针对非常高的随机I / O性能和低IOPS成本进行了优化。 同时，HS1实例针对非常高的存储密度，低存储成本和高顺序I / O性能进行了优化。</li>
<li>与EBS卷不同，实例存储卷不能分离或附加到另一个实例</li>
</ul>
<h2 id="使用范例-6"><a href="#使用范例-6" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>EC2本地实例存储卷提供快速，免费（即包含在EC2实例的价格中）“临时卷”最适合存储不断变化的临时数据，例如buffers，cache，暂存数据或者可重新生成数据，或者为了持久性而复制的数据</li>
<li>高I / O实例提供SSD支持的实例存储卷，非常适合许多高性能数据库工作负载。 如应用程序包括像Cassandra和MongoDB这样的NoSQL数据库。</li>
<li>高存储实例支持每个EC2实例更高的存储密度，非常适合在非常大的数据集中受益于高顺序I / O性能的应用程序。 例如应用程序包括数据仓库，Hadoop存储节点，地震分析，群集文件系统等。<br>Anti-Patterns（不建议模式）</li>
<li>持久性数据<ul>
<li>对于持久性虚拟磁盘存储，类似于物理磁盘驱动器，用于文件或其他必须持续时间超过EC2实例生命周期的数据， EBS卷或S3更合适。</li>
</ul>
</li>
<li>关系型数据库数据<ul>
<li>在大多数情况下，关系数据库要求存储在EC2实例的生命周期之后持续存在，这使得EBS卷成为更好的选择。</li>
</ul>
</li>
<li>共享数据存储<ul>
<li>实例存储卷专用于单个EC2实例，无法与其他系统或用户共享。如果需要可以从一个实例分离并连接到其他实例的存储，或者需要能够轻松共享数据，那么S3或EBS卷是更好的选择。</li>
</ul>
</li>
<li>快照<ul>
<li>如果要使用基于时间点磁盘快照的便利性，长期持久性，可用性和可共享性，则EBS卷是更好的选择。</li>
</ul>
</li>
</ul>
<h2 id="性能-6"><a href="#性能-6" class="headerlink" title="性能"></a>性能</h2><ul>
<li>在大多数EC2实例家族中，非基于ssd的实例存储卷具有与标准EBS卷类似的性能</li>
<li>EC2实例和本地实例存储卷位于同一物理服务器中，与存储的交互非常快，尤其是对于顺序访问</li>
<li>提高聚合IOPS或提高顺序磁盘吞吐量，可以使用RAID 0（磁盘条带化）软件将多个实例存储卷组合在一起</li>
<li>由于磁盘的带宽不受网络限制，因此多个实例卷的聚合顺序吞吐量可能高于相同容量的EBS卷</li>
<li>EC2高I / O实例中的SSD实例存储卷可提供数万至数十万随机IOPS，低延迟，4 KB</li>
<li>由于SSD设备的I/O特性，写性能在生命周期是是可变的</li>
<li>EC2高存储实例上的实例存储卷提供非常高的存储密度和高顺序读写性能。当使用块大小为2 MB时，高存储实例能够提供2.6 GB/秒的顺序读写性能</li>
</ul>
<h2 id="冗余性-amp-可用性-4"><a href="#冗余性-amp-可用性-4" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>不应用作持久磁盘存储，并且仅在关联EC2实例的生命周期内持续存在</li>
</ul>
<h2 id="可扩展性-amp-弹性-2"><a href="#可扩展性-amp-弹性-2" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>本地实例存储卷绑定到特定的EC2实例，并且对于给定的EC2实例类型，本地实例存储卷的数量和大小是固定的，因此该存储的可伸缩性和弹性绑定到EC2实例的规格限制</li>
</ul>
<h2 id="接口-7"><a href="#接口-7" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用EC2 API和AWS管理控制台的块设备映射功能指定实例存储卷</li>
<li>对于EC2实例，实例存储卷的显示方式与本地磁盘驱动器类似。写入实例存储卷并从中读取数据，请使用所选操作系统的本地文件系统I / O接口</li>
</ul>
<h1 id="Reffer"><a href="#Reffer" class="headerlink" title="Reffer"></a>Reffer</h1><ol>
<li><a href="http://jayendrapatil.com/" target="_blank" rel="noopener">http://jayendrapatil.com/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/21/AWS-Direct-Connect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/AWS-Direct-Connect/" itemprop="url">AWS Direct Connect</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T21:40:54+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Direct-Connect-Overview"><a href="#Direct-Connect-Overview" class="headerlink" title="Direct Connect Overview"></a>Direct Connect Overview</h2><ul>
<li>AWS Direct Connect是一种网络服务，它是一种替代Internet来利用AWS云服务的一种方案</li>
<li>通过标准的以太网光纤电缆将内部网络链接到 AWS Direct Connect 位置。电缆的一端接到用户侧路由器，另一端接到 AWS Direct Connect 路由器</li>
<li>可以使用1Gbps和10Gbps端口建立直接连接。可以从任何支持AWS Direct Connect的APN合作伙伴订购50Mbps，100Mbps，200Mbps，300Mbps，400Mbps和500Mbps的速度</li>
<li>有了此连接以后，可以创建直接连接到公共 AWS 服务（如 Amazon S3）或 Amazon VPC 的虚拟接口，从而绕过网络路径中的 Internet 服务提供商</li>
<li>AWS Direct Connect位置提供对与其关联的区域中的Amazon Web Services的访问，以及对其他美国区域的访问（如果是美国地区的Direct Connect）。例如，可以为美国的任何AWS Direct Connect位置配置单个连接，并使用它来访问所有美国区域和AWS GovCloud（美国）中的公共AWS服务。</li>
<li>每个AWS Direct Connect位置都可以连接到地理位置最近的AWS区域内的所有可用区</li>
<li>公有区域或AWS GovCloud (US)中的 AWS Direct Connect 位置可以访问任何其他公有区域（不包括中国(北京和宁夏)）中的公有服务</li>
</ul>
<p><img src="https://i.loli.net/2019/08/21/6VWEui91R57Yyjm.png" alt="direct_connect_overview.png"></p>
<h2 id="Direct-Connect-Advantages"><a href="#Direct-Connect-Advantages" class="headerlink" title="Direct Connect Advantages"></a>Direct Connect Advantages</h2><ul>
<li>降低带宽成本<ul>
<li>所有通过专用连接传输的数据均按AWS直接连接数据传输速率(而不是Internet数据传输速率)的，从而节省成本</li>
<li>在AWS之间传输数据直接减少了Internet服务提供商的带宽承诺</li>
</ul>
</li>
<li>一致的网络性能<ul>
<li>与互联网的网络变化（抖动、延迟）相比，Direct Connect提供专用连接和更一致的网络性能体验</li>
</ul>
</li>
<li>AWS 服务兼容性<ul>
<li>Direct Connect是一种网络服务，可与S3，EC2和VPC等所有AWS服务配合使用</li>
</ul>
</li>
<li>VPC的专用连接<ul>
<li>使用直接连接专用虚拟接口（Private virtual interface）可以在网络和VPC之间建立专用的专用高带宽网络连接</li>
</ul>
</li>
<li>弹性<ul>
<li>使用更高带宽的连接或建立多个连接，可以轻松扩展直接连接以满足需求</li>
</ul>
</li>
</ul>
<h2 id="Direct-Connect-vs-IPSec-VPN-Connections"><a href="#Direct-Connect-vs-IPSec-VPN-Connections" class="headerlink" title="Direct Connect vs IPSec VPN Connections"></a>Direct Connect vs IPSec VPN Connections</h2><ul>
<li>VPC VPN连接通过IPSec在Internet上建立内部网和Amazon VPC之间的加密网络连接</li>
<li>VPN连接可以在几分钟内进行配置，而对于需要一个具有低到适度的带宽需求，并能容忍在基于互联网连接的内在变化</li>
<li>AWS Direct Connect不涉及Internet; 相反，它使用Intranet和Amazon VPC之间的专用专用网络连接</li>
<li>与Direct Connect连接相比，VPN连接非常便宜，因为它需要实际的硬件和基础设施，可能需要数千个</li>
</ul>
<h2 id="Direct-Connect-Anatomy"><a href="#Direct-Connect-Anatomy" class="headerlink" title="Direct Connect Anatomy"></a>Direct Connect Anatomy</h2><p><img src="https://i.loli.net/2019/08/21/qgxn1o5FaWQEUVT.png" alt="screen-shot-2016-05-17-at-1-56-15-pm.png"></p>
<ul>
<li>亚马逊在不同地点维护AWS Direct Connect PoP（称为主机托管设施），这与AWS区域不同</li>
<li>AWS本身维护从AWS Direct Connect PoP到AWS区域的连接</li>
<li>消费者，既可以购买机架空间，也可以使用任何已在主机托管设施中拥有基础架构的AWS APN合作伙伴并配置客户网关</li>
<li>Direct Connect PoP与Colocation Facility内的Customer网关之间的连接称为Cross Connect</li>
<li>可以使用任何服务提供商网络建立从客户网关到客户数据中心的连接</li>
<li>使用AWS创建直接连接连接后，将收到LOA-CFA（授权书 - 连接设施分配）。</li>
<li>LOA-CFA可以切换到主机托管设施或APN合作伙伴以建立交叉连接</li>
<li>一旦建立了Cross Connect以及CGW和Customer DataCenter之间的连接，就可以创建虚拟接口</li>
<li>AWS Direct Connect需要VGW才能访问AWS VPC</li>
<li>虚拟接口<ol>
<li>每个AWS Direct Connect连接都需要一个虚拟接口</li>
<li>每个AWS Direct Connect连接都可以配置一个或多个虚拟接口。</li>
<li>可以创建公共虚拟接口（public virtual interface）以连接到例如公共资源。 SQS，S3，EC2，Glacier等只能公开到达</li>
<li>可以创建专用虚拟接口以连接到例如VPC私有IP地址的实例</li>
<li>每个虚拟接口都需要VLAN ID，接口IP地址，ASN和BGP密钥</li>
</ol>
</li>
<li>要将AWS Direct Connect连接与其他AWS账户一起使用，可以为该账户创建托管虚拟接口。 这些托管虚拟接口与标准虚拟接口的工作方式相同，可以连接到公共资源或VPC。</li>
</ul>
<h2 id="Direct-Connect-Redundancy"><a href="#Direct-Connect-Redundancy" class="headerlink" title="Direct Connect Redundancy"></a>Direct Connect Redundancy</h2><p><img src="https://i.loli.net/2019/08/21/y1cnTMYo63FADd5.png" alt="screen-shot-2016-05-17-at-1-57-22-pm.png"></p>
<ul>
<li>直接连接不提供冗余，并且有多个单点故障，因为每个连接都包含路由器端口和Amazon路由器之间的单个专用连接</li>
<li>冗余连接<ol>
<li>建立第二个DX，最好使用不同的路由器和AWS Direct Connect PoP在不同的主机托管设施中建立连接</li>
<li>客户DC与VGW之间的IPsec VPN连接</li>
</ol>
</li>
<li>对于在同一AWS Direct Connect位置中请求的多个端口，Amazon本身确保在冗余Amazon路由器上配置它们以防止硬件故障的影响</li>
</ul>
<h2 id="Direct-Connect-LAG"><a href="#Direct-Connect-LAG" class="headerlink" title="Direct Connect LAG"></a>Direct Connect LAG</h2><ul>
<li>链接聚合组 (LAG) 是一个逻辑接口，使用链接聚合控制协议 (LACP) 在一个 AWS Direct Connect 终端节点处聚合多个连接，从而允许将这些连接视为一个托管连接</li>
<li>可从现有连接创建 LAG，也可配置新连接</li>
<li>在创建 LAG 之后，可将现有连接 (无论是独立连接还是其他 LAG 的一部分) 与 LAG 关联</li>
<li>LAG遵循以下规则<ol>
<li>LAG 中的所有连接都必须使用相同的带宽</li>
<li>LAG 中最多可有 4 个连接。LAG 中的每个连接都会计入区域的整体连接限制</li>
<li>LAG 中的所有连接都必须终止于同一 AWS Direct Connect 终端节点</li>
</ol>
</li>
</ul>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul>
<li>AWS Direct Connect user guide</li>
<li><a href="http://jayendrapatil.com/aws-direct-connect-dx" target="_blank" rel="noopener">http://jayendrapatil.com/aws-direct-connect-dx</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/20/AWS-High-Availability-Fault-Tolerance-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/AWS-High-Availability-Fault-Tolerance-Architecture/" itemprop="url">AWS High Availability & Fault Tolerance Architecture</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T17:30:32+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>前言：AWS提供众多服务和基础架构能力，以在云中构建可靠，容错且高度可用的系统。一下为AWS的定义范围和解释</li>
</ul>
<ul>
<li>Fault Tolerance定义了构建系统的某些组件发生故障时，系统仍能保持运行的能力</li>
<li>大多数高级服务（如S3，RDS，SQS和ELB）都考虑了容错和高可用性（<font size="3" color="orange">自设计冗余性和高可用</font>）</li>
<li>提供基本基础架构（如EC2和EBS）的服务提供特定功能，例如可用区，弹性IP地址和快照，系统需要正确利用和使用这些功能才能达到容错和高可用性（<strong><font color="red">需要借助AWS基础架构实现高可用性和容错性</font></strong>）</li>
</ul>
<p><img src="https://i.loli.net/2019/08/20/UKcMhzL8VOBtHmD.png" alt="AWS-High-Availability-and-Fault-Tolerance.png"></p>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h3><ul>
<li>高可用性是指提供在本地系统单个组件故障情况下，能继续访问应用的能力，无论这个故障是业务流程、物理设施、IT软/硬件的故障。</li>
<li>主要用于确保关键系统始终正常运行，如核心业务系统、数据库场景。</li>
<li>（RPO=0，共享存储的情况下，RTO分钟级）</li>
<li>一般使用通过运行时间百分比表示其可用性，5 个9：99.999%年可用率，意味着每年停机时间在一到两分钟</li>
</ul>
<h3 id="FT"><a href="#FT" class="headerlink" title="FT"></a>FT</h3><ul>
<li>设计方式时当一个组件发生故障（无论是硬件还是软件）时，备份组件立即接管操作，从而不会丢失服务</li>
<li>容错是高可用性的更严格版本。 HA专注于提供尽可能少的停机时间，而FT则通过实现零停机而进一步提升， 但是，在容错模型中，系统在发生故障时提供高性能的能力不是首要任务，相反，预计系统可以保持运行性能，甚至降低水平</li>
<li>（ 设计目标RTO =0 &amp;&amp; RPO = 0）</li>
</ul>
<h3 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h3><ul>
<li><p>灾难恢复涉及<font color="red">一系列政策，工具和程序</font>，以便在自然灾害或人为灾难之后恢复或延续重要技术基础设施和系统。</p>
</li>
<li><p>DR需要具有异地设施，可以在其中恢复关键数据和工作负载（无论是完全还是部分），以便在发生破坏性事件后恢复足够的业务运营。要将工作负载转移到远程位置，必须采用适当的灾难恢复解决方案</p>
</li>
<li><p>灾难恢复是一个更广泛，更复杂的概念，它指的是一套具有全面组件的战略，包括：风险评估，规划，依赖关系分析，远程站点配置，员工培训，测试，自动化设置等等。灾难恢复超越了<font color="red">HA和FT</font>，但可以而且应该将这些因素包括在其技术设计中。</p>
</li>
<li><p>由于DR场景已经跨单数据中心，基本上RPO可小时级，RTO小时级到天级别</p>
</li>
<li><p>相比HA、FT，DR强调发生灾难后处理，而不是应急或预防，而是减弱灾难带来的影响。DR处理的不是单个组件的故障情况，而是DC级别的故障，应对人力不可控的风险。</p>
</li>
<li><p>在场景上一般都是有着严格行业监管要求的，如金融、医疗等</p>
</li>
<li><p>容灾通常意义上分为<font color="red"><strong>三个级别（数据、应用、业务</strong></font>，国际上专业划分为7个层次）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>级别</th>
<th>定义</th>
<th>RTO</th>
<th>RTO</th>
</tr>
</thead>
<tbody><tr>
<td>数据级</td>
<td>指通过建立异地容灾中心，做数据的远程备份，在灾难发生之后要确保原有的数据不会丢失或者遭到破坏。但在数据级容灾这个级别，发生灾难时应用是会中断的。在数据级容灾方式下，所建立的异地容灾中心可以简单地把它理解成一个远程的数据备份中心。数据级容灾的恢复时间比较长，但是相比其他容灾级别来讲它的费用比较低，而且构建实施也相对简单。但是，“数据源是一切关键性业务系统的生命源泉”，因此数据级容灾必不可少。</td>
<td>RTO 最长(若干天) ，因为灾难发生时，需要重新部署机器，利用备份数据恢复业务。</td>
<td>最低</td>
</tr>
<tr>
<td>应用级</td>
<td>在数据级容灾的基础之上，在备份站点同样构建一套相同的应用系统，通过同步或异步复制技术，这样可以保证关键应用在允许的时间范围内恢复运行，尽可能减少灾难带来的损失，让用户基本感受不到灾难的发生，这样就使系统所提供的服务是完整的、可靠的和安全的。</td>
<td>RTO 中等（若干小时）</td>
<td>中等。异地可以搭建一样的系统，或者小些的系统。</td>
</tr>
<tr>
<td>业务级</td>
<td>全业务的灾备，除了必要的 IT 相关技术，还要求具备全部的基础设施。其大部分内容是非IT系统（如电话、办公地点等），当大灾难发生后，原有的办公场所都会受到破坏，除了数据和应用的恢复，更需要一个备份的工作场所能够正常的开展业务。</td>
<td>RTO 最小（若干分钟或者秒）</td>
<td>最高</td>
</tr>
</tbody></table>
<ul>
<li><strong>RTO （Recovery Time Objective）和 RPO（Recovery Point Objective）</strong></li>
</ul>
<p><img src="https://i.loli.net/2019/08/20/o7k6O5vtfeIEcUP.png" alt="002.png"></p>
<h3 id="HA与DR关系"><a href="#HA与DR关系" class="headerlink" title="HA与DR关系"></a>HA与DR关系</h3><h4 id="两者相互关联，互相补充，互有交叉，同时又有显著的区别："><a href="#两者相互关联，互相补充，互有交叉，同时又有显著的区别：" class="headerlink" title="两者相互关联，互相补充，互有交叉，同时又有显著的区别："></a>两者相互关联，互相补充，互有交叉，同时又有显著的区别：</h4><ul>
<li>HA 往往指本地的高可用系统，表示在多个服务器运行一个或多种应用的情况下，应确保任意服务器出现任何故障时，其运行的应用不能中断，应用程序和系统应能迅速切换到其它服务器上运行，即本地系统集群和热备份。HA 往往是用共享存储，因此往往不会有数据丢失（RPO = 0），更多的是切换时间长度考虑即 RTO。</li>
<li>DR 是指异地（同城或者异地）的高可用系统，表示在灾害发生时，数据、应用以及业务的恢复能力。异地灾备的数据灾备部分是使用数据复制，根据使用的不同数据复制技术（同步、异步、Strectched Cluster 等），数据往往有损失导致 RPO &gt;0；而异地的应用切换往往需要更长的时间，这样 RT0 &gt;0。 因此，需要结合特定的业务需求，来定制所需要的 RTO 和 RPO，以实现最优的 CTO。</li>
</ul>
<h4 id="也可以从别的角度上看待两者的区别："><a href="#也可以从别的角度上看待两者的区别：" class="headerlink" title="也可以从别的角度上看待两者的区别："></a>也可以从别的角度上看待两者的区别：</h4><ul>
<li>从故障角度，HA 主要处理单组件的故障导致负载在集群内的服务器之间的切换，DR 则是应对大规模的故障导致负载在数据中心之间做切换。</li>
<li>从网络角度，LAN 尺度的任务是 HA 的范畴，WAN 尺度的任务是 DR 的范围。</li>
<li>从云的角度看，HA 是一个云环境内保障业务持续性的机制，DR 是多个云环境间保障业务持续性的机制。</li>
<li>从目标角度，HA 主要是保证业务高可用，DR 是保证数据可靠的基础上的业务可用<br>当前的国内IT对于这两个技术术语有着太多差异化的理解。从个人角度来讲<font color="red" size="5"><strong>容灾更强调业务级，而HA更强调数据的高可用，独立应用的可用性。</strong></font></li>
</ul>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://i.loli.net/2019/08/20/eBGgKt6F527nRLf.jpg" alt="HA&amp;DR (2).jpeg"></p>
<h2 id="Regions-amp-Availability-Zones"><a href="#Regions-amp-Availability-Zones" class="headerlink" title="Regions &amp; Availability Zones"></a>Regions &amp; Availability Zones</h2><ul>
<li>AWS提供多Region基础架构，并且在一个内具有多个可用区域（AZs），t提供更简易的可以轻松访问冗余部署位置。</li>
<li>AZ分布在不同的地理位置，其设计与其他AZ物理故障隔离</li>
<li>区域和AZ在地理上分布应用程序并帮助构建多站点解决方案来帮助实现更高的容错能力</li>
<li>AZ之间提供低成本，低延迟的网络连接</li>
<li>将EC2实例放置在多个AZ中，可以保护应用程序免于在单个数据中心发生故障</li>
<li>在同一区域或另一个区域中的多个AZ中运行独立的应用程序堆栈非常重要，这样，如果一个区域出现故障，另一个区域中的应用程序可以继续运行</li>
</ul>
<h2 id="Amazon-Machine-Image-–-AMIs"><a href="#Amazon-Machine-Image-–-AMIs" class="headerlink" title="Amazon Machine Image – AMIs"></a>Amazon Machine Image – AMIs</h2><ul>
<li>EC2是AWS中提供计算资源的服务</li>
<li>Amazon机器映像（AMI）提供了可用于定义服务实例的模板</li>
<li>模板包含软件配置（OS，应用服务和应用程序）并通过实例类型提供服务</li>
<li>AMI可以包含所有软件、应用程序和内置代码，也可以配置为具有启动时安装的引导脚本</li>
<li>单一的AMI可用于创建不同的实例类型的服务器，用于创建新实例或更换故障实例</li>
</ul>
<h2 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h2><ul>
<li>Auto Scaling可根据自定义的规则自动扩展或缩小EC2</li>
<li>AS除了在响应增大时，增加多个实例; 当不再需要这些实例时，它们将自动终止</li>
<li>AS可以根据需要终止服务器实例，他们将自动启动替换实例</li>
<li>AS可以在AWS Region范围内跨AZ部署</li>
</ul>
<h2 id="Elastic-Load-Balancing-–-ELB"><a href="#Elastic-Load-Balancing-–-ELB" class="headerlink" title="Elastic Load Balancing – ELB"></a>Elastic Load Balancing – ELB</h2><ul>
<li>ELB 在单个可用区或多个可用区内的多个目标（Amazon EC2 实例、容器和 IP 地址）之间自动分配流量</li>
<li>随着创建ELB，会产生一个DNS域名，发送到这个域名的任何请求都会被转发到后端处理实例上</li>
<li>ELB支持主机上的运行状况检查，在跨多个可用区域的EC2实例的流量分配，根据健康状态检查动态添加和删除EC2主机</li>
<li>ELB 可以检测无法正常运行的目标、停止向它们发送流量，然后将负载分散到剩余的正常运行的目标上，直至使用AS组无缝地恢复不健康的实例</li>
<li>AS和ELB是一个理想的组合——ELB为请求提供对外DNS访问域名，ELB自动确保始终有正确数量的健康EC2实例来接受请求处理</li>
<li>ELB可用于在一个区域的多个AZs中的多个实例之间进行平衡（<font color="red">跨AZ多实例</font>）</li>
</ul>
<h2 id="Elastic-IPs-–-EIP"><a href="#Elastic-IPs-–-EIP" class="headerlink" title="Elastic IPs – EIP"></a>Elastic IPs – EIP</h2><ul>
<li>弹性IP地址是公共静态IP地址，仅在所属区域内的实现地址于实例之间映射</li>
<li>EIP与AWS账户绑定，而不是与实例关联</li>
<li>弹性IP地址可用于固定终端服务的需求，例如，主数据库，文件服务器和EC2托管负载平衡器</li>
<li>可以通过快速将地址重新映射到另一个正在运行的实例或刚刚启动的替换实例，弹性IP地址可用于解决主机或可用区故障（EIP与实例解耦）</li>
</ul>
<h2 id="Reserved-Instance"><a href="#Reserved-Instance" class="headerlink" title="Reserved Instance"></a>Reserved Instance</h2><ul>
<li>预留实例有助于保留并保证计算始终以较低的成本提供</li>
</ul>
<h2 id="Elastic-Block-Store-–-EBS"><a href="#Elastic-Block-Store-–-EBS" class="headerlink" title="Elastic Block Store – EBS"></a>Elastic Block Store – EBS</h2><ul>
<li>弹性块存储（EBS）提供持久的实例存储卷，这些存储卷独立于实例的生命周期而存在，并且比实例存储大多个数量级</li>
<li>EBS卷以冗余方式存储数据，并在单个可用区内自动复制</li>
<li>在故障转移场景，如果EC2实例发生故障并需要更换，则EBS卷可以附加到新的EC2实例</li>
<li>有价值的数据不应该对实例（临时）存储上当没有没有适当的备份，复制或重新创建数据的能力的时候</li>
</ul>
<h2 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h2><ul>
<li>EBS卷是高度可靠的，为了进一步减轻故障的可能性并提高数据可靠性性，基于时间点的快照可以存储在S3中，然后将其复制到多个AZ</li>
<li>快照可用于创建新的EBS卷，这些卷是快照时原始卷的精确副本</li>
<li>快照提供了一种有效的方法来处理磁盘故障、主机、AZ的故障问题</li>
<li>快照是增量备份，仅备份自上一个快照以来的更改，因此建议保留最近的快照</li>
<li><font color="red">快照属于region范围内，而EBS卷属于AZ范围内</font></li>
</ul>
<h2 id="Relational-Database-Service-–-RDS"><a href="#Relational-Database-Service-–-RDS" class="headerlink" title="Relational Database Service – RDS"></a>Relational Database Service – RDS</h2><ul>
<li>RDS是在云上交付的一种数据库服务，并使数据库服务使用变得更加简单</li>
<li>RDS Multi-AZ部署，在不同的AZ提供数据库的同步备用副本，提高数据库的可用性，并保护数据库不受意外停机的影响</li>
<li>在出现故障转移的情况下，备用服务器被无缝地提升为主服务器，并将处理数据库操作</li>
<li>默认情况下，数据库启用的自动备份为数据库实例提供时间点恢复</li>
<li>RDS将备份数据库和事务日志，并将其存储在用户指定的保留期内</li>
<li>除自动备份外，还可以执行手动RDS备份，这些备份在明确删除之前一直保留</li>
<li>备份有助于从更高级别的故障中恢复，例如无意中的数据修改，无论是操作员错误还是应用程序中的错误</li>
<li>RDS只读副本提供数据库的只读副本，并提供扩展超出单个数据库部署容量的能力，用于读取大量数据库工作负载（<font color="red">注意数据库引擎，不是所有RDS支持</font>）</li>
<li>RDS只读副本是一种可扩展性而非高可用性解决方案</li>
</ul>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><ul>
<li>S3提供高度持久，容错和冗余的对象存储</li>
<li>跨S3区域中的多个设施在多个设备上冗余地存储对象</li>
<li>S3是作为一个非常理想的存储解决方案，适用于静态或缓慢变化的对象，例如图像，视频和其他静态媒体</li>
<li>S3结合Amazon CloudFront服务交互来支持静态内容缓存加速和流式数据加速传输</li>
</ul>
<h2 id="Simple-Queue-Service-–-SQS"><a href="#Simple-Queue-Service-–-SQS" class="headerlink" title="Simple Queue Service – SQS"></a>Simple Queue Service – SQS</h2><ul>
<li>简单队列服务（SQS）是一种高度可靠的分布式消息传递系统，作为容错应用程序的主干环节</li>
<li>SQS旨在提供所有消息的“至少一次”传送</li>
<li>消息被保证发送到队列被保留长达四天（默认，并且可以扩展高达14天）或直到它们被应用程序读出并删除</li>
<li>消息可由多个worker轮询并进行处理，而SQS使用称为可见性超时的可配置时间间隔，一次只由一个worker处理请求</li>
<li>如果队列中的消息数量开始增加，或者处理消息的平均时间变得过高，则可以通过添加额外的EC2实例来向上扩展worker</li>
</ul>
<h2 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h2><ul>
<li>Route 53是一种高度可用且可扩展的域名解析 服务</li>
<li>域名的查询自动路由到最近的DNS服务器，从而提供最佳的性能作了解答</li>
<li>Route 53支持将域名请求（例如，<a href="http://www.example.com）解析为Elastic" target="_blank" rel="noopener">www.example.com）解析为Elastic</a> Load Balancer地址以及域名root记录（example.com）</li>
</ul>
<h2 id="Cloud-Front"><a href="#Cloud-Front" class="headerlink" title="Cloud Front"></a>Cloud Front</h2><ul>
<li>CloudFront可用于使用全球边缘位置网络提供网站加速访问，包括动态，静态和流媒体内容</li>
<li>对内容的请求会自动路由到最近的边缘位置，以最佳性能体验</li>
<li>CloudFront可以与其他AWS（如S3和EC2）配合使用以获得的最好的体验</li>
<li>CloudFront还可以与任何非AWS原始服务器无缝协作，该服务器存储文件的源目标</li>
</ul>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol>
<li><a href="https://www.cnblogs.com/sammyliu/p/4741967.html" target="_blank" rel="noopener">https://www.cnblogs.com/sammyliu/p/4741967.html</a></li>
<li><a href="http://jayendrapatil.com/aws-high-availability-fault-tolerance-architecture-certification/" target="_blank" rel="noopener">http://jayendrapatil.com/aws-high-availability-fault-tolerance-architecture-certification/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/19/AWS-Disaster-Recovery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/AWS-Disaster-Recovery/" itemprop="url">AWS Disaster Recovery</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T21:08:22+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>前言：HA目标保障应用的连续运行（7\</em>24），备份确保数据的安全性，DR确保在距离上主站点故障而其应用、数据都还能够使用.</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><ul>
<li>AWS灾难恢复白皮书重点介绍了可用于灾难恢复流程的AWS服务和功能，以显著降低企业或组织的影响，包括数据、系统和业务运营方面。</li>
<li>概述实现灾难恢复的最佳实践，从最小投资到全面可用性以及容错机制，描述了如何使用AWS服务来降低成本并确保灾难事件后业务连续性的实践</li>
<li>灾备（Disaster Recovery）包括灾备方案和环境准备，以及从灾难中恢复两部分。任何对企业的业务持续性或财务有负面影响的事件都可成为灾难。AWS最佳实践之一就是始终故障设计系统的构建。</li>
<li>灾难包括硬件或软件故障、断网、断电、火灾、水灾、人为错误等等。为了减少灾难带来的损失，企业往往会投入时间和金钱来计划和准备、训练员工、定义和更新流程。为DR 计划而做的投资往往有很大不同。灾难恢复往往有两个指标：</li>
</ul>
<p>RTO - Recovery time objective：从灾难发生到恢复到满足计划SLA服务的时间<br>RPO - Reovery point objective：允许丢失的数据的时间长度<br><img src="https://i.loli.net/2019/08/19/EXpeLb4d6JwfrgO.jpg" alt="001.jpg"></p>
<ul>
<li>常见故障位置</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>硬件故障</td>
<td>系统中任何硬件组件的故障，包括主机，存储，网络或其他等。</td>
</tr>
<tr>
<td>部署失败</td>
<td>由于软件，硬件，网络或配置部署而直接导致的故障。 包括自动和手动更改。</td>
</tr>
<tr>
<td>负载因素</td>
<td>负载相关的故障可以是一个行为触发、特定进程或负载聚合加重，或者服务达到临界点。 而网络尤其可能发生负载故障。</td>
</tr>
<tr>
<td>数据因素</td>
<td>系统接受了无法处理的操作（毒丸）</td>
</tr>
<tr>
<td>凭证过期</td>
<td>证书或凭证到期导致的系统无法继续运行</td>
</tr>
<tr>
<td>依赖关系</td>
<td>相关依赖的服务故障</td>
</tr>
<tr>
<td>基础设施</td>
<td>电力或环境因素导致的硬件故障风险</td>
</tr>
<tr>
<td>资源耗尽</td>
<td>超出可用容量，达到限制条件，ID耗尽，提供的资源不再可用</td>
</tr>
</tbody></table>
<ul>
<li>常见应用应用程序设计目标和可用性</li>
</ul>
<table>
<thead>
<tr>
<th>可用性</th>
<th>最大停机时间（年）</th>
<th>应用类别</th>
</tr>
</thead>
<tbody><tr>
<td>99%</td>
<td>3天15小时</td>
<td>Batch processing, data extraction, transfer, and load jobs</td>
</tr>
<tr>
<td>99.90%</td>
<td>8小时45分钟</td>
<td>Internal tools like knowledge management, project tracking</td>
</tr>
<tr>
<td>99.95%</td>
<td>4小时22分钟</td>
<td>Online commerce, point of sale</td>
</tr>
<tr>
<td><font color="orange">99.99% </font></td>
<td><font color="orange"> 52分钟 </font></td>
<td><font color="orange">Video delivery, broadcast systems    </font></td>
</tr>
<tr>
<td><font color="orange">99.999% </font></td>
<td><font color="orange">5分钟  </font></td>
<td><font color="orange"> ATM transactions, telecommunications systems </font></td>
</tr>
</tbody></table>
<p><font face="黑体" size="5" color="red">针对最后两个AWS建议多Region部署</font></p>
<h2 id="Region级别服务"><a href="#Region级别服务" class="headerlink" title="Region级别服务"></a>Region级别服务</h2><ul>
<li><p>默认S3 DynamoDB EFS SQS Kinesis 提供区域内可靠性保障（无单点）</p>
</li>
<li><p>RDS ElasticCache ElasticSearch 需要配置多可用区部署实现可靠性保障<br><img src="https://i.loli.net/2019/08/19/IOTGYH4Q9EFVcLB.jpg" alt="002.jpg"></p>
</li>
<li><p><strong>AWS服务设计可用性目标</strong>（具体可相见文末《Reliability Pillar》，白皮书包含了非常详细的每一个服务的设计可用性）</p>
</li>
<li><p>基本上来讲，每一个服务都包含控制平面和数据平面，每一个纬度可用性不一样</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>服务</strong></th>
<th align="center"><strong>组件</strong></th>
<th align="center"><strong>可用性</strong></th>
<th align="center"><strong>多可用区可用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">EC2</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">单AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">多AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9990%</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">数据平面（卷可用性）</td>
<td align="center">99.999%</td>
<td align="center">100.0000%</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">单AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">多AZ数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">Route 53</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">Route 53</td>
<td align="center">数据平面(查询结果)</td>
<td align="center">100.000%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">服务（标准）</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">Auto Scaling</td>
<td align="center">控制平面</td>
<td align="center">99.900%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">Auto Scaling</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">EFS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EFS</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">控制平面</td>
<td align="center">99.900%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">数据平面</td>
<td align="center">99.995%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">Lambda</td>
<td align="center">函数调用</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">ELB</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">ELB</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">KMS</td>
<td align="center">控制平面</td>
<td align="center">99.990%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">KMS</td>
<td align="center">数据平面（卷可用性）</td>
<td align="center">99.995%</td>
<td align="center">N/A</td>
</tr>
</tbody></table>
<h1 id="实现DR的AWS关键服务"><a href="#实现DR的AWS关键服务" class="headerlink" title="实现DR的AWS关键服务"></a>实现DR的AWS关键服务</h1><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><ul>
<li>AWS服务在全球多个地区都可以使用，并DR站点位置可以适当地选择与主站点位置不同的区域</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><ul>
<li>11个9的持久性设计的存储架构，专为关键任务和主要数据存储设计</li>
<li>对象数据冗余的存储区域内多个设施多个设备上</li>
</ul>
<h4 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h4><ul>
<li>为数据存档和备份提供极具性价比的存储系统</li>
<li>针对不频繁访问模型进行优化，通常减速时间在3～5小时即可完成</li>
</ul>
<h4 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h4><ul>
<li>提供基于时间点的快照功能</li>
<li>快照卷可以用于创建新卷并附加到运行的实例上</li>
</ul>
<h4 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h4><ul>
<li>提供本地环境与AWS存储系统之间无缝和高度安全的集成服务</li>
</ul>
<h4 id="Snow-Family"><a href="#Snow-Family" class="headerlink" title="Snow Family"></a>Snow Family</h4><ul>
<li>使用便携式存储设备绕过Internet进行传输，加速大量数据移入和移出AWS</li>
<li>通过设高速内部网络将数据直接在设备与存储服务之间传输<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3></li>
</ul>
<h4 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h4><ul>
<li>在云中提供可调整大小的实例，轻松实现创建和扩展</li>
<li>实例使用预配置的AMI模板</li>
<li>EC2可以在多个AZ中启动，实现AZ级别的故障隔离<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3></li>
</ul>
<h4 id="Route53"><a href="#Route53" class="headerlink" title="Route53"></a>Route53</h4><ul>
<li>高度可用且可扩展的域名解析服务</li>
<li>支持全局负载均衡功能，这在处理灾难场景时非常有效。在多站点进行故障转移的时候，站点健康检查非常有用</li>
</ul>
<h4 id="Elastic-IP"><a href="#Elastic-IP" class="headerlink" title="Elastic IP"></a>Elastic IP</h4><ul>
<li>在实例或AZ故障的情况下，IP地址可以被重新映射到健康实例上</li>
<li>EIP专为云计算动态资源设计</li>
</ul>
<h4 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h4><ul>
<li>运行运行状况检查并自动在多个目标（如EC2实例）之间分配的应用程序流量</li>
</ul>
<h4 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h4><ul>
<li>允许配置AWS云的私有隔离部分，以便在定义的虚拟网络中启动资源</li>
</ul>
<h4 id="Direct-Connect"><a href="#Direct-Connect" class="headerlink" title="Direct Connect"></a>Direct Connect</h4><ul>
<li>设置从本地环境到AWS的专用网络连接</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>RDS，DynamoDb，Redshift提供完全托管的RDBMS，NoSQL和数据仓库解决方案，可轻松扩展</li>
<li>DynamoDB提供跨区域复制</li>
<li>RDS提供多可用区部署和只读副本，还能够将数据从一个区域快照到另一个区域</li>
</ul>
<h3 id="部署编排"><a href="#部署编排" class="headerlink" title="部署编排"></a>部署编排</h3><h4 id="CloudFormation"><a href="#CloudFormation" class="headerlink" title="CloudFormation"></a>CloudFormation</h4><ul>
<li>为开发人员和系统管理员提供了一种简单的方法来创建相关AWS资源的集合，并以有序和可预测的方式进行配置（DIY）</li>
</ul>
<h4 id="Elastice-Beanstalk"><a href="#Elastice-Beanstalk" class="headerlink" title="Elastice Beanstalk"></a>Elastice Beanstalk</h4><ul>
<li>是一种易于使用的服务，用于部署和扩展Web应用程序和服务</li>
</ul>
<h4 id="OpsWorks"><a href="#OpsWorks" class="headerlink" title="OpsWorks"></a>OpsWorks</h4><ul>
<li>完全托管的配置管理服务，基础设施和应用程序管理的自动化工具</li>
<li>应用程序塑造成一个包含不同层级 (例如负载均衡层、数据库层和应用程序服务器层) 的堆栈</li>
<li>具实例发生故障时，它将自动替换实例</li>
<li>可用于准备阶段以模拟环境，并在恢复阶段与AWS CloudFormation配合使用</li>
<li>可以依托预配置的堆栈快速的恢复预设环境（达到预设RTO）</li>
</ul>
<h1 id="四种场景"><a href="#四种场景" class="headerlink" title="四种场景"></a>四种场景</h1><p>从“备份和还原”选项（左侧）移至“多站点”选项（右侧）时，RTO和RPO会随着成本的增加而降低<br><img src="https://i.loli.net/2019/08/19/Kqtkb1VrwO5ISAh.png" alt="003.png"></p>
<h2 id="Backup-amp-Restore"><a href="#Backup-amp-Restore" class="headerlink" title="Backup &amp; Restore"></a>Backup &amp; Restore</h2><ul>
<li>备份恢复是最常见的一种容灾手段，将主站点数据备份到与主站点隔离的存储设备。当生产环境故障后，能够在备站点将数据恢复。<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a><strong>备份</strong></h3><img src="https://i.loli.net/2019/08/19/lzv5RpfmHdFo16h.jpg" alt="005.jpg"></li>
</ul>
<p><img src="https://i.loli.net/2019/08/19/S2Wusy9fhACOVko.jpg" alt="006.jpg"></p>
<ul>
<li>在大多数传统环境中，数据备份到磁带并定期发送到异地，需要花费更长时间在中断或灾难时恢复系统</li>
</ul>
<ol>
<li>S3可以在任何位置上进行数据备份和快速恢复</li>
<li>Snow Family系列设备可以直接绕过Internet进行大规模数据的传输</li>
<li>Glacier可用于存档场景，几个小时即可取回数据</li>
<li>Storage Gateway支持将本地数据卷（EBS卷）透明的复制到云上S3中进行备份。既可以作为备份解决方案的网关，也可作为主数据存储（缓存卷）</li>
<li>Direct Connect用于构建高速稳定一致的链路层（本地环境到云上）</li>
<li>EBS卷、RDS、Redshift的快照都可以存储到S3中</li>
</ol>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a><strong>恢复</strong></h3><p><img src="https://i.loli.net/2019/08/19/HYOyPK4SIceX2kb.jpg" alt="007.jpg"></p>
<ul>
<li>备份数据可以快速恢复和创建EC2、数据库实例的运行环境</li>
<li>几个关键步骤<ol>
<li>选择适当的工具或方法将数据备份到AWS</li>
<li>确保对此数据采用适当的保留策略</li>
<li>确保为此数据采取适当的安全措施，包括加密和访问策略</li>
<li>定期测试此数据的恢复和系统的恢复</li>
</ol>
</li>
</ul>
<h2 id="Pilot-Light"><a href="#Pilot-Light" class="headerlink" title="Pilot Light"></a>Pilot Light</h2><p>   Pilot Light 则在AWS上创建最小运行环境，它包含业务系统中最核心部分，比如数据库。这会节省恢复时间，因为系统中最核心部分已经在运行，而且数据是最新的了。而不经常更新部分，比如操作系统和应用，则可以定期打包到AMI中</p>
<ul>
<li>通过在AWS中维持配置和运行最小或关键系统，如数据库应用（保持数据库的复制和更新）</li>
<li>在恢复过程中，一个完整的生产环境，包括应用程序、Web服务等，可以围绕这个核心系统快速配置（预配置AMI模板和EBS快照）；</li>
<li>网络层面，可以使用ELB实现流量分配，并将DNS指向ELB，也可以使用预先分配的EIP与相关实例绑定</li>
</ul>
<h3 id="Pilotlight-prep"><a href="#Pilotlight-prep" class="headerlink" title="Pilotlight-prep"></a>Pilotlight-prep</h3><p><img src="https://i.loli.net/2019/08/19/xdZmK2tVSb9plRD.jpg" alt="008.jpg"></p>
<ol>
<li>建立EC2实例或RDS实例复制或镜像关系，保持关键数据两边一致</li>
<li>确保所有的软件在AWS环境中都可用</li>
<li>建立和维护在故障恢复时的关键服务的AMI（将操作系统和应用，则可以定期打包到AMI）</li>
<li>定期运行这些服务并测试，及时更新配置、软件更新</li>
<li>建议优先考虑自动化配置AWS服务</li>
</ol>
<h3 id="Pilot-light-recovery"><a href="#Pilot-light-recovery" class="headerlink" title="Pilot light-recovery"></a>Pilot light-recovery</h3><p><img src="https://i.loli.net/2019/08/19/C18ZsEtOWjmNDSq.jpg" alt="009.jpg"></p>
<ol>
<li>启动AMI创建EC2实例</li>
<li>视情况调整数据库实例大小/存储实例大小，以应对可能增大的流量，如RDS支持scale up，而EC2也可轻松实现水平扩展</li>
<li>建议在DR站点开启RDS 多可用区部署，以增强站点数据层的健壮性</li>
<li>更改DNS域名解析到新的EC2服务器</li>
<li>安装和配置任何非基于AMI的系统，最好使用自动化方式（避免手工错误）</li>
</ol>
<h2 id="Warm-Standby"><a href="#Warm-Standby" class="headerlink" title="Warm Standby"></a>Warm Standby</h2><ul>
<li>在温备场景下，一个小规模的完整业务环境会运行在AWS中</li>
<li>还能用于非生产环境，比如测试和内部使用</li>
<li>在灾难的情况下，系统可以轻松地按比例放大或缩小处理生产负载</li>
</ul>
<h3 id="Warm-standby—prep"><a href="#Warm-standby—prep" class="headerlink" title="Warm standby—prep"></a>Warm standby—prep</h3><p><img src="https://i.loli.net/2019/08/19/VfY2FtMjGD65a89.jpg" alt="010.jpg"></p>
<ol>
<li>建立实例级别的复制或镜像关系</li>
<li>创建和维护AMI以加快部署速度</li>
<li>使用最小配置环境运行服务</li>
<li>根据需要及时更新软件、补丁和配置文件，保持与主站点一致</li>
</ol>
<h3 id="Warm-standby—recover"><a href="#Warm-standby—recover" class="headerlink" title="Warm standby—recover"></a>Warm standby—recover</h3><p><img src="https://i.loli.net/2019/08/19/UYPvqVmub3FwCnj.jpg" alt="011.jpg"></p>
<ol>
<li>增加EC2数量（横向扩展）（扩成与主站点一致）</li>
<li>根据需要增大EC2配置（纵向扩展）使其启动应用程序</li>
<li>手动更改DNS记录，或使用Route 53自动运行状况检查将所有流量路由到AWS环境</li>
<li>增大或扩展数据库以防止DR发生故障</li>
<li>考虑使用AutoScaling组以调整适应负载的变化</li>
</ol>
<h2 id="Multi-Site"><a href="#Multi-Site" class="headerlink" title="Multi Site"></a>Multi Site</h2><ul>
<li>Multi Site 指的是 active-active 的架构，在两个站点上提供同样的基础架构</li>
<li>主备站点同时对外提供服务，由DNS根据加权路由决定将请求转发到相应站点</li>
<li>在故障的情况下，通过DNS解析可以将流量转发到健康站点，并同时扩展其架构以使用负载增大</li>
</ul>
<h3 id="Multi-site—prep"><a href="#Multi-site—prep" class="headerlink" title="Multi site—prep"></a>Multi site—prep</h3><p><img src="https://i.loli.net/2019/08/19/EAqiml5hf7Iwp19.jpg" alt="012.jpg"></p>
<ol>
<li>在AWS上复制生产环境到站点</li>
<li>DNS 可以根据加权规则进行不同比率流量分配</li>
<li>配置自动故障转移以将流量从受影响的站点重新路由。 例如用于检查主数据库是否可用的应用程序，若master故障则重定向到另外一边</li>
</ol>
<h3 id="Multi-site—recovery"><a href="#Multi-site—recovery" class="headerlink" title="Multi site—recovery"></a>Multi site—recovery</h3><p><img src="https://i.loli.net/2019/08/19/lyESjqAcoma8UPg.jpg" alt="013.jpg"></p>
<ol>
<li>手动或使用DNS故障转移集群，修改DNS权重，以便将所有请求转发到将康站点</li>
<li>具备故障转移应用程r 需要能够逻辑处理在切换后使用本地的数据库（健康）</li>
<li>建议使用AutoScaling组以自动调整其负载规模的变化</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Fail-back"><a href="#Fail-back" class="headerlink" title="Fail back"></a>Fail back</h2><p>当主站点恢复以后，你往往需要将运行环境从灾备环境切换到原来的主环境，此成为 fail-back。对于不同的灾备场景，有不同的做法。</p>
<p><strong>备份和恢复</strong></p>
<ol>
<li>冻结向 DR site 的数据更新</li>
<li>做备份</li>
<li>将备份 restore 到主 site</li>
<li>将用户引流到主site</li>
<li>解冻数据更新</li>
</ol>
<p><strong>Pilot light, warm standby, and multi-site：</strong></p>
<ol>
<li>从 DR site 往主site 做数据同步，直到主site数据一致</li>
<li>冻结向 DR site 的数据更新</li>
<li>将用户引流到主site</li>
<li>解冻数据更新</li>
</ol>
<h2 id="多站点部署需要考虑的因素"><a href="#多站点部署需要考虑的因素" class="headerlink" title="多站点部署需要考虑的因素"></a>多站点部署需要考虑的因素</h2><ul>
<li>站点间的距离 - 距离越远，往往延迟越高</li>
<li>可用的带宽</li>
<li>应用所需的数据同步速率 - 这速度需要低于可用带宽</li>
<li>同步技术 - 同步需要是并行的，以提高效率</li>
<li>同步方式 - 同步的和异步的。AWS RDS 在可用区之间是同步的</li>
<li>同步目标 - 是往一个目标站点同步，还是往多个目标站点同步</li>
</ul>
<h2 id="灾备计划"><a href="#灾备计划" class="headerlink" title="灾备计划"></a>灾备计划</h2><ul>
<li>测试：一旦DR site 准备就绪，需要有完整的测试来验证</li>
<li>持续的监控和告警：对 DR site 做持续监控，并及时处理问题</li>
<li>备份：即使切换到DR site，还是要做常规备份</li>
<li>用户访问：要保证用户访问 DR site 的安全性</li>
</ul>
<p>Refer</p>
<ol>
<li><a href="https://media.amazonwebservices.com/AWS_Disaster_Recovery.pdf" target="_blank" rel="noopener">https://media.amazonwebservices.com/AWS_Disaster_Recovery.pdf</a> 《Using Amazon Web Services for Disaster Recovery》</li>
<li><a href="https://www.cnblogs.com/sammyliu/p/8902556.html" target="_blank" rel="noopener">https://www.cnblogs.com/sammyliu/p/8902556.html</a></li>
<li>《Building Fault-Tolerant Application on AWS》</li>
<li><a href="https://d1.awsstatic.com/whitepapers/architecture/AWS-Reliability-Pillar.pdf" target="_blank" rel="noopener">https://d1.awsstatic.com/whitepapers/architecture/AWS-Reliability-Pillar.pdf</a> 《Reliability Pillar》</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/19/AWS-S3-Deep-Dive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/AWS-S3-Deep-Dive/" itemprop="url">AWS S3 Deep Dive</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T17:24:15+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>前言：本文主要介绍S3的详细功能，涉及S3 存储分类，一致性模型，生命周期管理，版本控制，权限管理，数据加密和最佳实践建议等。</em> </p>
<h1 id="S3-Overview"><a href="#S3-Overview" class="headerlink" title="S3 Overview"></a>S3 Overview</h1><h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><ul>
<li>Amazon S3是一个面向Internet设计的简单的键值对象存储系统</li>
<li>S3提供无限的存储空间，并仅在使用时才产生付费（按需）。费用随着使用量增加将变得更便宜。</li>
<li>S3是对象级别存储(不是块级存储)，不能用于托管OS或动态网站</li>
<li>S3资源在默认情况下是私有的，包含bucket和对象数据</li>
</ul>
<h2 id="S3-Bucket-amp-Objects"><a href="#S3-Bucket-amp-Objects" class="headerlink" title="S3 Bucket&amp;Objects"></a>S3 Bucket&amp;Objects</h2><ul>
<li>Buckets<ul>
<li>Bucket(存储桶)是存储对象的容器空间，组织和管理S3的命名空间</li>
<li>bucket由AWS帐户拥有，该帐户创建bucket并帮助标识负责存储和数据传输费用，bucket所有权不可转让</li>
<li>S3桶名是全局惟一的，但bueket创建是需要指定其所在区域（Region），<table><tr><td bgcolor="orange"> 也就是指其名字是Global，而数据仅限于Region范围内</td></tr></table></li>
<li>每一个object依附于bucket中</li>
<li>可以存储在存储桶中的对象数量没有限制，性能也没有差异(无论使用多buckets或单一bucket)</li>
<li>S3数据模型是扁平结构，即桶内没有层次结构或文件夹。可以通过使用键名称前缀（例如Folder1 / Object1）来推断逻辑层次结构</li>
<li>限制<ul>
<li>每个AWS账户中创建100个存储桶（软限制）</li>
</ul>
</li>
<li>存储桶名称应该是全局唯一且符合DNS的要求<table><tr><td bgcolor="orange">（小写，每一个对象都能通过其唯一url访问，url包含域名）</td></tr></table><ul>
<li>bucket所有权不可转让</li>
<li>bucket不能嵌套bucket</li>
</ul>
</li>
<li>可以删除空桶或非空桶</li>
<li>S3允许检索1000个对象并提供分页支持</li>
</ul>
</li>
<li>Objects<ul>
<li>对象是存储在S3 bucket中的基本实体</li>
<li>对象的唯一标识通过<table><tr><td bgcolor="orange">键名和版本ID</td></tr></table></li>
<li>对象由对象数据、元数据等其他信息组成</li>
<li>Key（键）是对象名称</li>
<li>Value(值)是数据部分且对S3不透明</li>
<li>元数据是关于数据的数据，并且是一组name-value，其描述例如内容类型，大小，最后修改时间。还可以在存储对象时自定义元数据</li>
<li>版本ID是对象的版本，与key结合使用在桶中唯一标识对象</li>
<li>Subresource（子资源） 有助于为对象提供附加信息</li>
<li>Access Control控制对象的访问权限</li>
<li>S3对象允许对象两种元数据<ul>
<li>System metadata<ul>
<li>诸如Last-Modified 时间之类的元数据，只能有S3有权限进行修改</li>
<li>用户可以控制的系统元数据，例如为对象配置的存储类（class）。</li>
</ul>
</li>
<li>User-defined metadata<ul>
<li>User可以自定义其对象元数据上传之前或之后</li>
<li>字定义的元数据与对象一起存储，并在下载对象时返回</li>
<li>S3不处理自定义元数据</li>
<li>自定义元数据必须以“x-amz-meta”开头，否则S3将不会处理其自定义设置</li>
</ul>
</li>
</ul>
</li>
<li>对象元数据上传之后不能修改，只能通过执行复制操作来设置元数据修改</li>
<li>属于bucket的对象保存在设定的Region范围内，不能离开此区域，除非使用块区域复制进行显式复制</li>
<li>对象作为整体或部分进行检索</li>
<li>启用版本控制之后，可以检索当前和之前的版本</li>
</ul>
</li>
</ul>
<h2 id="Bucket-amp-Object-操作"><a href="#Bucket-amp-Object-操作" class="headerlink" title="Bucket &amp; Object 操作"></a>Bucket &amp; Object 操作</h2><ul>
<li>Listing<ul>
<li>S 3 允许列出存储桶中所有key</li>
<li>一个list请求最多返回1000个对象，并且支持分页展示，在响应中使用指示器显示是否响应</li>
<li>可以使用前缀和分隔符列出key</li>
<li>Prefix将结果限制为仅以指定前缀开头的键(过滤)，分隔符list将包含公共前缀的所有key列出，形成一个摘要列表</li>
</ul>
</li>
<li>Retrival<ul>
<li>对象可以作为整体取回</li>
<li>可以使用Range HTTP标头一部分或部分特定字节检索对象</li>
<li>Range HTTP 标头非常有用<ul>
<li>如只需要部分对象，在多文件作为一个归档文件上传的时候</li>
<li>在网络环境较差的情况下，进行下载数据</li>
</ul>
</li>
<li>对象支持预签名 url访问</li>
<li>对象的元数据包含在响应标头中</li>
</ul>
</li>
<li>Object Uploads<ul>
<li>单次操作——单次put 操作最大对象5GB</li>
<li>分段上传——可用于上传大于5B大小的对象，最大5TB</li>
<li>支持预签名 URL上传对象</li>
<li>上传对象是否成功，可通过reponse值显示。此外，可以将返回的ETAG值与对象的MD5值进行比对</li>
</ul>
</li>
<li>Copying Objects<ul>
<li>单次操作最大5GB的对象，使用分段上传进行大于5GB的对象（最大5TB）</li>
<li>复制对象时<ul>
<li>用户自定义的元数据，如存储类和自定义的元数据都会被复制</li>
<li>系统元数据保留（如创建日期）</li>
</ul>
</li>
<li>其他复制情形<ul>
<li>复制多个对象副本</li>
<li>跨地点复制对象</li>
<li>重命名对象</li>
<li>更改对象元数据，例如存储分类，服务器端加密等</li>
<li>更新对象的任何元数据都需要再次指定的字段</li>
</ul>
</li>
</ul>
</li>
<li>Deleting Objects<ul>
<li>S3允许单次删除一个或最多100个对象</li>
<li>未开启版本控制bucket<ul>
<li>明确提供键名（key）则永久删除对象</li>
</ul>
</li>
<li>开启版本控制bucket<ul>
<li>删除对象键(key)，S3将插入一个删除标记，当前对象将变为非当前对象</li>
<li>删除对象键（key）和version ID,S3将永久删除对象</li>
<li>若version id作为删除标记，那么删除标记将被删除，previous版本将成为当前版本对象</li>
<li>启用MFA安全删除需要删除的对象</li>
</ul>
</li>
</ul>
</li>
<li>Restoring Objects from Glacier <ul>
<li>在访问存档对象之前，必须还原对象</li>
<li>对象的恢复可能需要大约3到5个小时进行标准检索。Glacier现在可以在几分钟内提供快速检索</li>
<li>恢复请求对象需要指定需要维护对象副本（Glacier数据临时放到S3上）的时间（天）</li>
<li>在此期间，存档和副本的存储费用都要收取</li>
</ul>
</li>
</ul>
<h2 id="Pre-Signed-URLs"><a href="#Pre-Signed-URLs" class="headerlink" title="Pre-Signed  URLs"></a>Pre-Signed  URLs</h2><ul>
<li>默认情况下，所有存储桶和对象都是私有的</li>
<li>预签名URL允许用户无需AWS安全凭据或权限即可下载或上载特定对象</li>
<li>预签名URL允许任何人访问URL中标识的对象，只要创建者游泳访问权限</li>
<li>预签名url需要创建者提供其安全凭证、指定bucket名称、对象密钥、HTTP方法(GET PUT)以及过期日期和时间</li>
<li>预签名url有时间期限</li>
</ul>
<h2 id="Multipart-upload"><a href="#Multipart-upload" class="headerlink" title="Multipart upload"></a>Multipart upload</h2><ul>
<li>分段上传允许分批次上传，每一次操作都是数据的一部分（子集）</li>
<li>Multipart uploads支持将数据拆分成1~10000部分，每部分数据从5MB到5GB，最后一次上传的数据允许小于5MB</li>
<li>每一部分数据可以独立上传，并且可以任意顺序上传。如果任何部分的传输失败，不影响其他部分的情况下重新上传</li>
<li>上传对象的所有部分并完成初始化之后，S3组装这些数据并创建对</li>
<li>使用分段上传的优势<ul>
<li>提高吞吐量——并行</li>
<li>避免网络故障的影响范围——最大减小网络故障带来上传数据失败（但也只影响部分数据，而不是全部）</li>
<li>暂停和恢复上传-对象部分可以随时间上传。一旦多部分上传启动，需要指定其完成或者中断时间，要不然会持续占有进程。就</li>
<li>对象可以在创建时上传，即便未知其大小</li>
</ul>
</li>
<li>操作步骤<ul>
<li>分段上传初始化<ul>
<li>分段上传请求初始化时会为每个分段上传分配唯一ID</li>
<li>每个部分上传，在完成或中止请求以及分段调用使用供此ID</li>
<li>在初始化时需要用提供object的元数据</li>
</ul>
</li>
<li>分段上传<ul>
<li>分段上传的数据使用唯一的上传ID标识</li>
<li>每一部分都有一个part number（1~1000）标识自己的分段在对象数据中位置</li>
<li>如果上传部分有相同的part number 则会覆盖前面的数据</li>
<li>上传成功之后，S3会返回Etag标头，标头需要与part number一起记录下来</li>
</ul>
</li>
<li>上传完成或暂停<ul>
<li>一旦上传请求完成，S3根据part number顺序组装数据，并将元数据与对象关联，创建对象</li>
<li>每一部分上传完成，应包含分段唯一上传UD、Etag</li>
<li>S3 response包括唯一地标识所述组合对象数据一个ETag</li>
<li>当分段上传abort时，则中止并删除所有上传的分段。但是，任何其他已经正在上传的部分，必须在完成上传之后才能发送abort</li>
<li>S3需要明确接收到上传完成或中止请求，不然不会删除上传部分并会收取相关存储费用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟主机-vs-url路径访问模式"><a href="#虚拟主机-vs-url路径访问模式" class="headerlink" title="虚拟主机 vs url路径访问模式"></a>虚拟主机 vs url路径访问模式</h2><p>S3允许以路径样式或虚拟主机样式的url引用桶和对象</p>
<ul>
<li>Path style <ul>
<li>Bucket name不是域名一部分（除非使用区域特定端点）</li>
<li>使用的endpoint必须与存储桶所在的区域匹配，例如，如果有一个名为mybucket的存储桶位于EU（爱尔兰）区域，其对象名为puppy.jpg，则正确的路径样式语法URI为http：//s3-eu-west-1.amazonaws.com/mybucket/puppy.jpg</li>
<li>收到带有HTTP响应代码301的“PermanentRedirect”错误，这条消息表达的意思是：如果在美国东部（弗吉尼亚北部）区域之外访问存储桶，正确的合规的资源URL请使用如下表达方式：<ul>
<li><a href="http://s3.amazonaws.com" target="_blank" rel="noopener">http://s3.amazonaws.com</a></li>
<li>与存储区所在区域不同的区域的endpoint。 例如，如果使用<a href="http://s3-eu-west-1.amazonaws.com获取在美国西部（加利福尼亚州北部）地区创建的存储桶" target="_blank" rel="noopener">http://s3-eu-west-1.amazonaws.com获取在美国西部（加利福尼亚州北部）地区创建的存储桶</a></li>
</ul>
</li>
</ul>
</li>
<li>Virtual Host style <ul>
<li>S3 支持在所有区域中的虚拟主机托管和路径访问模式</li>
<li>在虚拟主机托管方式中，bucket name是url中域名的一部分</li>
<li>如<a href="http://bucketname.s3.amazonaws.com/objectname" target="_blank" rel="noopener">http://bucketname.s3.amazonaws.com/objectname</a></li>
<li>S3虚拟主机可用于通过使用HTTP host 标头头来使用REST API调用存储桶</li>
<li>优势<ul>
<li>自定义访问路径</li>
<li>提供发布到bucket虚拟主机的“root directory”的功能。此功能非常重要，许多现有应用程序会在此标准位置搜索数据</li>
</ul>
</li>
<li>当在任何区域中创建存储桶时，S3会更新DNS以将请求重新路由到正确的位置，这可能需要一些时间。</li>
<li>如果使用美国东部（弗吉尼亚北部）端点s3.amazonaws.com，则S3会将任何虚拟托管样式请求路由到美国东部（N.Virginia）区域，而不是特定于区域的端点（例如 ，s3-eu-west-1.amazonaws.com）并且S3将其重定向到HTTP 307重定向到正确的区域。</li>
<li>使用带有SSL的虚拟托管样式存储桶时，SSL通配符证书仅匹配不包含句点的存储桶。要解决此问题，请使用HTTP或自行编写证书验证逻辑。</li>
<li>如果向<a href="http://bucket.s3.amazonaws.com端点发出请求，则DNS有足够的信息将请求直接路由到存储区所在的区域。" target="_blank" rel="noopener">http://bucket.s3.amazonaws.com端点发出请求，则DNS有足够的信息将请求直接路由到存储区所在的区域。</a></li>
</ul>
</li>
</ul>
<h1 id="S3-Conssistency-Model-一致性模型"><a href="#S3-Conssistency-Model-一致性模型" class="headerlink" title="S3 Conssistency Model 一致性模型"></a>S3 Conssistency Model 一致性模型</h1><ul>
<li>S3通过在亚马逊数据数据中心内的多个服务器上复制数据来实现高可用性</li>
<li>S3为新的对象put 提供写后读一致性（read-after-write）<ul>
<li>对于PUT请求，S3在返回SUCCESS之前完成在多个设施中数据同步</li>
<li>进程对新对象的写入，可以立即读取对象</li>
<li>进程将新对象的写入S3能立即在其存储桶中列出key。 在完全传播更改之前，对象可能不会出现在list中</li>
</ul>
</li>
<li>S3对覆盖puts&amp;deletes 对象提供最终一致性<ul>
<li>对象的更新和删除，更改最终会反映出来并且不会立即可用</li>
<li>若进程替换现有对象并立即尝试读取它。 在完全传播更改之前，S3可能会返回先前的数据</li>
<li>若进程删除现有对象并立即尝试读取它。 在完全传播删除之前，S3可能会返回已删除的数据</li>
<li>若进程删除现有对象并立即在其存储桶中列出key。 在删除完全传播之前，S3可能会列出已删除的对象。</li>
</ul>
</li>
<li>对于key的更改是原子的。 例如，如果PUT到现有key，后续读取可能会返回旧数据或更新数据，但它永远不会写入损坏或只有部分数据（不存在中间状态，要么成功要么失败）。</li>
<li>S3目前不支持对象数据锁定。例如，如果同时对同一个key发出两个PUT请求，则具有最新时间戳的请求获胜。如果要避免这个问题，将需要在应用程序中构建一个对象锁定机制</li>
<li>更新是基于key的; 没有办法跨key进行原子更新。 例如，除非在应用程序中设计此功能，否则无法更新一个key取决于另一个key的更新</li>
</ul>
<h1 id="S3-Subresources"><a href="#S3-Subresources" class="headerlink" title="S3 Subresources"></a>S3 Subresources</h1><ul>
<li>S3 Subresources提供存储和管理bucket配置</li>
<li>S3 subresources 存在于特定的存储桶或对象中</li>
<li>S3定义了一组与桶和对象相关联的subresources</li>
<li>S3 subresources是对象的子集; 也就是说，它们不是自己存在的，它们总是与某个其他实体相关联，例如对象或桶(如acl或bittorrent)</li>
<li>S3支持配置存储桶的各种选项，例如，可以配置存储桶用于网站托管，添加配置以管理存储桶中对象的生命周期，以及记录对存储桶的所有访问</li>
</ul>
<h2 id="静态网站托管"><a href="#静态网站托管" class="headerlink" title="静态网站托管"></a>静态网站托管</h2><ul>
<li>S3可用于静态网站托管（client 处理脚本）</li>
<li>S3不支持服务端处理脚本</li>
<li>S3与Route 53结合使用，支持根域托管网站，直接指向指向S3网站端点</li>
<li>S3 网站端点不支持Https</li>
<li>对于S3网站托管，内容应该是公开可读的，可以使用桶策略或对象上的ACL来设置</li>
<li>用户可以自定义索引，错误页面以及指向对象名称的条件路由</li>
<li>存储桶策略仅适用于存储桶拥有者拥有的对象。如果存储桶包含不属于存储桶拥有者的对象，则应使用对象ACL授予对这些对象的公共READ权限</li>
<li>请求者支付费用或DevPay存储桶不允许通过网站端点进行访问。对此类存储桶的任何请求都将收到403 -拒绝响应</li>
</ul>
<h2 id="跨源资源共享-CORS"><a href="#跨源资源共享-CORS" class="headerlink" title="跨源资源共享 (CORS)"></a>跨源资源共享 (CORS)</h2><ul>
<li>所有浏览器都实现了同源策略，出于安全考虑，其中来自域网页只能从同一个域请求资源。</li>
<li>CORS允许装在一个域中访问受限的资源上的客户端Web应用程序从另一个域要求</li>
<li>在S3中使用CORS支持允许跨源访问S3资源</li>
<li>CORS配置规则标识允许访问存储桶的起源，每个源支持的操作（HTTP 方法）以及其他特定操作的信息</li>
</ul>
<h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><ul>
<li>默认情况下禁用日志记录，开启追踪可以记录S3访问记录</li>
<li>每单个访问请求的详细日志记录信息，包含请求者，存储桶名称，请求时间，请求操作，响应状态和错误代码（如果有）。</li>
<li>访问日志信息在安全性和访问审核中非常有用，还有助于了解客户和S3账单</li>
<li>S3定期收集访问日志记录，合并日志文件中的记录，然后将日志文件作为日志对象上载到目标存储桶。</li>
<li>如果在具有相同目标bucket的多个源存储桶上启用了日志记录，则目标存储桶将具有所有这些源存储桶的访问日志，但每个日志对象将报告指定其源存储桶的访问日志记录。<br>标签</li>
<li>S3提供标记子资源以存储和管理存储桶上的标记</li>
<li>可以将成本分配标签添加到存储桶以对AWS成本进行分类和跟踪</li>
<li>AWS可以产生与使用和添加到bucket中的标签汇总费用成本分配报告</li>
</ul>
<h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><ul>
<li>创建存储桶时，需要明确指定在将要创建S3存储桶的AWS区域</li>
<li>S3将此信息存储在subresource(子资源)中，并提供用于检索此信息的API</li>
</ul>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><ul>
<li>通过 Amazon S3 通知功能，可以在存储桶中发生某些事件时接收通知</li>
<li>通知级别是Bucket级</li>
<li>通知配置可以通过对象的key的前缀和后缀进行过滤，但是不能使用重叠定义过滤规则</li>
<li>S3支持的时间类型<ul>
<li>新对象创建<ul>
<li>PUT、POST、COPY操作</li>
<li>不会从失败的操作收到事件通知</li>
</ul>
</li>
<li>对象删除事件<ul>
<li>公共删除事件以删除对象，删除版本对象或删除标记的插入</li>
<li>不会收到来自生命周期策略或失败操作的自动删除的事件通知</li>
<li>RRS存储类别对象丢失事件</li>
<li>可用于重现/重新创建Object</li>
</ul>
</li>
</ul>
</li>
<li>S3支持将事件发布到一下目标<ul>
<li>SNS</li>
<li>SQS</li>
<li>AWS lambda</li>
<li>必须授予Amazon S3 权限以调用相应目标</li>
</ul>
</li>
</ul>
<h2 id="跨区域复制-CRR"><a href="#跨区域复制-CRR" class="headerlink" title="跨区域复制 (CRR)"></a>跨区域复制 (CRR)</h2><ul>
<li>跨区域复制是一项存储桶级别配置，该功能支持跨不同 AWS 区域中的存储桶自动异步复制对象</li>
<li>可以请求 Amazon S3 复制所有对象，也可以通过在配置中提供一个键名称前缀来请求复制部分对象</li>
<li>默认使用安全套接字层 (SSL) 跨 AWS 区域加密传输中的所有数据</li>
<li>除非复制配置中发出特定请求，否则目标存储桶中的对象副本与源存储桶中的对象完全相同</li>
<li>CRR可用于以下场景需求：<ul>
<li>合规性要求——跨区域备份</li>
<li>最大限度减少延迟 – 客户处于两个地理位置</li>
<li>操作原因 – 两个不同 AWS 区域中具有分析同一组对象的计算集群</li>
</ul>
</li>
<li>要求<ul>
<li>源存储桶和目标存储桶必须已启用版本控制</li>
<li>源存储桶和目标存储桶必须处于不同的 AWS 区域</li>
<li>对象只能从源存储桶复制到一个目标存储桶</li>
<li>S3 必须对象从源存储桶复制到目标存储桶的权限</li>
<li>源存储桶拥有者也是对象的拥有者，则其拥有复制对象的完全权限。如果不是，则对象拥有者必须通过对象 ACL 向存储桶拥有者授予 READ 和 READ_ACP 权限（s3:GetObjectVersion and s3:GetObjectVersionACL）</li>
<li>在跨账户方案 (其中，源存储桶和目标存储桶由不同的 AWS 账户拥有) 中设置复制配置，源存储区拥有者必须具有复制目标存储区中对象的权限。</li>
</ul>
</li>
<li>复制和不复制的内容<ul>
<li>复制的内容<ul>
<li>添加复制配置之后创建的任何新对象</li>
<li>S3 会复制使用 Amazon S3 托管密钥 (SSE-S3) </li>
<li>复制存储桶拥有者有权读取对象和访问控制列表 (ACL) 的源存储桶中的对象</li>
<li>虽然在Amazon S3可以使两者同步之前可能会有一些延迟，但会复制任何对象ACL更新。 这仅适用于将复制配置添加到存储桶后创建的对象。<ul>
<li>不复制的内容</li>
</ul>
</li>
<li>S3不会追溯复制添加复制配置之前存在的对象</li>
<li>S3不会复制存储桶拥有者没有权限的源存储桶中的对象</li>
<li>对存储桶级别子资源进行的更新不会进行复制</li>
<li>不会复制使用客户提供的加密密钥通过服务器端加密 (SSE-C) 创建的对象。</li>
<li>不会复制使用 AWS KMS 托管加密密钥通过服务器端加密 (SSE-KMS) 创建的对象</li>
<li>仅复制客户操作。不复制生命周期配置执行的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="S3-Storage-Tiers-存储分层"><a href="#S3-Storage-Tiers-存储分层" class="headerlink" title="S3 Storage Tiers 存储分层"></a>S3 Storage Tiers 存储分层</h1><ul>
<li>Amazon S3存储层旨在维持一个或两个设施中的并发数据丢失</li>
<li>S3存储层允许生命周期管理以自动迁移对象以节省成本</li>
<li>S3存储层支持传输中的数据和静态数据加密的SSL加密</li>
<li>S3还使用校验和定期验证数据的完整性，并提供自动修复功能</li>
</ul>
<h2 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h2><ul>
<li>针对性能敏感的场景和频繁访问数据的理想选择，能够在2个设施的故障情况下继续提供服务</li>
<li>默认的存储层</li>
<li>低延迟和高吞吐的性能</li>
<li>11个9的持久性设计方案</li>
<li>年可使用率达到99.99%</li>
<li>提供Amazon SLA服务等级保障协议</li>
</ul>
<h2 id="Standard-IA"><a href="#Standard-IA" class="headerlink" title="Standard-IA"></a>Standard-IA</h2><ul>
<li>S3 Standard-IA （infrequent Access）存储层旨在提供长周期保存和不长访问的数据，如备份和受限访问旧数据，但仍然在访问时需要提供Standard层的性能</li>
<li>STANDARD-IA旨在维持两个基础设施中的数据丢失</li>
<li>STANDARD_IA对象可用于实时访问</li>
<li>STANDARD_IA存储类适用于保留至少30天的大于128 KB的较大对象（较小的对象仅为128 KB）。</li>
<li>标准的低延迟和高吞吐量性能</li>
<li>专为99.999999999％的持久性设计</li>
<li>年可使用率达到99.99%</li>
<li>提供Amazon SLA服务等级保障协议</li>
</ul>
<h2 id="Reduced-Redundancy-Storage-–-RRS"><a href="#Reduced-Redundancy-Storage-–-RRS" class="headerlink" title="Reduced Redundancy Storage – RRS"></a>Reduced Redundancy Storage – RRS</h2><ul>
<li>RRS存储层设计用于以比STANDARD层别更低的冗余级别存储，存储非关键，可重现的数据，从而降低存储成本</li>
<li>专为99.99％的持久性设计</li>
<li>年可使用率达到99.99%</li>
<li>较低的冗余级别导致较低的耐用性和可用性</li>
<li>RRS将对象存储在多个设备的多个设备上，提供400倍于典型磁盘驱动器的耐用性，</li>
<li>RRS不会像S3标准存储一样多次复制对象，并且旨在维持单个设施中的数据丢失。</li>
<li>如果RRS对象丢失，则S3对该对象发出的请求返回405错误</li>
<li>S3可以发送在桶上配置的事件通知，以在检测到RRS对象丢失时用于警告用户或启动工作流，该RRS对象可用于替换丢失的对象</li>
</ul>
<h2 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h2><ul>
<li>GLACIER存储层特别适合用于存档数据，其中数据取回通常需要3-5小时罕</li>
<li>GLACIER存储层使用非常低成本的存储服务，但此存储类中的对象仍通过S3管理</li>
<li>专为99.999999999％的持久性设计</li>
<li>GLACIER不能在对象创建时指定为存储层，但必须使用生命周期管理从STANDARD，RRS或STANDARD_IA转换为GLACIER存储类。</li>
<li>访问Glacier 对象<ul>
<li>必须通过恢复对象，这可能需要3-5小时</li>
<li>对象仅适用于还原请求期间指定的时间段（天数）</li>
<li>对象的始终保存在Glacier</li>
<li>存档（GLACIER层费用）和临时恢复的副本（RRS层费用）均收取费用</li>
</ul>
</li>
<li>Vault Lock功能可锁定策略强制实施合规性</li>
</ul>
<h1 id="S3-Object-Lifecycle"><a href="#S3-Object-Lifecycle" class="headerlink" title="S3 Object Lifecycle"></a>S3 Object Lifecycle</h1><h2 id="S3-Object-Lifecycle-Overview"><a href="#S3-Object-Lifecycle-Overview" class="headerlink" title="S3 Object Lifecycle Overview"></a>S3 Object Lifecycle Overview</h2><ul>
<li>可以使用生命周期策略来管理S3对象生命周期，该生命周期策略定义S3在其生命周期中如何管理对象</li>
<li>生命周期策略简化对象的生命周期管理，例如移动访问频率较低的对象、备份或存档数年的数据或永久删除对象，所有操作都可以后台自动控制</li>
<li>每个bucket最多配置1000个生命周期规则</li>
<li>应用于存储桶的S3对象生命周期策略规则适用于存储桶中的现有对象以及将未来添加的对象</li>
<li>S3对象生命周期策略对数据管理支持两种操作：<ul>
<li>Transition(转换)，其对象可以更改存储层（class）</li>
<li>Expiration，到期时间永久删除</li>
</ul>
</li>
<li>生命周期策略可以与版本控制结合，允许一个当前对象版本和零级或多个非当前对象的版</li>
<li>生命周期策略适用于非版本控制和启用版本控制的存储桶</li>
<li>未开启版本控制bucket<ul>
<li>Transition周期从对象创建时算起</li>
</ul>
</li>
<li>开启版本控制bucket<ul>
<li>Transition周期从对象创建起开始</li>
<li>非当前对象的转换周期是为该对象成为非当前版本控制对象的日期计算的</li>
<li>S3使用自其后续对象创建以来的天数作为对象非当前的时间</li>
</ul>
</li>
<li>S3规则中指定的时间从对象创建时间开始算起，采用UTC记录。</li>
<li>不支持在bucket的生命周期策略使用MFA</li>
</ul>
<h2 id="S3-Object-Lifecycle-Management-Rules"><a href="#S3-Object-Lifecycle-Management-Rules" class="headerlink" title="S3 Object Lifecycle Management Rules"></a>S3 Object Lifecycle Management Rules</h2><ol>
<li>STANDARD或REDUCED_REDUNDANCY  - &gt;（128 KB和30天） - &gt; STANDARD_IA<ul>
<li>只能transition(转换)超过128kb的对象，因为只有较大的对象才能实现成本优势（转到Standard-ia）</li>
<li>在转换到STANDARD_IA之前，对象必须在当前存储层中至少30天，因为较新的对象被更频繁地访问或者比适合STANDARD_IA更早删除</li>
</ul>
</li>
<li>STANDARD_IA -&gt; X -&gt; STANDARD or REDUCED_REDUNDANCY<ul>
<li>无法从Standard-IA转换到Standard或reduced-redundancy</li>
</ul>
</li>
<li>STANDARD or REDUCED_REDUNDANCY or STANDARD_IA -&gt; GLACIER<ul>
<li>任何存储层数据都可以transition 到Glacier</li>
</ul>
</li>
<li>STANDARD or REDUCED_REDUNDANCY -&gt; (1 day) -&gt; GLACIER<ul>
<li>标准或RRS层转换到Glacier在一天内完成</li>
</ul>
</li>
<li>STANDARD_IA -&gt; (30 days) -&gt; GLACIER<ul>
<li>对象创建起或非当前版本日期，需要花费30~60天才能从Standard-IA转换到Glacier</li>
</ul>
</li>
<li>GLACIER-&gt; X -&gt; STANDARD or REDUCED_REDUNDANCY or STANDARD_IA<ul>
<li>对象转换到Glacier层时单向的</li>
<li>无法从Glacier层将数据转换到其他存储层</li>
</ul>
</li>
<li>GLACIER -&gt; (90 days) -&gt; Permanent Deletion<ul>
<li>归档到Glacier层的数据，已经存档3个月或更长，则删除归档对象是免费的</li>
<li>如果删除或覆盖存档3个月以内的对象，则会按比例收取相关费用</li>
</ul>
</li>
<li>STANDARD or STANDARD_IA or GLACIER -&gt; X-&gt; REDUCED_REDUNDANCY<ul>
<li>无法将数据从任何存储层转换到Reduced-redundancy</li>
</ul>
</li>
<li>使用对象生命周期策略将对象归档到Glacier是异步执行的，并且生命周期策略中的转换日期与物理转换的日期之间可能存在延迟。 但是，AWS会根据规则中指定的转换日期收取Glacier的价格。</li>
<li>开启版本控制的bucket<ul>
<li>Transition和Experition 都适合当前的版本</li>
<li>NoncurrentVersionTransition和NoncurrentVersionExpiration操作适用于非当前版本，其工作方式类似于未开启版本对象，但时间段是从对象变为非当前时间开始的</li>
</ul>
</li>
<li>过期规则<ul>
<li>未开启版本控制：对象永久删除</li>
<li>开启版本控制<ul>
<li>规则使用于current 对象，不影响任何非当前对象</li>
<li>S3将标记具有唯一ID的Delete Marker对象，并且先前的当前对象变为非当前版本</li>
<li>若当前对象已经有一个删除标记，将不会采取任何操作</li>
<li>如果bucket只有一个对象，并且已经标记删除（过期对象删除标记），S3移除删除标记</li>
</ul>
</li>
<li>版本控制suspend 桶<ul>
<li>S3将插入版本ID为null的Delete Marker标记，并覆盖版本ID为null的任何对象</li>
</ul>
</li>
</ul>
</li>
<li>当对象到达其生命周期的末尾时， S3将排队以进行删除并异步操作。 在到期日期和S3删除对象的日期之间可能存在延迟。不需要为与已过期的对象关联的存储时间付费。</li>
<li>如果生命周期策略置于STANDARD_IA中的对象不到30天，或者GLACIER少于90天，则会有额外的成本费用产生。</li>
</ol>
<h1 id="S3-Object-Versioning"><a href="#S3-Object-Versioning" class="headerlink" title="S3 Object Versioning"></a>S3 Object Versioning</h1><ul>
<li>版本控制可用于防止意外覆盖和删除数据</li>
<li>版本控制将对象多个不同版本保留在bucket中，用于保存历史版本，检索和还原对象的不同版本</li>
<li>由于版本控制保留了整个相同对象的多个副本，因此要为多个版本产生费用。 对于带有5个副本的1GB文件，如果存在细微的差异，则会消耗5GB的S3存储空间，并且需要支付相同5GB空间费用</li>
<li>默认情况下不启用版本控制，存储桶使用时要明确启用</li>
<li>版本一旦启用，无法禁用，只能暂停</li>
<li>Bucket启用版本控制，适用于存储桶中所有对象</li>
<li>权限在版本级别设置。 每个版本都有自己的对象所有者; AWS账户是创建对象版本所有者。 因此，可以为同一对象的不同版本设置不同的权限</li>
<li>无论如何控制版本，桶中每个对象都有一个版本<ul>
<li>未开启版本控制存储桶，每个对象的版本ID为null</li>
<li>开启版本控制的存储桶，每个对象分配唯一的版本ID</li>
</ul>
</li>
<li>版本控制，版本ID与桶名和对象key(键)一起构成一个唯一的key元素，用于定义桶中对象的唯一性</li>
<li>对象检索<ul>
<li>未开启版本控制存储桶：检索始终返回唯一的可用对象</li>
<li>开启版本控制的存储桶，返回当前对象，可以通过指定版本ID返回非当前对象</li>
</ul>
</li>
<li>对象添加<ul>
<li>未开启版本控制：再次上传相同键的对象，则会覆盖该对象</li>
<li>开启版本控制：上传相同键的对象，则新上传的将会成为当前版本，之前的成为非当前版本</li>
<li>可以检索和恢复非当前版本化对象，从而防止意外覆盖</li>
</ul>
</li>
<li>删除对象<ul>
<li>未开启版本控制：对象永久删除，且无法恢复</li>
<li>开启版本控制：所有对象都保留，Amazon会插入一个删除标记，用于标记当前版本；可以检索和恢复非当前版本对象，从而防止意外删除和覆盖；如果指定删除版本ID的对象，则会永久删除且无法恢复</li>
</ul>
</li>
<li>删除标记<ul>
<li>删除标记对象没有任何与之关联的数据或acl，只有key和版本ID</li>
<li>对已经使用删除标记的对象检索将返回404</li>
<li>已经标记“delete marker”对象上只允许DELETE操作</li>
<li>指定其版本ID删除标记对象，则先前的版本对象将成为当前版本对象</li>
<li>如果将DELETE标记作为当前版本在桶上触发DELETE请求，则不会删除DELETE标记，而是再次添加一个DELETE标记</li>
</ul>
</li>
<li>恢复之前版本<ul>
<li>将先前版本对象复制到同一存储桶中。复制的对象将成为该对象当前的版本，并保留之前的对象版本。（建议保留所有版本）</li>
<li>永久删除当前版本时，世纪将之前的版本转换为当前版本</li>
</ul>
</li>
<li>暂停版本控制<ul>
<li>可以暂停版本控制功能，以停止存储桶后续对象的积累新的版本</li>
<li>已存在的对象不会更改，只对新添加对象有效</li>
<li>对于每个新添加的对象，对象添加版本ID为null</li>
<li>对于具有相同key的对象添加，对象和版本ID（null）都会被覆盖</li>
<li>存储桶上的DELETE请求将永久删除版本ID空对象并插入删除标记</li>
<li>如果存储桶没有版本ID为null的对象，则DELETE请求不会删除任何内容</li>
<li>对于存储了版本ID的任何先前对象，仍然可以使用指定版本ID触发DELETE请求</li>
</ul>
</li>
<li>启用 MFA 删除<ul>
<li>启用MFA删除，可以提高起安全性</li>
<li>在存储桶上启用MFA删除，以确保不会意外删除存储桶中的数据</li>
<li>存储桶拥有者，创建存储桶（root帐户）的AWS账户以及所有授权的IAM用户可以启用版本控制，但只有存储桶拥有者（root帐户）可以启用MFA删除</li>
</ul>
</li>
</ul>
<h1 id="S3-Permission-权限"><a href="#S3-Permission-权限" class="headerlink" title="S3 Permission 权限"></a>S3 Permission 权限</h1><ul>
<li>默认情况下，所有S3 存储桶，对象和相关子资源都时私有的</li>
<li>可以通过AWS 账户或IAM（有权限）访问资源</li>
<li>存储拥有者时创建存储桶的AWS账户</li>
<li>对象所有者是将对象上载到存储桶的AWS账户，而不是该账户所拥有的存储桶</li>
<li>只有资源所有者（创建资源的AWS账户）才能访问该资源</li>
<li>资源所有者<ul>
<li>创建存储桶或对象的AWS账户时这些资源拥有者</li>
<li>如果IAM用户创建存储桶或对象，则IAM用户的AWS账户拥有该资源</li>
<li>如果存储桶拥有者向其他AWS账户用户授予跨对象权限以将对象上载到存储桶，则对象由上载对象的用户的AWS账户拥有，而不是存储桶拥有者，但以下条件除外<ul>
<li>存储桶拥有者可以拒绝访问该对象，因为它是支付该对象的存储桶拥有者</li>
<li>存储桶拥有者可以删除或应用存档规则到对象并执行恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="S3-权限分类"><a href="#S3-权限分类" class="headerlink" title="S3 权限分类"></a>S3 权限分类</h2><ul>
<li>基于资源的策略和用户策略</li>
</ul>
<h3 id="用户策略"><a href="#用户策略" class="headerlink" title="用户策略"></a>用户策略</h3><ul>
<li>基于用户的策略使用IAM和S3来控制用户或用户组对AWS账户拥有的S3存储桶的访问类型</li>
<li>基于用户的策略始终附加到用户，组或角色，无法授予匿名权限</li>
<li>如果拥有存储桶的AWS账户想要向其帐户中的用户授予权限，则可以使用存储桶策略或用户策略</li>
</ul>
<h3 id="资源策略"><a href="#资源策略" class="headerlink" title="资源策略"></a>资源策略</h3><ul>
<li>存储桶策略和访问控制列表（ACL）是基于资源的，因为它们附加到Amazon S3资源</li>
</ul>
<p><img src="https://i.loli.net/2019/08/19/qv6ix2mDjR4XkUS.jpg" alt="001.jpg"></p>
<ul>
<li>存储桶策略&amp;访问控制列表</li>
</ul>
<h3 id="存储桶策略"><a href="#存储桶策略" class="headerlink" title="存储桶策略"></a>存储桶策略</h3><ul>
<li>存储桶策略用于向其他AWS账户或IAM用户授予对其中的存储桶和对象的跨账户访问权限</li>
<li>桶策略提供集中的，基于各种条件，包括S3的操作，请求者，资源和方面请求的访问控制区和物件（例如IP地址）</li>
<li>如果拥有存储桶的AWS账户想要向其帐户中的用户授予权限，则可以使用存储桶策略或用户策略</li>
<li>附加到存储桶的权限适用于存储桶所有者创建和拥有的该存储桶中的所有对象</li>
<li>策略可以在存储桶中的所有（或子集）对象上添加或拒绝权限</li>
<li>仅允许存储桶拥有者将策略与存储桶关联</li>
<li>仅允许存储桶拥有者将策略与存储桶关联</li>
</ul>
<h3 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h3><ul>
<li>存储桶和对象都可以有与之相关联的ACL</li>
<li>ACL是一个授权列表，用于标识被授予者和授予的权限</li>
<li>ACL向其他账户授予对资源的基本读/写权限</li>
<li>ACL是一系列的受限的权限集，<ul>
<li>不能授予条件权限，</li>
<li>也不能显式拒绝权限</li>
<li>不能用于授予bucket子资源的权限</li>
</ul>
</li>
<li>可以通过电子邮件地址或规范用户ID（模糊匹配的帐户ID）向AWS账户授予权限。 如果提供了电子邮件地址，S3仍会找到该用户的规范用户ID并将其添加到ACL</li>
<li>建议使用规范的用户ID，电子邮件地址将来不会被支持</li>
</ul>
<h3 id="Bucket-ACL"><a href="#Bucket-ACL" class="headerlink" title="Bucket ACL"></a>Bucket ACL</h3><ul>
<li>仅推荐用于 bucket ACL的用例是向S3 Log Delivery组授予写入权限，以将访问日志对象写入存储区</li>
<li>如果存储桶需要访问日志传送，则bucket ACL将有助于将存储桶的写入权限授予日志传送组</li>
<li>只有这样才能通过bucket ACL为日志传送组授予必要的权限</li>
</ul>
<h3 id="Object-ACL"><a href="#Object-ACL" class="headerlink" title="Object ACL"></a>Object ACL</h3><ul>
<li>对象ACL仅控制对象级权限</li>
<li>对象ACL是管理不属于存储桶拥有者的存储桶中对象的权限的唯一方法，即如果存储桶拥有者允许跨帐户对象上载，并且对象所有者与存储桶拥有者不同，则对象的所有者授予对象的权限是通过对象ACL</li>
<li>如果存储桶和对象由同一AWS账户拥有，则可以使用存储桶策略来管理权限</li>
<li>如果对象和用户归同一AWS账户所有，则可以使用用户策略来管理权限</li>
</ul>
<h3 id="Amazon-S3-请求授权"><a href="#Amazon-S3-请求授权" class="headerlink" title="Amazon S3 请求授权"></a>Amazon S3 请求授权</h3><pre><code>当Amazon S3收到请求时，它将评估所有用户策略，存储桶策略和确定是否授权或拒绝该请求。</code></pre><p>S3将在3个方面进行策略评估</p>
<ul>
<li><p>User context 是S3评估AWS父账户（上下文）附加到用户策略的基本策略</p>
</li>
<li><p>Bucket context是S3评估存储桶所有者拥有访问策略的上下文，以检查存储桶所有者是否显式拒绝访问资源</p>
</li>
<li><p>Object context是是S3评估对象所有者拥有的策略的上下文</p>
<h3 id="类比场景"><a href="#类比场景" class="headerlink" title="类比场景"></a>类比场景</h3></li>
<li><p>假设有三个AWS账户，A、B、C且其子用户（IAM user）分别为AA、BA、CA</p>
</li>
<li><p>A账户拥有Toy bucket,其中存储对象Toy AAA,允许对象被删掉和创建</p>
</li>
<li><p>A账户创建一个授权，AA可以访问Toy bucket和其中对象（user policy或Bucket policy或两者都包含）</p>
</li>
<li><p>A创建一个授权（bucket policy），允许B可以创建对象在Toy bucket中；那么B可以授权其BA在Toy bucket中创建对象(如BAA)的策略（user policy）</p>
</li>
<li><p>B可以授权A访问Toy bucket中BAA的权限策略（object acl）</p>
</li>
<li><p>A创建一个授权（bucket policy）访问Toy bucket中AAA（object）的策略，而C又可以授权CA访问AAA的权限策略（user policy）</p>
</li>
<li><p>A 可以授权C访问BAA（object）的权限(IAM role）,而C又可以授权CA访问BAA的权限（user policy）</p>
</li>
</ul>
<h3 id="Bucket-操作授权"><a href="#Bucket-操作授权" class="headerlink" title="Bucket 操作授权"></a>Bucket 操作授权</h3><p><img src="https://i.loli.net/2019/08/19/k6UAI5Cyf87sE1P.jpg" alt="002.jpg"></p>
<ol>
<li>如果请求者是 IAM 用户，则该用户必须拥有来自其所属的父 AWS 账户的权限。在此步骤中，Amazon S3 将评估由父账户 (也称为上下文机构) 拥有的一个策略子集。该策略子集包含父账户附加到该用户的用户策略。如果父级也拥有请求中的资源 (在本例中为存储桶)，则 Amazon S3 还会同时评估相应资源策略 (存储桶策略和存储桶 ACL)。</li>
<li>请求者必须拥有来自存储桶拥有者的权限才能执行特定存储桶操作。在此步骤中，Amazon S3 对由拥有该存储桶的 AWS 账户拥有的策略子集进行评估。</li>
<li>存储桶拥有者可通过使用存储桶策略或存储桶 ACL 来授予权限</li>
</ol>
<h3 id="Object操作授权"><a href="#Object操作授权" class="headerlink" title="Object操作授权"></a>Object操作授权</h3><p> <img src="https://i.loli.net/2019/08/19/skd6nRq1mWagxoB.jpg" alt="003.jpg"></p>
<ol>
<li>如果请求者是 IAM 用户，则该用户必须拥有来自其所属的父 AWS 账户的权限</li>
<li>Amazon S3 会评估由父账户 (也称为上下文机构) 拥有的一个策略子集。该策略子集包含父级附加到该用户的用户策略。如果父级也拥有请求中的资源 (存储桶、对象)，则 Amazon S3 还会同时评估相应资源策略 (存储桶策略、存储桶 ACL 和对象 ACL)</li>
<li>在此上下文中，Amazon S3 评估拥有该存储桶的 AWS 账户所拥有的策略。如果拥有请求中的对象的 AWS 账户与存储桶拥有者不同，则 Amazon S3 会在存储桶上下文中检查策略，查看存储桶拥有者是否已显式拒绝对该对象的访问。如果对该对象设置了显式拒绝，则 Amazon S3不对请求授权。</li>
<li>请求者必须拥有来自对象拥有者的权限才能执行特定对象操作。在此步骤中，Amazon S3将评估对象 ACL</li>
</ol>
<h3 id="权限委派"><a href="#权限委派" class="headerlink" title="权限委派"></a>权限委派</h3><ul>
<li>如果AWS账户拥有资源，则可以将这些权限授予另一个AWS账户。</li>
<li>该帐户可以将这些权限或其中一部分委派给帐户中的用户。 这称为权限委派。</li>
<li>但是，从其他帐户接收权限的帐户无法将权限跨帐户委派给其他AWS账户。</li>
<li>如果Bucket所有者想要将不属于它的Object的权限授予其他AWS账户，则无法通过跨账户权限执行该操作，并且需要定义IAM角色，AWS账户可以采用该角色来获取访问权限</li>
</ul>
<h1 id="S3-Data-Protection"><a href="#S3-Data-Protection" class="headerlink" title="S3 Data Protection"></a>S3 Data Protection</h1><ul>
<li>Amazon S3 为任务关键型和主数据存储提供了高度耐用的存储基础设施。在 Amazon S3 区域，对象以冗余方式存储在多个设施间的多个设备中。</li>
<li>对象冗余地存储在S3区域中的多个设施上的多个设备上</li>
<li>为帮助确保数据持久性，Amazon S3 PUT 和 PUT Object copy 操作会在多个设施间同步完成之后，然后才会返回 SUCCESS</li>
<li>存储对象后，Amazon S3 将通过快速检测和修复任何丢失的冗余数据，保持对象的持久性</li>
<li>S3 还会使用校验和定期验证所存储数据的完整性。如果 Amazon S3 检测到数据损坏，它将使用冗<br>余的数据进行修复</li>
<li>Amazon S3 还会在存储或检索数据时对所有网络流量计算校验和，以检测数据包是否损坏</li>
<li>S3还提供保护传输中的数据（当它往返S3时）和静止存放（当它存储在S3中时）的能力</li>
</ul>
<h2 id="传输中的数据"><a href="#传输中的数据" class="headerlink" title="传输中的数据"></a>传输中的数据</h2><ul>
<li>通过SSL或使用客户端加密进行通信来保护传输中的数据</li>
</ul>
<h2 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h2><ul>
<li>支持客户端加密和服务器端加密，以保护静态数据</li>
<li>服务器端加密关乎静态数据加密，即 Amazon S3 将数据写入数据中心内的磁盘时会在对象级别上加密这些数据，并在访问这些数据时解密这些数据</li>
<li>使用客户端加密，可以加密客户端数据并将加密数据上传到S3。 在这种情况下，自行管理加密过程，加密密钥和相关工具</li>
</ul>
<h2 id="Server-side-加密"><a href="#Server-side-加密" class="headerlink" title="Server-side 加密"></a>Server-side 加密</h2><ul>
<li>服务器端加密关于静态数据加密</li>
<li>服务器端加密仅加密对象数据,对象元数据是不加密的</li>
<li>S3处理数据对象的加密（写入磁盘时）和解密（访问对象时）</li>
<li>加密或未加密对象的访问机制没有区别，并由S3透明处理</li>
</ul>
<h2 id="Server-Side-Encryption-with-Amazon-S3-Managed-Keys-SSE-S3"><a href="#Server-Side-Encryption-with-Amazon-S3-Managed-Keys-SSE-S3" class="headerlink" title="Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)"></a>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)</h2><ul>
<li><p>Amazon S3 托管加密密钥的服务器端加密 (SSE-S3) 采用了多因素强加密。S3 使用唯一的密钥来加密每个对象。作为额外的保护，它将使用定期轮换的主密钥对密钥本身进行加密。</p>
</li>
<li><p>S3 服务器端加密使用可用的最强数据块密码之一 (即 256 位高级加密标准 (AES-256))来加密数据</p>
</li>
<li><p>当使用预签名url上传对象时，不能强制使用SSE-S3加密对象，因为指定服务器端加密的惟一方法是通过AWS管理控制台或HTTP请求头<br>Server-Side Encryption with AWS KMS-Managed Keys (SSE-KMS)<br><img src="https://i.loli.net/2019/08/19/3Ekn2RjTqsCFVUW.jpg" alt="004.jpg"></p>
</li>
<li><p>SSE-KMS类似于SSE-S3，但它使用AWS Key Management Services（KMS），它提供额外的优势和性价比</p>
<ul>
<li>AWS Key Management Service (AWS KMS) 是一项将安全、高度可用的硬件和软件结合起来，提供可扩展到云的密钥管理系统的服务</li>
<li>KMS 使用用户主密钥 (CMK) 加密Amazon S3 对象</li>
<li>主密钥（master key）从不使用</li>
<li>KMS集中创建加密密钥，定义控制密钥使用方式的策略</li>
<li>通过检查AWS CloudTrail中的日志，审计使用密钥用法是否正确使用</li>
<li>允许临时禁用和重新启用密钥</li>
<li>允许key进行定期轮换</li>
<li>AWS KMS中的安全控制有助于满足与加密相关的合规性要求</li>
</ul>
</li>
<li><p>SSE-KMS为使用信封密钥（即保护数据加密密钥的密钥）启用单独的权限，从而提供额外的保护，防止在S3中对对象进行未经授权的访问</p>
</li>
<li><p>SSE-KMS提供了创建和管理加密密钥的选项，或者默认使用客户主密钥(CMK)，该主密钥可用于当前服务，并且所工作的区域是惟一的</p>
</li>
<li><p>创建自定义的CMK可提供更大灵活性，包括创建、轮换、禁用和定义访问控制，以及审核用于保护数据的加密密钥的能力</p>
</li>
<li><p>用于加密数据的数据密钥也会加密并与它们保护的数据一起存储，并且对每个对象都是唯一的</p>
</li>
<li><p>处理流程</p>
<ul>
<li>应用程序或AWS服务客户端请求加密密钥来加密数据，并将引用传递给帐户下的主密钥</li>
<li>验证客户端请求是否有权使用主密钥进行加密</li>
<li>创建新的<table><tr><td bgcolor="orange">数据加密密钥</td></tr></table>，并在<table><tr><td bgcolor="red">主密钥（CMK）</td></tr></table>下加密<table><tr><td bgcolor="orange">数据加密密钥</td></tr></table>（经过授权）</li>
<li>数据密钥和加密数据密钥都返回给客户端</li>
<li>数据密钥用于加密客户数据，建议在实际使用完加密密钥之后尽快将其从内存中删除</li>
<li>保留<table><tr><td bgcolor="orange">加密数据密钥</td></tr></table>以供以后使用，并在需要解密数据时将其发送回AWS KMS进行解密获取数据密钥<br>Server-Side Encryption with Customer-Provided Keys (SSE-C)<br><img src="https://i.loli.net/2019/08/19/KT7oy4njN6IH9Fb.jpg" alt="005.jpg"></li>
</ul>
</li>
<li><p>使用客户提供的加密密钥的服务器端加密 (SSE-C) 允许设置自己的加密密钥。</p>
</li>
<li><p>S3在访问对象时管理加密，写入磁盘和解密载对象时，加密密钥作为请求的一部分提供，S3使用该加密密钥对数据应用AES-256加密，并从内存中删除加密密钥</p>
</li>
<li><p>在检索对象时，必须提供相同的加密密钥作为请求的一部分。Amazon S3 在将对象数据返回之前，会首先验证提供的加密密钥是否匹配，然后再解密对象</p>
</li>
<li><p>每个对象，每个对象的版本可以使用不同的密钥进行加密，但需要自行负责维护对象和所使用的加密密钥之间的映射。</p>
</li>
<li><p>SSE-C请求必须通过HTTPS完成，S3将拒绝使用SSE-C时通过http发出的任何请求</p>
</li>
<li><p>出于安全原因，错误地使用 http 发送的任何密钥都将存在被外泄的可能性。此时应丢弃该密钥，并根据需要轮换密钥</p>
</li>
<li><p>S3 不存储加密密钥，而是存储加密密钥添加了随机数据的 HMAC 值来验证请求。无法使用添加了随机数据的 HMAC 值来推导出加密密钥的值或解密加密对象的内容。这意味着，如果丢失加密密钥，则会失去该对象</p>
</li>
</ul>
<h2 id="客户端加密"><a href="#客户端加密" class="headerlink" title="客户端加密"></a>客户端加密</h2><p>客户端加密是指在将数据发送到Amazon S3之前加密数据并在下载之后解密数据。</p>
<h2 id="使用-AWS-KMS-托管客户主密钥-CMK"><a href="#使用-AWS-KMS-托管客户主密钥-CMK" class="headerlink" title="使用 AWS KMS 托管客户主密钥 (CMK)"></a>使用 AWS KMS 托管客户主密钥 (CMK)</h2><ul>
<li>客户可以使用 AWS KMS 托管客户主密钥用于客户端数据加密时，此时使 AWS KMS 客户主密钥 ID (CMK ID)</li>
<li>上传对象时<ul>
<li>客户端首先将请求发送到 AWS Key Management Service (AWS KMS)以获取可用于加密对象数据的密钥</li>
<li>AWS KMS 将返回一个随机生成的数据加密密钥，其中包含客户端用于<table><tr><td bgcolor="orange">加密对象数据的纯文本版本</td></tr></table>和客户端将作为对象元数据上传到 Amazon S3 的<table><tr><td bgcolor="orange">同一数据加密密钥的密码 blob</td></tr></table></li>
<li>客户端将为其上传的每个对象获取一个唯一的数据加密密钥</li>
<li>AWS S3加密的客户端上载与对象元数据的加密数据和加密BLOB</li>
</ul>
</li>
<li>下载对象时<ul>
<li>客户端首先从 Amazon S3 下载加密的对象以及作为对象元数据存储的数据加密密钥的密blob 版本</li>
<li>客户端将密码 blob 发送到 AWS KMS 以获取密钥的纯文本版本，以便让客户端解密对象数据<br>使用客户端主密钥</li>
</ul>
</li>
<li>加密主密钥完全在客户端维护</li>
<li>上传对象时<ol>
<li>Amazon S3 加密客户端在本地生成一个一次性对称密钥 (也称为“数据加密密钥”或“数据密钥”)。它使用数据密钥加密单个 Amazon S3 对象的数据。该客户端将为每个对象生成一个单独的数据密钥。</li>
<li>该客户端使用主密钥来加密数据加密密钥。客户端会将加密的数据密钥及其材料说明作为对象元数据的一部分上传。</li>
<li>该客户端将加密数据上传到 Amazon S3 并在 Amazon S3 中将加密数据密钥保存为对象元数据 (xamz-meta-x-amz-key)</li>
</ol>
</li>
<li>下载对象时<ul>
<li>该客户端从 Amazon S3 下载加密的对象。</li>
<li>通过对象元数据中的说明，该客户端将确定要用于解密数据密钥的主密钥</li>
<li>该客户端将使用该主密钥解密数据密钥，然后使用该数据密钥对对象进行解密</li>
</ul>
</li>
<li>客户端主密钥和未加密的数据从来不会发送到 AWS。务必安全地管理加密密钥</li>
<li>如果丢失了加密密钥，将无法解密数据</li>
</ul>
<h1 id="S3-最佳实践"><a href="#S3-最佳实践" class="headerlink" title="S3 最佳实践"></a>S3 最佳实践</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="并发PUTS-GETS"><a href="#并发PUTS-GETS" class="headerlink" title="并发PUTS/GETS"></a>并发PUTS/GETS</h3><ul>
<li>Amazon S3 可进行扩展，以支持非常高的请求速率。如果请求速率稳定增长，则 Amazon S3 会自动根据需要将存储桶进行分区，以支持更高的请求速率</li>
<li>如果典型工作负载仅涉及每秒100个请求的偶尔突发和每秒少于800个请求，则AWS会自动进行扩展和处理</li>
<li>如果预计存储桶的请求速率会快速提高到超过每秒 300 个 PUT/LIST/DELETE 请求或超过每秒 800 个 GET 请求，建议申请support,以便为工作负载做好准备，并且避免对请求速率的任何临时限制</li>
<li>仅当每秒定期处理100个或更多请求时，才能应用S3最佳实践指南</li>
<li>混合请求类型的工作负载<ul>
<li>如果请求一般为 GET、PUT、DELETE 或 GET Bucket (列出对象) 的组合，则为对象合理选择键名称可缩短访问 Amazon S3 索引的延迟，从而确保实现更高的性能</li>
<li>这种方式是由S3 存储key驱动的<ul>
<li>Amazon S3 在每个 AWS 区域维护对象键名称的索引</li>
<li>对象键以 UTF-8 二进制顺序保存在索引的多个分区中，键名称指示用于存储键的分区</li>
<li>对于大量键，使用顺序前缀 (如时间戳或字母顺序) 可增大 Amazon S3以特定分区为目标的可能性，从而耗尽该分区的 I/O 容量。</li>
</ul>
</li>
<li>如果在键名称前缀中引入某种随机性，则键名称 (以及 I/O 负载) 会在多个分区间分布</li>
<li>无论每秒发送的请求数量如何，它还可确保可扩展性</li>
</ul>
</li>
<li>GET 密集型工作负载<ul>
<li>建议使用 Amazon CloudFront 内容传输服务</li>
<li>向用户分发内容时同时实现低延迟和高数据传输速率。另外可以减少向 Amazon S3 发送直接请求，从而降低成本</li>
<li>支持Web分发或RTMP分发<h3 id="PUTs-GETs-for-Large-Objects"><a href="#PUTs-GETs-for-Large-Objects" class="headerlink" title="PUTs/GETs for Large Objects"></a>PUTs/GETs for Large Objects</h3></li>
</ul>
</li>
<li>AWS支持并行化PUT / GET请求以提高上载和下载性能以及在失败时恢复的能力</li>
<li>对于上传，分段上传可以帮助改善上传体验<ul>
<li>同时执行多个上载并最大化网络带宽利用率</li>
<li>从故障中快速恢复，因为只有一部分上传失败需要重新上传</li>
<li>暂停和恢复上传的能力</li>
<li>在已知对象大小之前开始上载</li>
</ul>
</li>
<li>对于GET，range http标头可以帮助提高下载<ul>
<li>允许在部分而不是整个对象中检索对象</li>
<li>从故障中快速恢复，因为只有无法下载的部分需要重试</li>
</ul>
</li>
</ul>
<h2 id="List-Operations"><a href="#List-Operations" class="headerlink" title="List Operations"></a>List Operations</h2><ul>
<li>对象键(key)以字典顺序存储在Amazon S3索引中，因此很难对LIST的内容进行排序和操作</li>
<li>S3维护单个按字典顺序排序的索引列表</li>
<li>在S3之外构建和维护二级索引，例如 DynamoDB或RDS用于存储，索引和查询对象元数据，而不是在S3上执行操作</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>开启版本控制<ul>
<li>防止意外的覆盖和删除</li>
<li>允许检索和恢复已删除对象或回滚到以前版本的功能</li>
</ul>
</li>
<li>启用MFA（多重身份验证）删除来启用安全性</li>
<li>版本控制不会阻止Bucket删除，必须进行备份，就像意外或恶意删除数据一样</li>
<li>使用跨区域复制功能将数据备份到其他区域</li>
<li>将VPC与S3一起使用时，建议使用VPC S3端点<ul>
<li>是水平缩放，冗余和高可用性的VPC组件</li>
<li>帮助在VPC和S3之间建立专用连接，流量永远不会离开AWS网络</li>
</ul>
</li>
</ul>
<h2 id="Traking"><a href="#Traking" class="headerlink" title="Traking"></a>Traking</h2><ul>
<li>使用事件通知来通知S3put或delete请求</li>
<li>使用CloudTrail，便于 AWS账户捕获特定的API调用，并提供日志文件到一个S3桶</li>
<li>使用CloudWatch监控Amazon S3存储桶，跟踪存储的对象计数和字节等指标，并配置相应的操作</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">seven</p>
              <p class="site-description motion-element" itemprop="description">seven 的精神家园，学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="1988xuegang@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">seven</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
