<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="seven 的精神家园，学习笔记">
<meta name="keywords" content="云计算,大数据，kuberntes">
<meta property="og:type" content="website">
<meta property="og:title" content="岳阳北寒">
<meta property="og:url" content="http://sevengarden.club/index.html">
<meta property="og:site_name" content="岳阳北寒">
<meta property="og:description" content="seven 的精神家园，学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="岳阳北寒">
<meta name="twitter:description" content="seven 的精神家园，学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://sevengarden.club/">





  <title>岳阳北寒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">岳阳北寒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">要有最朴素的生活和最遥远的梦想，即使明日天寒地冻，路远马亡.......</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-somrthing">
          <a href="/有料" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            somrthing
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/28/AWS-Elastic-LoadBalancer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/AWS-Elastic-LoadBalancer/" itemprop="url">AWS Elastic LoadBalancer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T21:08:05+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Elastic Load Balancing 在多个目标（如 Amazon EC2 实例、容器、IP 地址和 Lambda 函数）之间自动分配传入的应用程序流量</li>
<li>ELB作为客户侧访问的单一入口</li>
<li>ELB通过允许在一个或多个可用区域中添加或删除多个EC2实例来帮助透明并提高应用程序可用性，而不会中断业务流量</li>
<li>ELB的优势<ul>
<li>自身设计是一个高度容错和自动监控的分布式系统</li>
<li>简化管理、维护和扩展负载均衡的复杂性</li>
<li>可以是抵御网络攻击的第一道防线</li>
<li>可以卸载加密和解密（SSL终止）的工作，以便于EX2实例专注于自身负载</li>
<li>与Auto Scaling集成，可确保有足够的后端容量，以满足不同的流量压力</li>
<li>非单点故障</li>
</ul>
</li>
<li>默认情况下，Elastic Load Balancer将每个请求独立地路由到具有最小负载的已注册实例。</li>
<li>如果EC2实例失败，ELB会自动将流量重新路由到剩余正在运行的健康EC2实例。 如果还原失败的EC2实例，Elastic Load Balancing将恢复该实例的流量。</li>
<li>负载均衡器仅适用于区域内的AZ</li>
</ul>
<p><img src="https://i.loli.net/2019/08/28/bieqrjDdSkMzvo6.png" alt="screen-shot-2016-04-05-at-7-54-34-am.png"></p>
<h1 id="AWS-ELB-Application-Load-Balancer"><a href="#AWS-ELB-Application-Load-Balancer" class="headerlink" title="AWS ELB Application Load Balancer"></a>AWS ELB Application Load Balancer</h1><blockquote>
<p>Application Load Balancer 运行于请求级别（第 7 层），可根据请求的内容将流量路由至 EC2 实例、容器、IP 地址和 Lambda 函数等目标。Application Load Balancer 最适合 HTTP 和 HTTPS 流量的高级负载均衡，面向交付包括微服务和基于容器的应用程序在内的现代应用程序架构，提供高级请求路由功能。Application Load Balancer 通过确保始终使用最新的 SSL/TLS 密码和协议，简化并提高应用程序的安全性。</p>
</blockquote>
<p><img src="https://i.loli.net/2019/08/28/S57BoUwFTL2Rpcn.png" alt="img2.png"></p>
<h2 id="Application-Load-Balancer-Benefits"><a href="#Application-Load-Balancer-Benefits" class="headerlink" title="Application Load Balancer Benefits"></a>Application Load Balancer Benefits</h2><ul>
<li>支持基于路径的路由，可以根据请求中的URL将侦听器规则配置为转发请求。</li>
<li>通过使用多个端口注册实例，支持将请求路由到单个EC2实例上的多个服务。</li>
<li>支持容器化应用程序。 EC2容器服务（ECS）可以在计划任务时选择未使用的端口，并使用此端口向目标组注册任务，从而有效地使用群集。</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查，并在目标组级别报告了许多CloudWatch指标。 通过将目标组附加到Auto Scaling组，可以根据需求动态扩展每个服务。</li>
</ul>
<h2 id="Application-Load-Balancer-Features"><a href="#Application-Load-Balancer-Features" class="headerlink" title="Application Load Balancer Features"></a>Application Load Balancer Features</h2><ul>
<li>支持使用HTTP和HTTPS协议对应用程序进行负载平衡</li>
<li>支持HTTP/2，本机启用。支持HTTP/2的客户端可以通过TLS连接</li>
<li>支持WebSockets和Secure WebSockets</li>
<li>默认情况下，支持请求追踪</li>
<li>支持使用负载均衡器生成的cookie的粘滞会话（会话关联），将来自同一客户端的请求路由到同一目标</li>
<li>支持SSL终止，在将请求发送到后端目标之前解密ALB上的请求</li>
<li>支持第7层特​​定功能，如X-Forwarded-For标头，以帮助确定实际的客户端IP，端口和协议</li>
<li>随着请求容量自动伸缩调整其负载大小</li>
<li>支持跨AZ部署，提高高可用性和传入流量分布</li>
<li>与ACM集成以提供SSL / TLS证书并将其绑定到负载均衡器，从而使整个SSL卸载过程变得非常容易</li>
<li>支持IPv6,面向internet的负载均衡</li>
<li>支持请求追踪，自定义标识符“X-Amzn-Trace-Id”HTTP头标注在所有请求上，以帮助跟踪各种服务的请求流</li>
<li>支持安全组来控制允许进出负载均衡器的流量</li>
<li>提供访问日志，记录发送到负载均衡器的所有请求，并将日志存储在S3中，以便以压缩格式进行后续分析</li>
<li>支持连接空闲超时 -  ALB为每个请求维护两个连接，一个连接客户端（前端），另一个连接目标实例（后端）。如果在空闲超时时间过去之前没有发送或接收数据，则ALB关闭前端连接</li>
<li>支持使用循环算法的慢启动模式，允许添加新目标但不会用大量请求占用新目标</li>
<li>与CloudWatch集成以提供请求计数，错误计数，错误类型和请求延迟等指标</li>
<li>与AWS WAF集成，这是一种Web应用程序防火墙，允许通过允许基于IP地址，HTTP标头和自定义URI字符串的规则配置来保护Web应用程序免受攻击</li>
<li>与CloudTrail集成以接收在AWS账户上进行的ALB API调用的历史记录</li>
</ul>
<h2 id="Application-Load-Balancer-Listeners"><a href="#Application-Load-Balancer-Listeners" class="headerlink" title="Application Load Balancer Listeners"></a>Application Load Balancer Listeners</h2><ul>
<li>侦听器是使用配置的协议和端口检查连接请求的进程</li>
<li>支持HTTP和HTTPS协议，端口好范围1-65535</li>
<li>ALB支持HTTPS侦听器的SSL终止，这有助于卸载加密和解密工作，以便目标可以专注于其主要工作。</li>
<li>HTTPS侦听器在侦听器上仅支持一个SSL服务器证书。</li>
<li>具有HTTP和HTTPS侦听器的WebSockets（安全WebSockets）</li>
<li>支持HTTP/2和HTTPS侦听器<ul>
<li>一个HTTP/2连接可以并发128个请求</li>
<li>ALB将这些请求转换为单独的HTTP / 1.1请求，并使用循环路由算法将它们分布到目标组中的健康目标上。</li>
<li>HTTP / 2更有效地使用前端连接，从而减少客户端与负载均衡器之间的连接。</li>
<li>不支持HTTP / 2的服务器推送功能</li>
</ul>
</li>
<li>侦听器都有一个默认规则，可以自定义其他规则</li>
<li>每个规则都包含优先级，动作，可选主机条件和可选路径条件<ul>
<li>优先级——按优先级顺序评估规则，从最低值到最高值。 默认规则具有最低优先级</li>
<li>动作——每个规则操作都有一个类型和一个目标组。 目前，唯一支持的类型是forward，它将请求转发给目标组。 可以随时更改规则的目标组。</li>
<li>条件——有两种类型的规则条件：主机和路径。 当满足规则的条件时，则采取其行动</li>
</ul>
</li>
<li>主机条件或基于主机的路由<ul>
<li>主机条件可用于定义根据主机头中的主机名将请求转发到不同目标组的规则</li>
<li>这使得能够使用单个ALB支持多个域，例如， orders.example.com，images.example.com，registration.example.com</li>
<li>每个主机条件都有一个主机名。</li>
</ul>
</li>
<li>路径条件或基于路径的路由<ul>
<li>路径条件可用于定义根据请求中的URL将请求转发到不同目标组的规则 </li>
<li>每个路径条件具有一个路径模式，例如， example.com/orders,example.com/images,example.com/registration</li>
<li>如果请求中的URL与侦听器规则中的路径模式完全匹配，则使用该规则路由请求。</li>
</ul>
</li>
</ul>
<h2 id="相比CLB的优势"><a href="#相比CLB的优势" class="headerlink" title="相比CLB的优势"></a>相比CLB的优势</h2><ul>
<li>支持基于路径的路由，其中​​可以配置规则以使侦听器基于URL转发请求</li>
<li>支持基于主机的路由，其中​​可以为侦听器配置规则，以根据HTTP标头中的主机字段转发请求。</li>
<li>支持将请求路由到单个EC2实例上的多个应用程序。可以使用多个端口向同一目标组注册每个实例或IP地址</li>
<li>支持按IP地址注册目标，包括负载均衡器的VPC外部目标。</li>
<li>使用动态端口映射为ECS支持容器化应用程序</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查和许多CloudWatch指标</li>
<li>将目标组附加到Auto Scaling组可以根据需求动态扩展每个服务</li>
<li>访问日志包含其他信息并以压缩格式存储</li>
<li>提高负载均衡器性能</li>
</ul>
<h1 id="AWS-ELB-Network-Load-Balancer"><a href="#AWS-ELB-Network-Load-Balancer" class="headerlink" title="AWS ELB Network Load Balancer"></a>AWS ELB Network Load Balancer</h1><ul>
<li>网络负载均衡器运行于连接级别（第 4 层），可根据 IP 协议数据将连接路由至Amazon VPC内的不同目标（Amazon EC2 实例、微服务和容器）</li>
<li>网络负载均衡器最适合 TCP 和 UDP 流量的负载均衡，能够在保持超低延迟的同时每秒处理数百万个请求</li>
<li>网络负载均衡器还经过了优化，能够处理突发的和不稳定的流量模式，同时在每个可用区使用单个静态 IP 地址</li>
<li>集成了其他常见的 AWS 服务，例如 Auto Scaling、Amazon EC2 Container Service (ECS)、Amazon CloudFormation 和 Amazon AWS Certificate Manager (ACM)</li>
</ul>
<h2 id="Network-Load-Balancer-Features"><a href="#Network-Load-Balancer-Features" class="headerlink" title="Network Load Balancer Features"></a>Network Load Balancer Features</h2><h3 id="基于连接的负载均衡"><a href="#基于连接的负载均衡" class="headerlink" title="基于连接的负载均衡"></a>基于连接的负载均衡</h3><ul>
<li>可以对 TCP 和 UDP 流量执行负载均衡，将连接路由到不同的目标 – Amazon EC2 实例、微服务和容器。</li>
</ul>
<h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><ul>
<li>网络负载均衡器具有高可用性。</li>
<li>它接受来自客户端的传入流量，并在同一可用区内的目标之间分配此流量。</li>
<li>负载均衡器还监控其已注册目标的运行状况，并确保它仅将流量路由到正常运行的目标。</li>
<li>当负载均衡器检测到无法正常运行的目标时，它会停止将流量路由到该目标，并将流量重新路由到剩余的正常运行的目标。如果一个可用区中的所有目标全都无法正常运行，但已在另一个可用区中设置了目标，则网络负载均衡器将自动进行故障转移以将流量路由到其他可用区中正常运行的目标。</li>
</ul>
<h3 id="高吞吐量"><a href="#高吞吐量" class="headerlink" title="高吞吐量"></a>高吞吐量</h3><ul>
<li>网络负载均衡器旨在处理不断增长的流量，并可以对每秒数百万个请求进行负载均衡。它还可以处理突发的不稳定流量模式。</li>
</ul>
<h3 id="低延迟"><a href="#低延迟" class="headerlink" title="低延迟"></a>低延迟</h3><ul>
<li>网络负载均衡器为延迟敏感的应用程序提供极低的延迟。</li>
</ul>
<h3 id="保留源-IP-地址"><a href="#保留源-IP-地址" class="headerlink" title="保留源 IP 地址"></a>保留源 IP 地址</h3><ul>
<li>网络负载均衡器保留客户端源 IP，允许后端查看客户端的 IP 地址。然后，应用程序可以将其用于进一步处理。</li>
</ul>
<h3 id="静态-IP-支持"><a href="#静态-IP-支持" class="headerlink" title="静态 IP 支持"></a>静态 IP 支持</h3><ul>
<li>网络负载均衡器自动提供每个可用区（子网）的静态 IP，应用程序可将其用作负载均衡器的前端 IP。</li>
</ul>
<h3 id="弹性-IP-支持"><a href="#弹性-IP-支持" class="headerlink" title="弹性 IP 支持"></a>弹性 IP 支持</h3><ul>
<li>网络负载均衡器还允许为每个可用区（子网）分配弹性 IP，从而提供自己的固定 IP。</li>
</ul>
<h3 id="TLS-卸载"><a href="#TLS-卸载" class="headerlink" title="TLS 卸载"></a>TLS 卸载</h3><ul>
<li>网络负载均衡器支持在客户端和负载均衡器之间终止 TLS。</li>
<li>除了为在完成客户端与负载均衡器之间的 TLS 握手时首选的密码和协议提供灵活性的预定义安全策略外，网络负载均衡器还提供通过 AWS Identity and Access Management (IAM) 和 AWS Certificate Manager 管理 SSL 证书的功能。</li>
<li>在网络负载均衡器上终止 TLS 后，源 IP 地址将继续保留在的后端应用程序中。</li>
</ul>
<h3 id="运行状况检查"><a href="#运行状况检查" class="headerlink" title="运行状况检查"></a>运行状况检查</h3><ul>
<li>网络负载均衡器支持网络和应用程序目标运行状况检查。</li>
<li>网络级健康检查<ul>
<li>基于底层目标（实例或容器）对正常流量的总体响应。</li>
<li>如果目标很慢或无法响应新的连接请求，则标记为不可用</li>
</ul>
</li>
<li>应用程序级健康检查<ul>
<li>通过定期探测给定目标上的特定 URL，它可以集成实际应用程序的运行状况</li>
</ul>
</li>
</ul>
<h3 id="DNS-故障转移"><a href="#DNS-故障转移" class="headerlink" title="DNS 故障转移"></a>DNS 故障转移</h3><ul>
<li>如果没有向网络负载均衡器注册的正常运行的目标，或者给定区域中的网络负载均衡器节点无法正常运行，则 Amazon Route 53 会将流量定向到其他可用区中的负载均衡器节点。</li>
</ul>
<h3 id="与-Amazon-Route-53-集成"><a href="#与-Amazon-Route-53-集成" class="headerlink" title="与 Amazon Route 53 集成"></a>与 Amazon Route 53 集成</h3><ul>
<li>如果的网络负载均衡器无法响应，则与 Route 53 的集成将从服务中删除不可用的负载均衡器 IP 地址，并将流量定向到另一个区域中的备用网络负载均衡器。</li>
</ul>
<h3 id="与-AWS-服务集成"><a href="#与-AWS-服务集成" class="headerlink" title="与 AWS 服务集成"></a>与 AWS 服务集成</h3><ul>
<li>网络负载均衡器已与其他 AWS 服务集成，例如 Auto Scaling、Elastic Container Service (ECS)、CloudFormation、Elastic BeanStalk、CloudWatch、Config、CloudTrail、CodeDeploy 和 AWS Certificate Manager (ACM)。</li>
</ul>
<h3 id="长时间运行的-TCP-连接"><a href="#长时间运行的-TCP-连接" class="headerlink" title="长时间运行的 TCP 连接"></a>长时间运行的 TCP 连接</h3><p>网络负载均衡器支持长时间运行的 TCP 连接，这是 WebSocket 类型的应用程序的理想选择。</p>
<h3 id="集中-API-支持"><a href="#集中-API-支持" class="headerlink" title="集中 API 支持"></a>集中 API 支持</h3><ul>
<li>网络负载均衡器使用与 Application Load Balancer 相同的 API。这将使能够在同一 Amazon EC2 实例上的多个端口之间使用目标组、运行状况检查和负载均衡，以支持容器化应用程序。</li>
</ul>
<h3 id="可靠的监控和审核"><a href="#可靠的监控和审核" class="headerlink" title="可靠的监控和审核"></a>可靠的监控和审核</h3><ul>
<li>Amazon CloudWatch 报告网络负载均衡器指标。CloudWatch 提供诸如活动流计数、正常运行的主机计数、新流计数、已处理的字节等指标。网络负载均衡器还与 AWS CloudTrail 集成。CloudTrail 跟踪对网络负载均衡器的 API 调用。</li>
</ul>
<h3 id="增强的日志记录"><a href="#增强的日志记录" class="headerlink" title="增强的日志记录"></a>增强的日志记录</h3><ul>
<li>可以使用流日志功能记录发送到负载均衡器的所有请求。</li>
<li>流日志捕获有关进出 VPC 中网络接口的 IP 流量的信息。流日志数据使用 Amazon CloudWatch Logs 进行存储。</li>
<li>在的网络负载均衡器上添加 TLS 侦听器后，可以选择启用“访问日志”功能，这些访问日志将发送到选择的 S3 存储桶中。“访问日志”会捕获有关侦听器接收的每个 TLS 连接的信息，可从中了解成功和失败的 TLS 握手情况。</li>
</ul>
<h3 id="区域隔离"><a href="#区域隔离" class="headerlink" title="区域隔离"></a>区域隔离</h3><ul>
<li>网络负载均衡器专为单个区域中的应用程序架构而设计。</li>
<li>如果可用区中的某些内容失败，我们将自动故障转移到其他正常运行的可用区。</li>
<li>虽然我们建议客户在多个可用区中配置负载均衡器和目标以实现高可用性，但可以在单个可用区中启用网络负载均衡器，以支持需要区域隔离的架构。</li>
</ul>
<h3 id="使用IP地址作为目标进行负载平衡"><a href="#使用IP地址作为目标进行负载平衡" class="headerlink" title="使用IP地址作为目标进行负载平衡"></a>使用IP地址作为目标进行负载平衡</h3><ul>
<li>允许使用应用程序后端的IP地址作为目标，对AWS或本地托管的任何应用程序进行负载平衡。</li>
<li>允许负载平衡到托管在任何IP地址和实例上任何接口上的应用程序后端。</li>
<li>跨AWS和本地资源实现负载均衡的能力有助于迁移到云，突发到云或故障转移到云</li>
<li>托管在本地位置的应用程序可用作Direct Connect连接和EC2-Classic（使用ClassicLink）的目标。</li>
</ul>
<h2 id="相比CLB的优势-1"><a href="#相比CLB的优势-1" class="headerlink" title="相比CLB的优势"></a>相比CLB的优势</h2><ul>
<li>能够处理不稳定的工作负载并扩展到每秒数百万个请求，而无需预热</li>
<li>支持负载均衡器的静态IP /弹性IP地址</li>
<li>支持按IP地址注册目标，包括负载均衡器的VPC（内部部署）之外的目标。</li>
<li>支持将请求路由到单个EC2实例上的多个应用程序。 可以使用多个端口向同一目标组注册单个实例或IP地址。</li>
<li>支持容器化应用程序。 使用动态端口映射，ECS可以在计划任务时选择未使用的端口，并使用此端口向目标组注册任务。</li>
<li>支持独立监控每项服务的运行状况，因为在目标组级别定义了运行状况检查，并在目标组级别报告了许多CloudWatch指标。 将目标组附加到Auto Scaling组可以根据需求动态扩展每个服务</li>
</ul>
<h1 id="ELB-主要功能"><a href="#ELB-主要功能" class="headerlink" title="ELB 主要功能"></a>ELB 主要功能</h1><h2 id="Scaling-ELB"><a href="#Scaling-ELB" class="headerlink" title="Scaling ELB"></a>Scaling ELB</h2><ul>
<li>每个ELB都分配并配置了默认容量</li>
<li>ELB Controller 存储了所有配置信息，还监视负载均衡器并管理用于处理客户端请求的容量</li>
<li>随着流量配置文件的更改，控制器服务会扩展负载平衡器以处理更多请求，并在所有AZ中进行相同的扩展</li>
<li>ELB通过利用更大的资源（向上扩展 - 具有更高性能特征的资源）或更多独立资源（向外扩展）来增加其容量</li>
<li>AWS本身处理ELB容量的扩展，并且此扩展与ELB将其请求路由到的EC2实例的扩展不同，这由Auto Scaling处理</li>
<li>Elastic Load Balancing扩展所需的时间范围为1到7分钟，具体取决于流量配置文件中的更改</li>
</ul>
<h2 id="预热-ELB"><a href="#预热-ELB" class="headerlink" title="预热 ELB"></a>预热 ELB</h2><ul>
<li>ELB最适合逐渐增加流量</li>
<li>AWS能够自动扩展并处理绝大多使用场景</li>
<li>但是，在某些情况下，如果预计存在流量峰值或无法将负载测试配置为逐渐增加流量，建议联系AWS支持以使负载均衡器“预热”</li>
<li>AWS将通过将负载均衡器配置为具有基于预期流量的适当容量级别来帮助预热ELB</li>
<li>AWS需要有关开始日期，结束日期和每秒预期请求率的信息以及请求/响应的总大小</li>
</ul>
<h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><ul>
<li>ELB根据流量配置文件自动缩放</li>
<li>缩放时，Elastic Load Balancing服务将更新负载均衡器的域名系统（DNS）记录，以便新资源在DNS中注册其各自的IP地址。</li>
<li>创建的DNS记录包括60秒的生存时间（TTL）设置</li>
<li>默认情况下，当客户端执行DNS解析时，ELB将返回多个IP地址，并在每个DNS解析请求上随机排序记录。</li>
<li>建议客户端至少每60秒重新查找DNS，以利用增加的容量</li>
</ul>
<h2 id="负载均衡类型"><a href="#负载均衡类型" class="headerlink" title="负载均衡类型"></a>负载均衡类型</h2><ul>
<li>面向internet（具有公共IP地址）<ul>
<li>面向Internet的负载均衡器通过Internet从客户端接收请求，并将这些请求分发到使用负载均衡器注册的EC2实例</li>
</ul>
</li>
<li>内部负载均衡（只有私有IP地址）<ul>
<li>将流量路由到私有子网中的EC2实例</li>
</ul>
</li>
</ul>
<h2 id="可用区-子网"><a href="#可用区-子网" class="headerlink" title="可用区/子网"></a>可用区/子网</h2><ul>
<li>Elastic Load Balancing允许添加子网，并在子网所在的每个可用区中创建负载均衡器节点</li>
<li>ELB至少连接一个子网</li>
<li>每个AZ只能有一个子网连接到ELB。 连接已附加AZ的子网将替换现有子网</li>
<li>每个子网必须具有至少具有/ 27位掩码的CIDR块，并且至少具有8个空闲IP地址，ELB使用这些IP地址与后端实例建立连接</li>
<li>对于高可用性，建议为每个AZ附加一个子网，至少两个AZ，即使实例位于一个子网中</li>
<li>子网可以与ELB连接或分离，它将启动或停止向子网中的实例发送请求</li>
</ul>
<h2 id="安全组和NACL"><a href="#安全组和NACL" class="headerlink" title="安全组和NACL"></a>安全组和NACL</h2><ul>
<li>安全组和NACL应允许来自客户端的负载均衡器侦听器端口上的入站流量用于Internet ELB或VPC CIDR用于内部ELB</li>
<li>安全组和NACL应允许实例侦听器端口和运行状况检查端口上的后端实例的出站流量</li>
<li>此外，nacl应该允许在临时端口上响应</li>
<li>所有EC2实例都应该允许来自ELB的传入流量</li>
</ul>
<h2 id="SSL协商配置"><a href="#SSL协商配置" class="headerlink" title="SSL协商配置"></a>SSL协商配置</h2><ul>
<li>对于HTTPS负载平衡器，Elastic Load Balancing使用安全套接字层（SSL）协商配置（称为安全策略）来协商客户端和负载均衡器之间的SSL连接。<br>安全策略是SSL协议，SSL密码和服务器顺序首选项选项的组合</li>
<li>Elastic Load Balancing支持以下版本的SSL协议TLS 1.2，TLS 1.1，TLS 1.0，SSL 3.0，SSL 2.0（现已弃用）<br>SSL协议使用多个SSL密码来加密Internet上的数据。</li>
<li>Elastic Load Balancing支持Server Order Preference选项，用于协商客户端和负载均衡器之间的连接。<br>在SSL连接协商过程中，这允许负载均衡器控制并选择其列表中位于客户端密码列表中的第一个密码，而不是检查客户端列表中的第一个密码与服务器列表匹配的默认行为。</li>
<li>Elastic Load Balancer允许使用预定义的安全策略或为特定需求创建自定义安全策略。如果未指定，则ELB选择最新的预定义安全策略。</li>
</ul>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><ul>
<li>负载均衡对所有已注册的实例执行运行状况检查，无论实例处于健康状态还是不健康状态</li>
<li>负载均衡器执行运行状况检查以发现EC2实例的可用性，负载均衡器定期发送ping，尝试连接或向健康状况发送请求以检查EC2实例。</li>
<li>运行状况检查是健康实例状态的InService和不健康实例的OutOfService</li>
<li>负载均衡器每隔几秒向Ping协议、Ping端口和Ping路径上的每个注册实例发送一个请求。它等待实例在响应超时期间内响应。如果健康检查超过连续失败响应的不健康阈值，负载平衡器将该实例退出服务。当健康检查超过连续成功响应的健康阈值时，负载平衡器将实例重新投入服务。</li>
<li>负载均衡器仅向健康的EC2实例发送请求，并停止将请求路由到不健康的实例</li>
</ul>
<h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><ul>
<li>侦听器是检查来自客户端的连接请求的进程</li>
<li>侦听器配置有用于前端（客户端到负载平衡器）连接的协议和端口，以及用于后端（负载平衡器到后端实例）连接的协议和端口</li>
<li>监听器支持HTTP，HTTPS，SSL，TCP协议</li>
<li>HTTPS或SSL连接需要X.509证书，负载均衡器使用证书终止连接，然后在将请求发送到后端实例之前解密来自客户端的请求。<br>如果要使用SSL，但不想终止负载均衡器上的连接，请使用TCP进行从客户端到负载均衡器的连接，使用SSL协议进行从负载均衡器到后端应用程序的连接，并在处理请求的后端实例上部署证书。</li>
<li>如果为后端使用HTTPS / SSL连接，则可以在后端实例上启用身份验证。此身份验证可用于确保后端实例仅接受加密通信，并确保后端实例具有正确的证书。</li>
<li>ELB HTTPS侦听器不支持客户端SSL证书</li>
</ul>
<h2 id="空闲连接超时"><a href="#空闲连接超时" class="headerlink" title="空闲连接超时"></a>空闲连接超时</h2><ul>
<li>对于客户端通过负载均衡器发出的每个请求，它为每个客户端请求维护两个连接，一个与客户端的连接，另一个连接到后端实例。</li>
<li>对于每个连接，负载均衡器管理在指定时间段内没有数据通过连接发送时触发的空闲超时。 如果未发送或接收数据，则在空闲超时时间（默认为60秒）过后，它将关闭连接</li>
<li>对于冗长的操作（例如文件上载），应调整连接的空闲超时设置，以确保冗长的操作有时间完成</li>
</ul>
<h2 id="X-Forwarded标头和代理协议支持"><a href="#X-Forwarded标头和代理协议支持" class="headerlink" title="X-Forwarded标头和代理协议支持"></a>X-Forwarded标头和代理协议支持</h2><ul>
<li>由于Elastic Load Balancer拦截客户端和后端服务器之间的流量，后端服务器不知道客户端和负载均衡器之间使用的IP地址，协议和端口。<br>ELB提供X-Forwarded标头支持，以帮助后端服务器在使用HTTP协议时跟踪相同的内容</li>
<li>X-Forwarded-For请求标头，用于在使用HTTP或HTTPS负载均衡器时帮助后端服务器识别客户端的IP地址</li>
<li>X-Forwarded-Proto请求标头，用于帮助后端服务器识别客户端用于连接服务器的协议（HTTP/S）</li>
<li>X-Forwarded-Port请求标头，用于帮助后端服务器识别HTTP或HTTPS负载均衡器用于连接客户端的端口</li>
<li>ELB提供代理协议支持，以帮助后端服务器在使用非HTTP协议或使用HTTPS时不跟踪负载平衡器上的SSL连接。</li>
<li>代理协议是一种Internet协议，用于从请求连接的源传送连接到请求连接的目标的连接信息。</li>
<li>Elastic Load Balancing使用代理协议版本1，它使用可读的头格式，其中包含源IP地址，目标IP地址和端口号等连接信息</li>
<li>如果ELB已经在启用了代理协议的代理服务器后面，则在ELB上启用代理协议将添加两次头</li>
</ul>
<h2 id="块区域负载均衡"><a href="#块区域负载均衡" class="headerlink" title="块区域负载均衡"></a>块区域负载均衡</h2><ul>
<li>默认情况下，负载均衡器会在其启用的可用区域内均匀分配传入请求，例如 如果AZ-a有5个实例且AZ-b有2个实例，则每个AZ的负载仍将分配50％</li>
<li>启用跨区域负载平衡允许ELB在所有后端实例上均匀分配传入请求，而不管AZ包含多少个实例</li>
<li>跨区域负载平衡器减少了在每个可用区中维护相同数量的后端实例的需要，并提高了应用程序处理一个或多个后端实例丢失的能力</li>
<li>建议在每个可用区中保持大致相等数量的实例，以获得更高的容错能力</li>
</ul>
<h2 id="连接耗尽"><a href="#连接耗尽" class="headerlink" title="连接耗尽"></a>连接耗尽</h2><ul>
<li>默认情况下，如果注册的带有ELB的EC2实例已取消注册或变得不健康，则负载均衡器会立即关闭连接</li>
<li>连接耗尽可以帮助负载均衡器在保持现有连接打开的同时完成正在进行的请求，并防止任何新请求被发送到取消注册或不健康的实例</li>
<li>连接耗尽有助于执行维护，例如部署软件升级或替换后端实例，而不会影响客户体验</li>
<li>连接耗尽允许指定最大时间（介于1到3,600秒之间，默认为300秒），以便在将实例报告为取消注册之前保持连接处于活动状态。最大超时限制不适用于与不健康实例的连接</li>
<li>如果实例是Auto Scaling组的一部分并且已为负载均衡器启用了连接耗尽，则Auto Scaling会在由于扩展事件或运行状况而终止实例之前等待正在进行的请求完成，或等待最大超时到期检查更换</li>
</ul>
<h2 id="粘性会话"><a href="#粘性会话" class="headerlink" title="粘性会话"></a>粘性会话</h2><ul>
<li>ELB可以配置为使用粘性会话功能（也称为会话关联），使其能够将用户的会话绑定到实例，并确保将所有请求发送到同一实例</li>
<li>粘性保持一段时间，可以通过应用程序的会话cookie（如果存在）或通过名为AWSELB的cookie（通过Elastic Load balancer创建）来控制</li>
<li>默认情况下，禁用ELB的粘性会话<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>HTTP / HTTPS负载均衡器。</li>
<li>SSL流量应该在ELB上终止。 ELB通过使用HTTP cookie在HTTP / HTTPS侦听器上执行会话粘性。 如果SSL流量未在ELB上终止并在后端实例上终止，则ELB无法查看HTTP标头，因此无法设置或读取任何来回传递的HTTP标头。</li>
<li>每个可用区中至少有一个健康实例。<h3 id="基于持续时间的粘性会话"><a href="#基于持续时间的粘性会话" class="headerlink" title="基于持续时间的粘性会话"></a>基于持续时间的粘性会话</h3></li>
</ul>
</li>
<li>基于持续时间的会话粘性由ELB维护，使用创建的特殊cookie来跟踪每个请求到每个侦听器的实例。</li>
<li>当负载均衡器收到请求时，它首先检查请求中是否存在此cookie。 如果是，则将请求发送到cookie中指定的实例。</li>
<li>如果没有cookie，ELB会根据现有的负载平衡算法选择一个实例，并在响应中插入一个cookie，用于绑定来自同一用户的后续请求。</li>
<li>粘性策略配置定义了cookie过期，它确定了每个cookie的有效期。 Cookie会在有效期到期后自动更新。</li>
</ul>
<h3 id="应用程序控制粘性会话"><a href="#应用程序控制粘性会话" class="headerlink" title="应用程序控制粘性会话"></a>应用程序控制粘性会话</h3><ul>
<li>负载均衡器仅使用特殊cookie将会话与处理初始请求的实例相关联，但遵循策略配置中指定的应用程序cookie的生命周期。</li>
<li>如果应用程序响应包含新的应用程序cookie，则负载均衡器仅插入新的粘性cookie。 负载均衡器粘性cookie不会随每个请求更新。</li>
<li>如果明确删除或过期应用程序cookie，则在发出新的应用程序cookie之前，会话将停止粘滞。</li>
<li>如果实例失败或变得不健康，负载均衡器会停止将路由请求发送到该实例，而是根据现有的负载均衡算法选择新的健康实例。 负载均衡器将会话视为现在“卡住”到新的正常实例，并继续将请求路由到该实例，即使失败的实例返回。</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><ul>
<li>对于 Application Load Balancer，用于接收请求的负载均衡器节点会按照优先级顺序评估侦听器规则以确定应用哪个规则，然后使用轮询路由算法从目标组中选择一个目标以实施规则操作。每个目标组的路由都是单独进行的，即使某个目标已在多个目标组中注册。</li>
<li>对于 Network Load Balancer，用于接收连接的负载均衡器节点会根据协议、源 IP 地址、源端口、目标 IP 地址、目标端口和 TCP 序列号，使用流式哈希算法从目标组中为默认规则选择一个目标。来自客户端的 TCP 连接具有不同的源端口和序列号，可以路由到不同的目标。每个单独的 TCP 连接在连接的有效期内路由到单个目标。</li>
<li>对于 Classic Load Balancer，接受请求的负载均衡器节点将利用不同算法来选择已注册的实例。它对 TCP 侦听器使用轮询路由算法，对 HTTP 和 HTTPS 侦听器使用最少未完成请求路由算法。<h2 id="ALB-vs-NLB-vs-CLB"><a href="#ALB-vs-NLB-vs-CLB" class="headerlink" title="ALB vs NLB vs CLB"></a>ALB vs NLB vs CLB</h2></li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>功能</strong></th>
<th align="center"><strong>Application Load Balancer</strong></th>
<th align="center"><strong>网络负载均衡器</strong></th>
<th align="center"><strong>Classic Load Balancer</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议</td>
<td align="center">HTTP、HTTPS</td>
<td align="center">TCP、UDP、TLS</td>
<td align="center">TCP、SSL/TLS、HTTP、HTTPS</td>
</tr>
<tr>
<td align="left">平台</td>
<td align="center">VPC</td>
<td align="center">VPC</td>
<td align="center">EC2-Classic、VPC</td>
</tr>
<tr>
<td align="left">运行状况检查</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">CloudWatch 指标</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">日志记录</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">区域故障转移</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">Connection Draining（注销延迟）</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">负载均衡到同一实例上的多个端口</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">IP 地址即目标</td>
<td align="center">✔</td>
<td align="center">✔（TCP、TLS）</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">负载均衡器删除保护</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">可配置的空闲连接超时</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">跨区负载均衡</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">粘性会话</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">静态 IP</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">弹性 IP 地址</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">保留源 IP 地址</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于资源的 IAM 权限</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">基于标签的 IAM 权限</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">慢启动</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">WebSocket</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">PrivateLink 支持</td>
<td align="center"></td>
<td align="center">✔（TCP、TLS）</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于源 IP 地址 CIDR 的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">第 7 层</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于路径的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于主机的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">本机 HTTP/2</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">重定向</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">固定响应</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">Lambda 函数即目标</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于 HTTP 标头的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于 HTTP 方法的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">基于查询字符串参数的路由</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">安全性</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">SSL 卸载</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">服务器名称指示 (SNI)</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">后端服务器加密</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center">✔</td>
</tr>
<tr>
<td align="left">用户身份验证</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">自定义安全策略</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
</tbody></table>
<h1 id="AutoScaling-amp-ELB"><a href="#AutoScaling-amp-ELB" class="headerlink" title="AutoScaling &amp; ELB"></a>AutoScaling &amp; ELB</h1><ul>
<li>Auto Scaling动态添加和删除EC2实例，而Elastic Load Balancing通过优化路由流量来管理传入请求，这样就不会有任何一个实例超负荷运行</li>
<li>AUto Scaling有助于在用户需求增加时自动增加EC2实例的数量，并在需求下降时减少EC2实例的数量</li>
<li>ELB服务有助于在所有正在运行的EC2实例之间自动分配传入的Web流量</li>
<li>ELB使用负载平衡器来监控流量并处理来自Internet的请求</li>
<li>使用ELB和Auto Scaling<ul>
<li>可以轻松地在动态变化的EC2实例中路由流量</li>
<li>负载均衡器充当Auto Scaling组中实例的所有传入流量的单一连接点<br><img src="https://i.loli.net/2019/08/28/47J6cRxMrObEjwY.png" alt="Screen-Shot-2016-06-07-at-4.13.10-PM.png"></li>
</ul>
</li>
</ul>
<h2 id="Attaching-Detaching-ELB-with-Auto-Scaling-Group"><a href="#Attaching-Detaching-ELB-with-Auto-Scaling-Group" class="headerlink" title="Attaching/Detaching ELB with Auto Scaling Group"></a>Attaching/Detaching ELB with Auto Scaling Group</h2><ul>
<li>Auto Scaling与Elastic Load Balancing集成，可以将一个或多个负载均衡器连接到现有的Auto Scaling组。</li>
<li>ELB使用其IP地址注册EC2实例，并将请求路由到实例的主接口（eth0）的主IP地址。</li>
<li>连接ELB后，它会自动在组中注册实例，并在实例之间分配传入流量</li>
<li>分离ELB时，它会在取消注册组中的实例时进入“删除”状态。</li>
<li>如果启用了连接耗尽，ELB将在取消注册实例之前等待正在进行的请求完成。</li>
<li>从ELB注销实例后，实例仍在运行</li>
<li>Auto Scaling会在启动时向ELB添加实例，但这可以暂停。 在暂停期间启动的实例在恢复后不会添加到负载均衡器，并且必须手动注册。</li>
</ul>
<h2 id="High-Availability-amp-Redundancy"><a href="#High-Availability-amp-Redundancy" class="headerlink" title="High Availability &amp; Redundancy"></a>High Availability &amp; Redundancy</h2><ul>
<li>Auto Scaling可以跨越同一区域内的多个AZ</li>
<li>当一个AZ变得不健康或不可用时，Auto Scaling会在未受影响的AZ中启动新实例</li>
<li>当不健康的AZ恢复时，Auto Scaling会在所有健康的AZ中重新分配流量</li>
<li>可以设置Elastic Load balancer以在区域内的单个AZ或多个AZ中跨EC2实例分发传入请求</li>
<li>建议通过跨区域内多个AZ的Auto Scaling组使用Auto Scaling和ELB，然后设置ELB以在这些AZ之间分配传入流量，来利用地理冗余的安全性和可靠性。</li>
<li>在为ELB启用的所有AZ中，传入流量均衡负载到AZ中</li>
</ul>
<h2 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h2><ul>
<li>Auto Scaling组通过定期检查EC2实例状态检查的结果来确定每个实例的运行状况</li>
<li>如果实例未通过EC2实例状态检查，Auto Scaling会将实例标记为运行状况不佳并替换实例</li>
<li>ELB还对在其上注册的EC2实例执行健康检查，例如 ping和健康检查页面提供应用程序</li>
<li>如果ELB运行状况检查失败，则默认情况下，Auto Scaling不会替换实例</li>
<li>应使用实例的ELB运行状况检查来确保流量仅路由到正常运行的实例</li>
<li>向Auto Scaling组注册负载均衡器后，除了EC2实例状态检查之外，还可以将其配置为使用ELB运行状况检查的结果来确定Auto Scaling组中EC2实例的运行状况。</li>
</ul>
<h2 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h2><ul>
<li>Elastic Load Balancing将有关负载均衡器和EC2实例的数据发送到Amazon CloudWatch。 CloudWatch收集有关资源性能的数据，并将其显示为指标。</li>
<li>在使用Auto Scaling组注册一个或多个负载均衡器后，可以将Auto Scaling组配置为使用ELB指标（例如请求延迟或请求计数）自动扩展应用程序</li>
</ul>
<h1 id="AWS-ELB-Monitoring"><a href="#AWS-ELB-Monitoring" class="headerlink" title="AWS ELB Monitoring"></a>AWS ELB Monitoring</h1><h2 id="Cloud-Watch-Metrics"><a href="#Cloud-Watch-Metrics" class="headerlink" title="Cloud Watch Metrics"></a>Cloud Watch Metrics</h2><ul>
<li>Elastic Load Balancing向Amazon CloudWatch发布有关负载均衡器和后端实例的数据采集信息</li>
<li>仅当请求流经负载均衡器时，Elastic Load Balancing才会将指标报告给CloudWatch。 如果有请求流经负载均衡器，Elastic Load Balancing将以60秒的间隔测量并发送其指标。 如果没有请求流经负载均衡器或没有指标数据，则不会报告该指标。</li>
</ul>
<p>监控指标包含如下</p>
<ul>
<li>HealthyHostCount，UnHealthyHostCount<ul>
<li>使用负载均衡器注册的健康和不健康实例的数量</li>
<li>统计数据是平均值，最小值和最大值</li>
</ul>
</li>
<li>RequestCount<ul>
<li>在指定的时间间隔内（1或5分钟）完成的请求数或连接数</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>latency<ul>
<li>请求离开负载均衡器之后经过的时间（以秒为单位），直到收到响应的标头</li>
<li>统计数据是平均值</li>
</ul>
</li>
<li>SurgeQueueLength<ul>
<li>待处理路由的请求总数</li>
<li>如果请求无法与正常实例建立连接以便路由请求，则负载均衡器会对请求进行排队</li>
<li>队列的最大大小为1,024。队列已满时，将拒绝其他请求。</li>
<li>统计信息是max，因为它表示排队请求的峰值</li>
</ul>
</li>
<li>SpilloverCount<ul>
<li>由于浪涌队列已满而被拒绝的请求总数。理想情况下应为0</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>HTTPCode_ELB_4XX，HTTPCode_ELB_5XX<ul>
<li>负载均衡器生成的客户端和服务器错误代码</li>
<li>统计数据是总和</li>
</ul>
</li>
<li>HTTPCode_Backend_2XX，HTTPCode_Backend_3XX，HTTPCode_Backend_4XX，HTTPCode_Backend_5XX<ul>
<li>已注册实例生成的HTTP响应代码数</li>
<li>统计数据是总和</li>
</ul>
</li>
</ul>
<h2 id="ELB-访问日志"><a href="#ELB-访问日志" class="headerlink" title="ELB 访问日志"></a>ELB 访问日志</h2><ul>
<li>Elastic Load Balancing提供访问日志，可捕获有关发送到负载均衡器的所有请求的详细信息</li>
<li>每个日志都包含诸如接收请求的时间，客户端的IP地址，延迟，请求路径和服务器响应之类的信息。<br>Elastic Load Balancing捕获日志并将其存储在Amazon S3存储桶中</li>
<li>默认情况下禁用访问日志记录，无需任何额外费用即可启用。 只需支付S3存储费用</li>
</ul>
<h2 id="Cloud-Trail-日志"><a href="#Cloud-Trail-日志" class="headerlink" title="Cloud Trail 日志"></a>Cloud Trail 日志</h2><ul>
<li>AWS CloudTrail可用于捕获由AWS账户或代表AWS账户制作的Elastic Load Balancing API的所有调用，并且可以直接使用Elastic Load Balancing API，也可以通过AWS管理控制台或AWS CLI间接调用</li>
<li>CloudTrail将信息作为日志文件存储在指定的Amazon S3存储桶中。</li>
<li>CloudTrail收集的日志可用于监控负载均衡器的活动，并确定进行的API调用，使用的源IP地址，拨打电话的人员，拨打电话的时间等等。</li>
</ul>
<h1 id="Classic-Load-Balancer-vs-Application-Load-Balancer"><a href="#Classic-Load-Balancer-vs-Application-Load-Balancer" class="headerlink" title="Classic Load Balancer vs Application Load Balancer"></a>Classic Load Balancer vs Application Load Balancer</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>CLB是跨多个EC2实例的流量的简单负载平衡的理想选择，</li>
<li>ALB是微服务或基于容器的体系结构的理想选择，在这种体系结构中，需要将流量路由到多个服务或在同一EC2实例上的多个端口之间进行负载平衡。</li>
</ul>
<p><img src="https://i.loli.net/2019/08/28/oiZSxfG1CDlRYVb.png" alt="AWS-ELB-Classic-Load-Balancer-vs-Application-Load-Balancer.png"></p>
<h2 id="支持协议"><a href="#支持协议" class="headerlink" title="支持协议"></a>支持协议</h2><ul>
<li>CLB在第4层运行，支持HTTP，HTTPS，TCP，SSL，而Application Load Balancer在第7层运行，支持HTTP，HTTPS，HTTP / 2，WebSockets</li>
<li>如果需要第4层功能，则应使用CLB</li>
</ul>
<h2 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h2><ul>
<li>CLB 支持EC2-Classic和EC2-VPC，而ALB仅支持EC2-VPC</li>
</ul>
<h2 id="Stick-Sessions（Cookies）"><a href="#Stick-Sessions（Cookies）" class="headerlink" title="Stick Sessions（Cookies）"></a>Stick Sessions（Cookies）</h2><ul>
<li>Stick Sessions（粘性会话）使负载均衡器能够将用户的会话绑定到特定实例，从而确保会话期间来自用户的所有请求都发送到同一个实例</li>
<li>Classic和Application Load Balancer都支持粘性会话以保持会话亲和性</li>
</ul>
<h2 id="空闲连接超时-1"><a href="#空闲连接超时-1" class="headerlink" title="空闲连接超时"></a>空闲连接超时</h2><ul>
<li>空闲连接超时有助于指定一个时间段，如果在空闲超时时间过去之前没有数据发送或接收，ELB将使用该时间段来关闭连接</li>
<li>Classic和Application Load Balancer都支持空闲连接超时</li>
</ul>
<h2 id="连接耗尽-1"><a href="#连接耗尽-1" class="headerlink" title="连接耗尽"></a>连接耗尽</h2><ul>
<li>连接耗尽使负载均衡器能够完成对取消注册或不健康的实例的正在进行的请求</li>
<li>Classic和Application Load Balancer都支持连接耗尽</li>
</ul>
<h2 id="SSL终止"><a href="#SSL终止" class="headerlink" title="SSL终止"></a>SSL终止</h2><ul>
<li>CLB和ALB都支持SSL终端，以便在将客户端发送到目标之前对其进行解密，从而减轻负载。 必须在负载均衡器上安装SSL证书。</li>
</ul>
<h2 id="后端服务器身份验证"><a href="#后端服务器身份验证" class="headerlink" title="后端服务器身份验证"></a>后端服务器身份验证</h2><ul>
<li>后端服务器身份验证允许对实例进行身份验证。 仅当实例提供给负载均衡器的公钥与负载均衡器的身份验证策略中的公钥匹配时，负载均衡器才与实例通信。</li>
<li>CLB器支持，而应用程序负载均衡器不支持后端服务器身份验证 </li>
</ul>
<h2 id="跨区域负载平衡"><a href="#跨区域负载平衡" class="headerlink" title="跨区域负载平衡"></a>跨区域负载平衡</h2><ul>
<li>跨区域负载平衡有助于在其启用的AZ中的所有实例之间均匀分配传入请求。 默认情况下，Load Balancer将在其启用的AZ上均匀分布请求，而不管其承载的实例如何。</li>
<li>Classic和Application Load Balancer都支持跨区域负载平衡，但是对于Classic，需要启用它，而对于ALB，它始终启用</li>
</ul>
<h2 id="健康检查-1"><a href="#健康检查-1" class="headerlink" title="健康检查"></a>健康检查</h2><ul>
<li>Classic和Application Load Balancer都支持运行状况检查，以确定实例是健康的还是不健康的<br>ALB提供运行状况检查改进，允许配置200-399的详细错误代码</li>
</ul>
<h2 id="CloudWatch指标"><a href="#CloudWatch指标" class="headerlink" title="CloudWatch指标"></a>CloudWatch指标</h2><ul>
<li>Classic和Application Load Balancer都与CloudWatch集成以提供指标，ALB提供额外的指标</li>
</ul>
<h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><ul>
<li>访问日志捕获有关发送到负载均衡器的请求的详细信息。 每个日志都包含诸如接收请求的时间，客户端的IP地址，延迟，请求路径和服务器响应之类的信息</li>
<li>Classic和Application Load Balancer都提供访问日志，ALB提供其他属性</li>
</ul>
<h2 id="基于主机的路由和基于路径的路由"><a href="#基于主机的路由和基于路径的路由" class="headerlink" title="基于主机的路由和基于路径的路由"></a>基于主机的路由和基于路径的路由</h2><ul>
<li>基于主机的路由使用主机条件来定义根据主机头中的主机名将请求转发到不同目标组的规则。 这使ALB能够使用单个负载均衡器支持多个域。</li>
<li>基于路径的路由使用路径条件来定义基于请求中的URL将请求转发到不同目标组的规则。 每个路径条件都有一个路径模式。 如果请求中的URL与侦听器规则中的路径模式完全匹配，则使用该规则路由请求。<br>只有ALB支持基于主机和路径的路由。</li>
</ul>
<h2 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h2><ul>
<li>只有ALB支持使用ECS进行动态端口映射，这允许两个服务容器在动态端口上的单个服务器上运行，ALB自动检测并重新配置自身。</li>
</ul>
<h2 id="删除保护"><a href="#删除保护" class="headerlink" title="删除保护"></a>删除保护</h2><ul>
<li>只有ALB支持删除保护，如果启用了删除保护，则无法删除负载均衡器</li>
</ul>
<h2 id="请求跟踪"><a href="#请求跟踪" class="headerlink" title="请求跟踪"></a>请求跟踪</h2><ul>
<li>只有ALB支持请求跟踪来跟踪从客户端到目标或其他服务的HTTP请求。</li>
</ul>
<h2 id="VPC中的IPv6"><a href="#VPC中的IPv6" class="headerlink" title="VPC中的IPv6"></a>VPC中的IPv6</h2><ul>
<li>只有ALB在VPC中支持IPv6</li>
</ul>
<h2 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h2><ul>
<li>只有ALB支持AWS WAF，可以直接在VPC中的ALB（内部和外部）上使用，以保护网站和Web服务</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/26/札记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/札记/" itemprop="url">札记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T19:23:57+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数字化转型（金融）"><a href="#数字化转型（金融）" class="headerlink" title="数字化转型（金融）"></a>数字化转型（金融）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="left"><strong>信息化模型</strong></th>
<th align="left"><strong>数字化模型</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用模式</td>
<td align="left">专线支持的网点、ATM、POS机等客户场景</td>
<td align="left">互联网生态及自有APP的用户场景、无人银行</td>
</tr>
<tr>
<td align="center">人员思维</td>
<td align="left">项目经理思维，架构师思维</td>
<td align="left">产品思维、数据思维</td>
</tr>
<tr>
<td align="center">产品形态</td>
<td align="left">以金融机构为视角的专业化产品</td>
<td align="left">以客户体验为核心的生态化产品</td>
</tr>
<tr>
<td align="center">开发模式</td>
<td align="left">基于完整需求进行瀑布式开发</td>
<td align="left">基于体验点进行敏捷开发</td>
</tr>
<tr>
<td align="center">合作模式</td>
<td align="left">业务部门定义产品，科技部门实现产品</td>
<td align="left">业务部门和科技部门共同定义产品</td>
</tr>
<tr>
<td align="center">团队组织</td>
<td align="left">由项目经理、架构师、领域开发人员组成的开发中心、测试中心、数据中心</td>
<td align="left">包含项目经理、产品经理、全栈开发组成</td>
</tr>
<tr>
<td align="center">技术平台</td>
<td align="left">自建、私有云</td>
<td align="left">自建+ 租用 私有云+公有云</td>
</tr>
<tr>
<td align="center">数据架构</td>
<td align="left">大数据</td>
<td align="left">数据湖</td>
</tr>
<tr>
<td align="center">应用架构</td>
<td align="left">MVC/三层</td>
<td align="left">现代化应用</td>
</tr>
<tr>
<td align="center">开发运维工具</td>
<td align="left">开发工具/运维工具</td>
<td align="left">DevOps、AIoPS</td>
</tr>
<tr>
<td align="center">自动化程度</td>
<td align="left">实现“人管机器”的技术自动化</td>
<td align="left">业务自动化</td>
</tr>
</tbody></table>
<h4 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h4><ul>
<li>I/O路经长</li>
<li>latency 大（网络抖动、多副本处理）</li>
</ul>
<p>优化时延主要方法：</p>
<ul>
<li>硬件升级，诸如NVME、RDMA</li>
<li>优化I/O路径，通信框架</li>
<li>优化每个模块的处理时间</li>
<li>优化磁盘布局</li>
<li>增加数据缓存层</li>
</ul>
<h4 id="数据仓库-vs-数据湖"><a href="#数据仓库-vs-数据湖" class="headerlink" title="数据仓库 vs 数据湖"></a>数据仓库 vs 数据湖</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据</td>
<td align="left">来自食物系统、运营数据库、业务应用程序</td>
<td align="left">IoT设备、网络、移动应用程序、社交媒体（非关系）</td>
</tr>
<tr>
<td align="center">Schema</td>
<td align="left">写入型Schema</td>
<td align="left">写入分析时（读取型 Schema）</td>
</tr>
<tr>
<td align="center">性价比</td>
<td align="left">更快查询结果成本高</td>
<td align="left">更快查询结果较低存储成本</td>
</tr>
<tr>
<td align="center">数据质量</td>
<td align="left">可作为重要事实依据的高度监管数据</td>
<td align="left">任何可以或无法进行监管数据</td>
</tr>
<tr>
<td align="center">用户</td>
<td align="left">业务分析师</td>
<td align="left">数据科学家、数据开发人员和业务分析师</td>
</tr>
<tr>
<td align="center">分析</td>
<td align="left">批处理、BI、可视化</td>
<td align="left">机器学习、预测成本、数据发现和分析</td>
</tr>
</tbody></table>
<blockquote>
<p>数据湖概念：</p>
</blockquote>
<p> <em>在保障数据持久性和安全性的前提下，存储任何量级的各种数据（结构化、非结构化、半结构化），并对其运用不同的分析手段（查询、统计、挖掘），以获得数据内在价值并指导业务发展</em></p>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><ul>
<li>InnoDB的行锁匙实现在索引上的</li>
<li>并发控制保证数据一致性常见手段<ul>
<li>锁（locking）</li>
<li>数据多版本（multi versioning）</li>
</ul>
</li>
<li>共享锁（share lock ）,读数据枷锁</li>
<li>排他锁（exclusive lock），修改数据加X锁</li>
<li>写事务未提交，读相关数据select阻塞</li>
<li>由锁机制延伸出数据多版本</li>
</ul>
<p>核心原理</p>
<ul>
<li>写任务发生时，将数据克隆一份，以版本号区别</li>
<li>写人物操作新克隆的数据，直至提交</li>
<li>并发读可以继续读取旧版本数据，不至于阻塞</li>
</ul>
<ul>
<li>普通锁串行，读写锁读读并行，数据多版本读写并行</li>
<li>Redo日志保证已提交事务的ACID特性，设计思路是通过顺序写代替随机写，提高并发</li>
<li>redo 日志保证未提交事务的ACID特性，存储在回滚段中</li>
<li>InnoDB是基于MVCC的存储引擎，利用存储在回滚段里undo日志，即数据的旧版本提高并发 </li>
<li>InnoDB 之所以并发高，快照读不加锁</li>
<li>InnoDB 所有的普通Select 都是快照读</li>
</ul>
<p>InnoDB 存储引擎</p>
<ol>
<li>重做日志 redo log 用于实力故障恢复是，继续那些已经commit 但尚未完全回写到磁盘的事务</li>
<li>回滚日志 undo log 用于在实例故障恢复时，借助undo log将尚未commit的食物，回滚到事务开始前的状态</li>
</ol>
<p>总结：redo log 可以保证事务的原子性和持久性，undo log可以保证事务的一致性（事务的隔离性是由锁来实现的）<br>redo和undo 都可以视作一种恢复操作，redo恢复提交事务修改的页操作，记录的内容是物理日志，记录的是页的物理修改操作；而undo回滚行记录到某个特定的版本，记录的是逻辑日志，根据每行记录进行记录。</p>
<p>数据库索引</p>
<ol>
<li>B+ 树 数据结构：高度平衡的多叉树，叶子节点保存所有数据。（注意B+树的非聚集索引的叶子节点并不是直接存放的给定键值的行，而是数据行所在的页，然后数据库通过把页读入内存，再在内存中查找）</li>
<li>B+ 树数据结构应用在数据库的索引实现中，具有高度的扇出性，一般B+树的高度都在2～4层，也就是说查找某一键值的行记录时最多只需要2～4此IO</li>
</ol>
<p>B+树索引可以分为聚集索引（主键索引，已主键作为key的索引）和辅助索引（非聚集索引）。</p>
<ul>
<li>聚集索引的叶子节点保存的是数据，即行记录；</li>
<li>InnoDB的主键索引的排序查找和范围查找非常快；</li>
</ul>
<p>InnoDB的数据文件本身就是索引文件。MyISAM索引文件爱你和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引仅够，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB的辅助索引data域存储相应记录主键的值而不是地址，InnoDB的所有辅助索引引用主键作为data域。<br>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两边索引：首先检索辅助索引获得主键，然后哦用主键到主索引中检索获得记录。</p>
<p>数据库事务隔离级别</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>隔离级别</strong></td>
<td align="left"><strong>脏读（Dirty Read）</strong></td>
<td align="left"><strong>不可重复读（NonRepeattable Read）</strong></td>
<td align="left"><strong>幻读（Phantom Read）</strong></td>
</tr>
<tr>
<td align="left">未提交读 （Read uncommited）</td>
<td align="left">可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">已提交读（Read commited）</td>
<td align="left">不可能</td>
<td align="left">可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可重复读（Repeatable read）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">可能</td>
</tr>
<tr>
<td align="left">可串行化（Serializable）</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
<td align="left">不可能</td>
</tr>
</tbody></table>
<ul>
<li>未提交读（Read Uncommited）：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li>提交读（Read Committed）：只能读取到已经提交的数据。Oracle等多数据默认都是该级别（不重复读）</li>
<li>可重复读（RepeatedRead）：可重复读。在同一个事务内的查询都是事务开始时刻是一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻想读。</li>
<li>串行读（Serializable）：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<p>MySQL尽量避免使用NULL（空值）列，其使得索引、索引统计和值都比较复杂</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/26/AWS-Route-53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/AWS-Route-53/" itemprop="url">AWS Route 53</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T19:15:38+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Amazon Route 53 是一种具有很高可用性和可扩展性的域名系统 (DNS) Web 服务。可以使用 Route 53 以任意组合执行三个主要功能：域注册、DNS 路由和运行状况检查。</p>
<ol>
<li><p>域名注册</p>
</li>
<li><p>将Internet路由到域名</p>
<ul>
<li>域名解析到正确的IP地址</li>
<li>使用权威DNS服务器的全局网络响应DNS查询，从而减少延迟</li>
<li>将Internet流量路由到CloudFront，Elastic Beanstalk，ELB或S3。 对这些资源进行DNS查询是免费的</li>
</ul>
</li>
<li><p>检查资源的运行状况</p>
<ul>
<li>可以监控Web和电子邮件服务器等资源的运行状况。</li>
<li>通过Internet向应用程序发送自动请求</li>
<li>验证它是否可访问，可用且功能正常</li>
<li>可以为运行状况检查配置CloudWatch警报，以便在资源不可用时发送通知。</li>
<li>可以配置为将Internet流量路由远离不可用的资源</li>
</ul>
<h2 id="支持的DNS记录类型"><a href="#支持的DNS记录类型" class="headerlink" title="支持的DNS记录类型"></a>支持的DNS记录类型</h2></li>
</ol>
<ul>
<li><p>A（IPv4地址记录）</p>
</li>
<li><p>AAAA（IPv6 地址记录）</p>
</li>
<li><p>CNAME（规范名称记录）</p>
<ul>
<li>格式与域名相同</li>
<li>DNS协议不允许为DNS命名空间的顶级节点创建CNAME记录，也称为区域顶点（例如，区域顶点）。 DNS名称example.com注册，区域顶点是example.com，无法创建example.com的CNAME记录，但可以为<a href="http://www.example.com，newproduct.example.com等创建CNAME记录。" target="_blank" rel="noopener">www.example.com，newproduct.example.com等创建CNAME记录。</a></li>
<li>如果为子域创建了CNAME记录，则无法为该子域创建该子域的任何其他资源记录集。如果为<a href="http://www.example.com创建了CNAME，而不是可以创建名称字段值为www.example.com的其他资源记录集" target="_blank" rel="noopener">www.example.com创建了CNAME，而不是可以创建名称字段值为www.example.com的其他资源记录集</a></li>
</ul>
</li>
<li><p>CAA (认证机构授权)</p>
</li>
<li><p>MX (邮件交换记录)</p>
</li>
<li><p>NAPTR（命名授权指针记录）</p>
</li>
<li><p>NS（名称服务器记录）</p>
<ul>
<li>NS记录标识托管区域的名称服务器。 NS记录的值是名称服务器的域名。</li>
</ul>
</li>
<li><p>PTR（指针记录）</p>
</li>
<li><p>SOA（起始授权记录）</p>
</li>
<li><p>SPF（发件人策略框架）</p>
</li>
<li><p>SRV（服务定位器）</p>
</li>
<li><p>TXT（文本记录）</p>
</li>
<li><p>Amazon Route 53 还提供别名记录，这些记录是 Amazon Route 53 专用的 DNS 扩展。</p>
</li>
</ul>
<h2 id="Alias-记录类型"><a href="#Alias-记录类型" class="headerlink" title="Alias 记录类型"></a>Alias 记录类型</h2><ul>
<li>Route　53支持别名资源记录集，可以将查询路由到CloudFront分配，Elastic Beanstalk，ELB，配置为静态网站的S3存储桶或其他Route 53资源记录集</li>
<li>别名记录不是DNS RFC的标准，是Route 53的扩展功能</li>
<li>别名记录类似于CNAME记录，但可以为根域或顶点域、子域创建别名记录，而cname只能用于记录子域</li>
<li>Route 53自动识别别名记录资源所引用的资源记录的变化，如对于指向ELB的指导年，若负载均衡的IP发生变化，则Route 53将自动在DNS的回应中反映这些变化，而不对包含资源记录集的托管区域进行任何更改</li>
<li>若alias记录集指向CloudFront、ELB或S3，则无法设置TTL；Route 53使用cloudfront、LB或者S3的TTL</li>
</ul>
<table>
<thead>
<tr>
<th>NAME 记录</th>
<th>别名记录</th>
</tr>
</thead>
<tbody><tr>
<td>CNAME 记录可以将 DNS 查询重定向到任何 DNS 记录。例如，可以创建一条 CNAME 记录，该记录将查询从 acme.example.com 重定向到 zenith.example.com 或 acme.example.org。不需要使用 Route 53 作为您要将查询重定向到的域的 DNS 服务。</td>
<td>别名记录只能将查询重定向到选定的 AWS 资源，例如：Amazon S3 存储桶 ;CloudFront 分配;其中创建别名记录的 Route 53 托管区域中的其他记录;例如，可以创建一个名为 acme.example.com 的别名记录，该记录将查询重定向到 Amazon S3 存储桶（也称为 acme.example.com.）。还可以创建一个 acme.example.com 别名记录，该记录将查询重定向到 example.com 托管区域中名为 zenith.example.com 的记录。</td>
</tr>
<tr>
<td>不能创建与托管区域（区域 APEX）同名的 CNAME 记录。对于域名 (example.com) 的托管区域和子域 (zenith.example.com) 的托管区域都是如此。</td>
<td>在大多数配置中，您可以创建一个与托管区域（区域 APEX）同名的别名记录。一个例外情况是，当您要将来自区域 APEX（如 example.com）的查询重定向到具有类型 CNAME（如 zenith.example.com）的同一托管区域中的记录时。别名记录必须与您要将流量路由到的目标记录具有相同的类型，而为顶级域名创建 CNAME 记录的做法不受支持，即使对于别名记录也是如此。</td>
</tr>
<tr>
<td>Route 53 收取 CNAME 查询费用。</td>
<td>对于 AWS 资源的别名查询，Route 53 不收费。有关更多信息，请参阅 Amazon Route 53 定价。</td>
</tr>
<tr>
<td>无论记录类型如何，CNAME 记录都会重定向对记录名称（如 A 或 AAAA）的 DNS 查询。</td>
<td>仅当别名记录的名称（如 acme.example.com）和别名记录的类型（如 A 或 AAAA）与 DNS 查询中的名称和类型匹配时，Route 53 才响应 DNS 查询。</td>
</tr>
<tr>
<td>CNAME 记录在响应 dig 或 nslookup 查询时显示为 CNAME 记录。</td>
<td>别名记录显示为您在创建记录时指定的记录类型，例如 A 或 AAAA。别名属性仅在 Route 53 控制台中或在响应以编程方式发出的请求时可见，例如 AWS CLI list-resource-record-sets 命令。</td>
</tr>
</tbody></table>
<h2 id="托管区域"><a href="#托管区域" class="headerlink" title="托管区域"></a>托管区域</h2><ul>
<li>托管区域是一个记录容器，记录中包含的信息说明您希望如何路由特定域（如 example.com）及其子域（acme.example.com、zenith.example.com）的流量。</li>
<li>管区域与相应域具有相同的名称。</li>
<li>有两种类型的托管区域：<ul>
<li>公有托管区域 包含指定了如何路由 Internet 流量的记录。</li>
<li>私有托管区域 包含指定了如何在 Amazon VPC 中路由流量的记录。</li>
</ul>
</li>
<li>在托管区域中创建记录<ul>
<li>记录定义了为每个域名或子域名路由路由的位置。</li>
<li>托管区域中每条记录的名称必须以托管区域的名称结尾。</li>
</ul>
</li>
</ul>
<h2 id="Route-53-Split-view-Split-horizon-DNS"><a href="#Route-53-Split-view-Split-horizon-DNS" class="headerlink" title="Route 53 Split-view(Split-horizon) DNS"></a>Route 53 Split-view(Split-horizon) DNS</h2><ul>
<li>允许公开使用的相同域名访问网站的内部版本</li>
<li>使用Route 53 Spilt-view 为DNS维护具有相同域名的私有和公共托管区域</li>
<li>确保在VPC上启用DNS解析和DNS主机名</li>
<li>DNS查询将根据请求的来源回答答案。 在VPC内，答案将来自私有托管区域，而公共查询将从公共托管区域返回答案。</li>
</ul>
<h1 id="DNS-路由策略"><a href="#DNS-路由策略" class="headerlink" title="DNS 路由策略"></a>DNS 路由策略</h1><h2 id="简单路由策略"><a href="#简单路由策略" class="headerlink" title="简单路由策略"></a>简单路由策略</h2><ul>
<li>简单路由策略是一种简单的循环策略，可以在有单个资源为域执行功能时应用。如为网站提供内容的服务器</li>
<li>AWS Route 53基于资源记录集中的值来响应DNS查询。 如A记录中的IP地址</li>
</ul>
<h2 id="加权轮询（WRR）"><a href="#加权轮询（WRR）" class="headerlink" title="加权轮询（WRR）"></a>加权轮询（WRR）</h2><ul>
<li>加权路由策略使路由53能够以指定的比例（权重）将流量路由到不同的资源，例如，75％的一个服务器和25％的另一个服务器</li>
<li>可以为权重指定0到255之间的任何数字</li>
<li>当存在多个执行相同功能的资源（例如，服务于相同站点的web服务器）时，可以应用加权路由策略</li>
<li>加权资源记录集允许您将多个资源与单个DNS名称相关联</li>
<li>常见用例包括<ul>
<li>负载均衡</li>
<li>A / B测试和试用新版软件</li>
</ul>
</li>
<li>创建一组加权资源记录集，可以创建具有相同DNS名称和类型组合的两个或更多资源记录集，并且为每个资源记录集分配唯一标识符和相对权重</li>
<li>处理DNS查询时，Route 53搜索具有指定名称和类型的资源记录集或一组资源记录集</li>
<li>Route 53从组中选择一个。选择任何一个资源记录集的概率取决于其权重作为该组中所有资源记录集的总权重的比例，例如，假设<a href="http://www.example.com具有三个权重为1的资源记录集（20％）" target="_blank" rel="noopener">www.example.com具有三个权重为1的资源记录集（20％）</a> ），1（20％）和3（60％）（总和= 5）。平均而言，Route 53在五分之一的时间中选择前两个资源记录集中的每一个，并且返回三分之三的时间的第三资源记录集。</li>
</ul>
<h2 id="基于延迟的路由（LBR）"><a href="#基于延迟的路由（LBR）" class="headerlink" title="基于延迟的路由（LBR）"></a>基于延迟的路由（LBR）</h2><ul>
<li>基于延迟的路由策略使Route 53能够根据哪个数据中心为用户提供最低的网络延迟来响应DNS查询</li>
<li>当有多个资源执行相同的功能时，可以使用基于延迟的路由策略，并且Route 53需要配置为使用提供最快响应和最低延迟的资源来响应DNS查询</li>
<li>可以为托管应用程序的每个区域中的EC2资源创建延迟资源记录集。当Route 53收到对应域的查询时，它会选择为EC2区域设置的延迟资源记录，为用户提供最低延迟。然后，Route 53以与该资源记录集相关联的值进行响应，例如，您能在爱尔兰和东京的EC2数据中心中具有example.com的Web服务器。当用户从新加坡浏览example.com时，Route 53将从用户位置获取具有最低延迟的数据中心（东京）</li>
<li><strong>由于网络连接和路由的变化，Internet上主机之间的延迟可能会随着时间的推移而发生变化。基于延迟的路由基于在一段时间内执行的等待时间测量，并且测量结果反映了这些变化。</strong>如果新加坡用户到爱尔兰的延迟有所改善，用户可以路由到爱尔兰</li>
<li>基于延迟的路由不能保证来自相同地理位置的用户出于任何合规性原因将从同一位置提供服务</li>
<li>可以使用Route 53支持的除NS或SOA之外的任何记录类型来创建延迟资源记录集</li>
</ul>
<h2 id="故障转移策略（Failover）"><a href="#故障转移策略（Failover）" class="headerlink" title="故障转移策略（Failover）"></a>故障转移策略（Failover）</h2><ul>
<li>故障转移路由策略允许主动 - 被动故障转移配置，其中一个资源在可用时占用所有流量，而另一个资源在第一个资源不可用时占用所有流量。</li>
<li>Route 53运行状况检查代理将监视应用程序的每个位置/端点以确定可用性。</li>
<li>故障转移路由策略仅适用于公共托管区域</li>
</ul>
<h2 id="地理位置路由策略（Geo-DNS）"><a href="#地理位置路由策略（Geo-DNS）" class="headerlink" title="地理位置路由策略（Geo DNS）"></a>地理位置路由策略（Geo DNS）</h2><ul>
<li>地理位置路由策略使路由53能够根据用户的地理位置（即DNS查询源自的位置）响应DNS查询</li>
<li>常见用例包括<ul>
<li>内容的本地化和以用户语言呈现部分或全部网站</li>
<li>限制内容的分发仅限于您拥有发行权的位置。</li>
<li>以可预测，易于管理的方式平衡端点之间的负载，以便每个用户位置始终路由到同一端点。</li>
</ul>
</li>
<li>地理位置路由策略允许按洲，国家或州（仅在美国）指定地理位置</li>
<li>地理定位记录集，如果创建的话，用于例如重叠的地理区域。非洲大陆，然后是同一大洲的国家，优先考虑最小的地理区域，这允许将一个大陆的一些查询路由到一个资源，并查询该大陆上的选定国家的不同资源</li>
<li>地理定位的工作原理是将IP地址映射到位置，这些位置可能未映射到确切的地理位置</li>
<li>可以创建默认资源记录集来处理这些查询，也可以创建没有创建显式记录集的查询</li>
<li>如果未创建默认资源记录集，则Route 53对来自这些位置的查询返回“无应答”响应</li>
<li>无法创建指定相同地理位置的两个地理位置资源记录集</li>
<li>Route 53支持EDNS0的edns-client-subnet扩展（EDNS0为DNS协议添加了几个可选扩展。）以提高地理定位路由的准确性</li>
</ul>
<h1 id="AWS-Route-53-Resolver"><a href="#AWS-Route-53-Resolver" class="headerlink" title="AWS Route 53 Resolver"></a>AWS Route 53 Resolver</h1><h2 id="解析VPC和本地网络之间的DNS查询"><a href="#解析VPC和本地网络之间的DNS查询" class="headerlink" title="解析VPC和本地网络之间的DNS查询"></a>解析VPC和本地网络之间的DNS查询</h2><ul>
<li>Route 53 Resolver在VPC内提供自动DNS解析</li>
<li>默认情况下，Resolver会回答VPC域名的DNS查询，例如EC2实例或ELB负载均衡器的域名</li>
<li>Resolver对所有其他域名的公共名称服务器执行递归查找</li>
<li>但是，本地实例无法解析Route 53 DNS条目，而Route 53无法解析本地DNS条目</li>
<li>可以通过Direct Connect或VPN连接配置AWS VPC与本地网络之间的DNS解析</li>
<li>Route 53 Resolver是区域性的</li>
<li>要使用入站或出站转发，请在VPC中创建解析器端点</li>
<li>作为端点定义的一部分，指定要将入站DNS查询转发到的IP地址或要从其发出的出站查询的IP地址。 对于指定的每个IP地址，Resolver会自动创建VPC弹性网络接口</li>
</ul>
<h2 id="将-DNS-查询从网络上的解析程序转发到-Route-53-解析程序"><a href="#将-DNS-查询从网络上的解析程序转发到-Route-53-解析程序" class="headerlink" title="将 DNS 查询从网络上的解析程序转发到 Route 53 解析程序"></a>将 DNS 查询从网络上的解析程序转发到 Route 53 解析程序</h2><p><img src="https://i.loli.net/2019/08/26/7PEZxyOBLbNWR3h.png" alt="Resolver-inbound-endpoint.png"></p>
<ul>
<li>本地网络上的DNS解析器可以将DNS查询转发到指定VPC中的解析器。</li>
<li>这使DNS解析器能够轻松解析AWS资源的域名，例如EC2实例或Route 53私有托管区域中的记录。</li>
</ul>
<h2 id="将查询从-VPC-有条件地转发到您网络上的解析程序"><a href="#将查询从-VPC-有条件地转发到您网络上的解析程序" class="headerlink" title="将查询从 VPC 有条件地转发到您网络上的解析程序"></a>将查询从 VPC 有条件地转发到您网络上的解析程序</h2><p><img src="https://i.loli.net/2019/08/26/UPLo5bKJQHVxmIw.png" alt="Resolver-outbound-endpoint.png"></p>
<ul>
<li>配置解析程序，将它从 VPC中EC2实例收到的查询转发到您网络上的 DNS 解析程序</li>
<li>要转发选定的查询，可以创建解析程序规则，指定要转发的 DNS 查询的域名（例如 example.com），以及希望将查询转发到网络上的 DNS 解析程序的 IP 地址</li>
<li>如果查询与多个规则匹配（example.com、acme.example.com），解析程序会选择匹配最具体的规则 (acme.example.com) 并将查询转发到该规则中指定的IP地址</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/22/AWS-Storage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/AWS-Storage/" itemprop="url">AWS Storage</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T21:21:37+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="https://i.loli.net/2019/08/20/S5pGc6xsHIB8MlZ.jpg" alt="AWS——Storage (2).jpeg"></p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><blockquote>
<p>AWS提供多种基于云的存储选择，每个服务都具有独特的性能、持久性、可用性、成本和接口，以及其他特性(如可伸缩性和弹性)。在选择存储服务请考虑其适应场景和Anti-Patterns（不推荐）模式。（可参考下图）</p>
</blockquote>
<p><img src="https://i.loli.net/2019/08/20/17jtOg8lUSsuWQH.png" alt="002.png"><br><em>本文以下内容不涉及EC2 Instancestore、CloudFront、RDS、ElasticeCache等有关数据的存储，主要是以独立的存储服务提供数据存储与管理的服务组件，因为如instancestore是临时性的，在EC2的生命周期结束之后数据就会被删除，而RDS数据库的数据处理引擎和存储有着比较紧密的耦合度（不是指不可分离），不在这里阐述.</em></p>
<h1 id="S3-对象存储"><a href="#S3-对象存储" class="headerlink" title="S3(对象存储)"></a>S3(对象存储)</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>高度可扩展，可靠且低延迟的数据存储基础架构，成本极低。</li>
<li>通过一个简单的Web服务接口，可以在<font color="red">任何时间</font>从EC2内或Web上的<font color="red">任何位置</font>存储和检索<font color="red">任何数量</font>的数据。</li>
<li>write、read、delete等操作，每个对象大小1byte~5TB之间。</li>
<li>S3 bucket中的对象数量可以理解为无限的。</li>
<li>强安全控制，支持静态加密，并提供多种机制来提供对Amazon S3资源访问的细粒度控制（ACL、Policy、IAM）。</li>
<li>可扩展，允许许多单独的客户端或应用程序线程对Amazon S3数据进行并发读取或写入访问。</li>
<li>提供数据生命周期管理功能，允许用户定义规则以自动将Amazon S3数据存档到Amazon Glacier，或者在生命周期结束时删除数据。</li>
</ul>
<h2 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>存储和分发静态web内容和媒体<ul>
<li>静态网站托管，并仅为具有静态内容的网站提供高度可用、可扩展的解决方案，支持HTML、图像、视频和客户端脚本（如javascript）。</li>
<li>适用于快速增长的互联网网站，托管密集型数据，如视频、照片共享网站（Instagram，不需要考虑存储的供给问题）</li>
<li>每一个content都可以通过对象的唯一HTTP URL访问。</li>
<li>作为CDN溯源（Origin）站点，如搭配CloudFront会有更好的效果</li>
<li>借助S3的弹性设计，非常适合承载带宽要求极高的web内容</li>
</ul>
</li>
<li>大型对象数据存储<ul>
<li>可以与RDS或NoSQL数据库配合，用于存储大型对象，例如 文件或对象，而关联的元数据例（如名称，标签，注释等）可以存储在RDS或NoSQL数据库中，可以对其进行索引和查询，从而更快地访问相关数据。（对象存储系统并不像文件系统一样有自己的索引机制，所以其访问实际是由独立的URL实现的。）</li>
</ul>
</li>
<li>计算和大规模分析的数据存储（计算之后）<ul>
<li>通常用作计算和大规模分析的数据存储，例如金融交易分析，点击流分析（网站）和媒体转码数据。</li>
<li>借助其水平伸缩性，同时从多个计算节点访问数据而不受单个连接的限制。</li>
</ul>
</li>
<li>关键数据的备份和归档<ul>
<li>借助其数据高度持久性、架构可扩展性、数据安全方案，可用作数据备份和归档领域，并未业务连续性提供灾难恢复解决方案</li>
<li>数据冗余的存储region范围内（即覆盖AZ之间，）提供以上场景所需的高度持久的存储基础设施。</li>
<li>提供版本控制功能，用于关键数据意外删除。(need enable version  feature)</li>
</ul>
</li>
</ul>
<h2 id="Anti-Patterns（不建议）"><a href="#Anti-Patterns（不建议）" class="headerlink" title="Anti-Patterns（不建议）"></a>Anti-Patterns（不建议）</h2><ul>
<li>动态网站<ul>
<li>S3非常适合托管静态网站，但是无法托管需要服务器端交互，脚本或数据库交互的动态网站，而应该托管在Amazon EC2上。（也就是其本质是WORM属性，适合读场景，并不适合数据变化快的场景）</li>
</ul>
</li>
<li>备份和归档存储<ul>
<li>不频繁读取访问权限的长期归档存储的数据可以在Glacier中更经济有效地存储。</li>
</ul>
</li>
<li>结构化数据查询<ul>
<li>Amazon S3不提供查询功能，因此要读取对象，必须知道对象名称和键。相反，将S3与RDS或Dynamo DB配合，以存储、索引和查询关于Amazon S3对象的元数据</li>
<li>注意:S3现在提供了查询功能，也可以使用Athena（一种交互式查询服务，可使用此服务通过标准 SQL 在 Amazon S3 中轻松分析数据）</li>
</ul>
</li>
<li>快速变化的数据<ul>
<li>频繁更新的数据，建议使用具有较低读/写延迟的存储解决方案，如Amazon EBS卷、RDS或Dynamo DB。</li>
</ul>
</li>
<li>文件系统<ul>
<li>S3使用扁平的命名空间，不能作为独立的或通过POSIX兼容文件系统。但是可以通过使用分隔符（通常是’/‘或’’字符），可以构造键值模拟给定存储桶中文件系统的分层文件夹结构。（对象存储系统是扁平的结构，而文件系统是树状结构）</li>
</ul>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li>在同一region内，EC2访问S3速度很快。</li>
<li>S3在设计上，相较于Internet网络访问在服务器端延迟是相对很低的。</li>
<li>S3在扩展性，请求数和用户访问数，支持几乎无限数量的Web级应用程序。</li>
<li>对于多线程、多应用程序或多客户访问S3，则S3的总吞吐量通常是以线性增加的方式提供服务或响应需求。</li>
</ul>
<h2 id="冗余性-amp-可用性"><a href="#冗余性-amp-可用性" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>S3在所选地理范围内，通过多设备和多设施之间自动化、同步机制实现数据存储最高级别的数据持久性和可用性。</li>
<li>内置数据的纠错机制（Daemon模式）和高可用架构（没有单点故障）。</li>
<li>设计目标：每个对象99.999999999％（11个9）的持久性和一年内（使用周期内，每个region可能有差异）99.99％的可用性。</li>
<li>提供版本控制功能，以防意外删除或覆盖。</li>
<li>支持MFA（多重身份验证）模式控制存储桶的版本控制功能。（双重身份验证）</li>
<li>非关键和可重复的数据，例如缩略图，转码媒体等，可使用S3 Reduced Redundancy Storage（RRS），以较低的存储成本提供较低的耐用性。</li>
<li>RRS的设计目标是在给定的一年内为每个对象提供99.99%的耐久性。虽然RRS不如标准的Amazon S3耐用，但它的耐用性仍然是典型磁盘驱动器的400倍。</li>
</ul>
<h2 id="扩展性-amp-弹性"><a href="#扩展性-amp-弹性" class="headerlink" title="扩展性&amp;弹性"></a>扩展性&amp;弹性</h2><p>注：Elasticity and Scalability 对比，英文原文如下（个人觉得比较好的解释）</p>
<ul>
<li>Scalability is the ability of a system to handle the increased load on its current hardware and software resources. In a highly scalable system it is possible to increase the workload without increasing the resource capacity. Scalability supports any sudden surge in the demand/traffic with current set of resources.（可伸缩性是系统处理其当前硬件和软件资源上增加的负载的能力。 在高度可扩展的系统中，可以在不增加资源容量的情况下增加工作量。 可扩展性支持使用当前资源集的任何突然的需求/流量激增。）</li>
<li>Elasticity is the ability of a system to increase the workload by increasing the hardware/software resources dynamically. Highly elastic systems can handle the increased demand and traffic by dynamically commission and decommission resources. Elasticity is an important characteristic of Cloud Computing applications. Elasticity means how well your architecture is adaptable to workload in real time.（弹性是系统通过动态增加硬件/软件资源来增加工作负载的能力。 高弹性系统可以通过动态调试和停用资源来处理增加的需求和流量。 弹性是云计算应用程序的一个重要特征，意味着架构能够实时适应工作负载。）</li>
<li>S3旨在自动提供非常高的伸缩性、弹性。</li>
<li>S3 bucket几乎可以无限数量的存储对象数据和文件。</li>
<li>S3将自动管理扩展并将数据的冗余副本分发到同一区域中其他AZ中的存储设备上，所有这些都使用AWS的高性能基础架构。</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>S3为管理和数据操作提供标准的REST和SOAP Web服务API。（注 -不推荐使用HTTP上的SOAP支持，但仍可通过HTTPS使用它。 SOAP不支持新的Amazon S3功能。建议使用REST API或AWS SDK。）</li>
<li>S3提供易于使用的高级别的工具包或SDK，封装了包含底层API的不同语言（如Java，.NET，PHP和Ruby）。</li>
<li>S3命令行界面（CLI）提供一组常见操作的类高级Linux Amazon S3文件命令，例如ls，cp，mv，sync等。还提供执行递归上载和下载的功能使用文件夹级别的S3命令，并支持并行传输。</li>
<li>管理控制台提供简单的基于Web的用户界面轻松创建和管理Amazon S3存储桶，上载和下载对象以及浏览Amazon S3存储桶内容的功能。</li>
<li>所有接口都能够将S3对象（文件）存储在唯一命名的存储桶（top-level folders）中，每个对象在该存储桶中的都具有唯一对象标识符（key id）。</li>
</ul>
<h1 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>极低成本的存储服务，为数据备份和存档提供高度安全，持久和灵活的存储。</li>
<li>可靠地存储数据，并且每月只需0.01美元每千兆字节。（价格可能变动）</li>
<li>将操作和扩展存储的管理负担转移到AWS，例如容量规划、硬件供应、数据复制、硬件故障检测和修复，或耗时的硬件迁移等。（用户只需关注其归档服务即可，其他一概不需要care）</li>
<li>数据作为归档文件存储在Glacier中，归档文件可以表示单个文件，也可以表示多个文件合成一个归档文件。</li>
<li>通过IAM控制访问存储在Vault中的存档文件。</li>
<li>从Vaults检索存档需要启动一个job,并且可能需要大约3-5个小时才能取回数据。</li>
<li>Glacier通过使用S3数据生命周期管理策略将数据从S3移动到Glacier，从而与Amazon S3无缝集成。<strong>（其实数据是不能直接归档到Glacier的，需要经过S3）</strong></li>
<li>AWS Import / Export可用于加速使用便携式存储设备将大量数据移动到Amazon Glacier进行存储归档。</li>
</ul>
<h2 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>Glacier是理想的长期档案解决方案，不经常访问的数据存档企业信息，媒体资产，研究和科学数据，数字保存和磁带更换的最佳替换者。（总之一句话，面向归档存储。）</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）"><a href="#Anti-Patterns（不建议模式）" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>快速变化数据<ul>
<li>频繁更新的数据，建议使用具有较低读/写延迟的存储解决方案，如Amazon EBS卷、RDS或Dynamo DB。</li>
</ul>
</li>
<li>实时数据访问<ul>
<li>无法实时访问存储在Glacier中的数据，并且需要启动用于对象检索的job，检索时间范围为3-5小时。若需要立即访问，Amazon S3是更好的选择。</li>
</ul>
</li>
</ul>
<h2 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h2><ul>
<li>Glacier是一种低成本存储服务，旨在存储不经常访问且使用寿命长的数据。</li>
<li>Glacier的工作通常在3到5个小时内完成（默认）。</li>
<li>加速检索1<del>5分钟，批量检索5</del>12H（加费用）</li>
</ul>
<h2 id="持久性和可用性"><a href="#持久性和可用性" class="headerlink" title="持久性和可用性"></a>持久性和可用性</h2><ul>
<li>Glacier将数据冗余地存储在多个基础设施中以及每个设施内的多个存储设备上</li>
<li>Glacier旨在为存档提供99.999999999％（11个9）的平均年度耐久性。</li>
<li>Glacier会在上传归档返回SUCCESS之前，将数据同步存储在多个设施中以确保数据一致性。</li>
<li>Glacier定期执行的系统数据完整性检查，并可自动进行自我修复，以确保数据完整性。</li>
</ul>
<h2 id="扩展性和弹性"><a href="#扩展性和弹性" class="headerlink" title="扩展性和弹性"></a>扩展性和弹性</h2><ul>
<li>单个存档文件上限限制为40 TB，但Glacier服务中存储的数据总量没有限制。</li>
<li>无论是存储数PB还是千兆，Glacier都可以扩展以满足不断增长且通常无法预测的存储容量要求， Glacier会根据需要自动扩展或缩小存储。</li>
</ul>
<h2 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h2><ul>
<li>Glacier提供标准的原生REST Web服务接口，以及Java和.NET SDK。</li>
<li>AWS管理控制台或Glacier API可用于创建存储Vault以组织Glacier中的存档。</li>
<li>Glacier api可用于上传和检索归档文件，监视作业的状态，还可以配置Vault，以便在作业完成时通过Amazon SNS发送通知。</li>
<li>使用对象生命周期管理，从S3到Glacier提供自动，策略驱动的归档。</li>
<li>S3 api提供了一个恢复操作，检索过程同样需要3-5个小时。</li>
<li>在检索时，检索到的对象的副本将放置在S3 RRS存储中（一定的保留期）;原始存档对象仍存储在Amazon Glacier中，仍需要为存储付费，除非删除。</li>
<li>在S3中使用Amazon Glacier作为存储层（Class）时，使用Amazon S3 API，当使用“native（原生）” Glacier时使用Glacier API。</li>
<li>通过S3归档到Glacier的对象只能通过Amazon S3 api或AWS管理控制台列出和检索—它们不能作为Glacier vault中的归档文件显示。</li>
</ul>
<h1 id="为数据选择合适的S3分类"><a href="#为数据选择合适的S3分类" class="headerlink" title="为数据选择合适的S3分类"></a>为数据选择合适的S3分类</h1><p><img src="https://i.loli.net/2019/08/20/4ecOy7jliw3dHZr.jpg" alt="存储分类-S3.jpeg"></p>
<h3 id="S3-Standard"><a href="#S3-Standard" class="headerlink" title="S3 Standard"></a>S3 Standard</h3><ul>
<li>活跃且频繁访问数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1755/GB</li>
</ul>
<h3 id="S3-Intelligent-tiering-（利用了大数据技术进行分层处理）"><a href="#S3-Intelligent-tiering-（利用了大数据技术进行分层处理）" class="headerlink" title="S3 Intelligent_tiering （利用了大数据技术进行分层处理）"></a>S3 Intelligent_tiering （利用了大数据技术进行分层处理）</h3><ul>
<li>访问模式不确定数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1030/GB~0.1775/GB</li>
<li>最小存储周期</li>
</ul>
<h3 id="S3-Standard-IA"><a href="#S3-Standard-IA" class="headerlink" title="S3 Standard-IA"></a>S3 Standard-IA</h3><ul>
<li>不频繁访问数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.1030/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-One-Zone-IA"><a href="#S3-One-Zone-IA" class="headerlink" title="S3 One Zone-IA"></a>S3 One Zone-IA</h3><ul>
<li>可重建数据</li>
<li>毫秒访问延迟</li>
<li>≥3个可用区</li>
<li>￥0.0824/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-Glacier"><a href="#S3-Glacier" class="headerlink" title="S3 Glacier"></a>S3 Glacier</h3><ul>
<li>归档数据</li>
<li>分钟到小时级别恢复时间</li>
<li>≥3个可用区</li>
<li>￥0.0300/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h3 id="S3-Glacier-Deep-Archive"><a href="#S3-Glacier-Deep-Archive" class="headerlink" title="S3 Glacier Deep Archive"></a>S3 Glacier Deep Archive</h3><ul>
<li>归档数据</li>
<li>小时级别恢复时间（12~48）</li>
<li>≥3个可用区</li>
<li>￥0.010800/GB</li>
<li>取回成本高（按GB）</li>
<li>最小存储周期</li>
<li>最小对象大小</li>
</ul>
<h1 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul>
<li>EBS为EC2实例提供持久的块级存储</li>
<li>EBS独立于EC2实例，具备生命周期、通过网络连接非依赖实例的存储</li>
<li>EBS卷通过附加到实例，可以像物理硬盘驱动器一样使用，通过文件系统格式化之后，即可用文件系统的I/O接口实现数据的存储与管理</li>
<li>EBS卷可用于引导EC2实例(仅Amazon EBS-root ami)，多个Amazon EBS卷可附加到一个EC2实例（多对一）</li>
<li>EBS卷在单一时间只能挂载一个EC2实例。（不支持1对多挂载）</li>
<li>EBS提供基于时间点快照的功能，这些快照保存在S3中。快照可用于实例化新的EC2卷并保护数据以实现长期保存</li>
<li>EBS快照也可以跨AWS区域复制，从而可以更轻松地利用多个AWS区域进行地理扩展，进行数据中心迁移和灾难恢复</li>
</ul>
<h2 id="使用范例-2"><a href="#使用范例-2" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>EBS适用于数据变化相对频繁并且需要长期持久化的场景</li>
<li>EBS卷提供对裸块级存储的访问，特别适合用作数据库或主文件系统存储</li>
<li>预配置IOPS卷特别适合与需要速度且具有数据一致性的随机磁盘读写的数据库应用程序一起使用</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）-1"><a href="#Anti-Patterns（不建议模式）-1" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>临时性数据<ul>
<li>EBS卷独立于EC2生命周期</li>
<li>对于cache、buffer、queue等数据，建议使用本地存储，SQS或Elastice cache</li>
</ul>
</li>
<li>持久性数据<ul>
<li>年持久性可达99.5～99.9%（最近一次修改数据少于20GB的EBS卷），数据修改约频繁，其持久性会下降</li>
<li>对于数据持久性有更高要求的，建议使用S3或Glacier</li>
</ul>
</li>
<li>静态数据或网站内容<ul>
<li>对于数据很少更改的静态web内容，使用EC2的EBS卷提供 web服务页面</li>
<li>S3是存储这种固定信息的更经济有效和可伸缩的解决方案，并且可以直接从S3提供服务。</li>
</ul>
</li>
</ul>
<h2 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h2><ul>
<li>EBS提供两种卷类型：标准卷和预配置IOPS卷，它们在性能和价格模型上有所不同，根据应用程序的需要的存储性能和成本进行选择</li>
<li>可以使用RAID 0或逻辑卷管理器软件在多个EBS卷之间进行条带EBS卷，从而聚合提高可用的IOPS、吞吐量和卷大小</li>
<li>标准卷可为普通或突发I / O要求的应用程序提供经济高效的数据吞吐。标准卷也非常适合用作启动卷，其中突发功能提供快速的实例启动时间</li>
<li>预配置IOPS卷旨在为I / O密集型工作负载（如数据库）提供可预测的高性能。使用预配置IOPS，在创建卷时指定IOPS， EBS在指定的生命周期提供一致数据速率</li>
<li>EBS卷是通过网络连接挂载的，实例执行的其他网络I / O以及共享网络上的负载会影响EBS卷的性能。启动EBS优化实例，在EC2和EBS之间提供专用的吞吐量，并使实例能够充分利用Amazon EBS卷上提供的IOPS</li>
<li>根据需求将EBS卷配置为EBS标准或EBS预配置IOPS。或者，也可以对数据进行条带化</li>
</ul>
<h2 id="冗余性-amp-可用性-1"><a href="#冗余性-amp-可用性-1" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>EBS卷旨在提供高可用性和可靠性</li>
<li>EBS卷数据在<strong><font color="red">可用区</font></strong>中的多个服务器之间复制，以防止任何单个组件发生故障而导致数据丢失</li>
<li>EBS卷的持久性取决于卷的大小以及自上次快照以来更改的数据量。快照是增量的时间点备份，仅包含自上次快照以来更改的数据块。自最近一次快照以来，使用20 GB或更少修改数据运行的EBS卷的年度故障率（AFR）可能在0.1％到0.2％之间。自最近一次快照以来具有超过20 GB修改数据的EBS卷预期有更高的故障率与修改数据的增加大致成比例。因此，建议创建快照的频度更大一些，以最大限度地提高其EBS数据的持久性和可用性</li>
<li>EBS快照提供更快的磁盘克隆或磁盘映像机制，常用于备份，共享和灾难恢复</li>
<li>EBS 快照与 Amazon Data Lifecycle Manager (DLM) 策略配合使用，以自动执行快照管理</li>
</ul>
<h2 id="可扩展性-amp-弹性"><a href="#可扩展性-amp-弹性" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>EBS卷可以通过修改卷的大小（增大）、IOPS，快速地进行配置和发布，以适应不断变化的存储需求</li>
<li>无法在线缩小卷的大小（不确定是否有更新）</li>
</ul>
<h2 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h2><ul>
<li>通过SOAP和REST格式为Amazon EBS提供管理API，可用于为<strong><font color="red">EC2实例</font></strong> reate, delete, describe, attach, and detach ，以及从<font color="red"><strong>EBS创建</strong></font>，删除和快照 到S3，将快照从一个区域复制到另一个区域</li>
<li>AWS管理控制台提供以上相同的功能</li>
</ul>
<h1 id="EFS"><a href="#EFS" class="headerlink" title="EFS"></a>EFS</h1><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ul>
<li>提供简单，可扩展的文件存储服务，以便与EC2实例一起使用</li>
<li>存储空间是弹性的，随着文件的添加和删除而自动增长和收缩</li>
<li>挂载在到EC2实例上时，提供标准文件系统接口和文件系统访问语义</li>
<li>在共享模式下工作，多个EC2实例可以同时访问EFS文件系统，EFS提供共享数据服务</li>
<li>可以在EC2实例上并发运行工作负载和应用程序</li>
<li>使用AWS Direct Connect连接到VPC时，可以在本地数据中心服务器挂载共享文件系统使用</li>
<li>可以挂载到本地服务器上，以便数据集迁移到EFS，将本地数据备份到EFS</li>
<li>专为高可用性和耐用性而设计，可为广泛的工作负载和应用程序提供性能，包括大数据和分析，媒体处理工作流，内容管理，Web服务和主目录</li>
<li>基于 Linux 的工作负载</li>
</ul>
<h2 id="使用范例-3"><a href="#使用范例-3" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>跨可用区、区域和 VPC 访问文件系统，并可以通过 AWS Direct Connect 或 AWS VPN 在数千个 Amazon EC2 实例与本地服务器之间共享文件</li>
<li>超高吞吐量的高度并行化的横向扩展工作负载到单线程的延迟敏感型工作负载，均适用。直接迁移企业应用程序、大数据分析、Web 服务和内容管理、应用程序开发和测试、媒体和娱乐工作流程、数据库备份和容器存储。<br>直接迁移企业应用程序、大数据分析、Web 服务和内容管理、应用程序开发和测试、媒体和娱乐工作流程、数据库备份和容器存储。</li>
</ul>
<h2 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h2><ul>
<li>提供标准和不经常访问存储类。标准存储类是为活动文件系统工作负载而设计的，EFS 不频繁访问 (EFS IA) 是一种成本较低的存储类，针对不经常访问的文件进行了成本优化。EFS 文件系统透明地提供来自两个存储类的数据转换。</li>
<li>所有文件系统的稳定基准性能为每 TB 标准类存储 50MB/s </li>
<li>EFS 支持一个到数千个EC2 实例同时连接一个文件系统</li>
<li>性能模式<ul>
<li>通用性能模式，非常适合对延迟敏感的使用案例，如 Web 服务环境、内容管理系统、主目录和一般文件服务。（默认）</li>
<li>最大 I/O 性能模式，扩展到更高级别的聚合吞吐量和每秒操作数，但代价是稍高的文件操作延迟。诸如大数据分析、媒体处理和基因组分析等高度并行化的应用程序和工作负载可以受益于这种模式。</li>
</ul>
</li>
<li>吞吐量模式<ul>
<li>突增吞吐量，Amazon EFS 上的吞吐量将随着标准存储类别中存储的文件系统的增大而增加，都能突增到 100 MB/秒的吞吐量</li>
<li>预置吞吐量使 Amazon EFS 客户能够预置文件系统的吞吐量（无需考虑存储的数据量），从而优化文件系统的吞吐性能，以满足应用程序的需求</li>
</ul>
</li>
</ul>
<h2 id="冗余性-amp-可用性-2"><a href="#冗余性-amp-可用性-2" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>每个文件系统对象（即目录、文件和链接）均会在多个可用区中进行冗余存储。此外，文件系统还可以从其所在区域中的各个可用区同时访问，这意味着在构建应用程序时，可以使其从区域中的一个可用区故障转移到其他可用区，从而确保应用程序的高可用性。挂载目标本身即具有高可用性。<br>可扩展性&amp;弹性</li>
<li>随文件系统增减文件的操作自动进行扩展和收缩，因此不需要进行存储的采购和预配置工作</li>
</ul>
<h2 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用标准 Linux 挂载命令和文件系统的 DNS 名称将文件系统挂载到基于 Linux 的 EC2 实例上</li>
<li>为了简化对 EFS 文件系统的访问，建议使用 EFS 挂载助手实用程序</li>
<li>EFS 使用网络文件系统版本 4 (NFS v4) 协议</li>
<li>DataSync 工具提供将现有文件系统与 Amazon EFS 安全同步，可借助VPN或DX。</li>
<li>通过 AWS 管理控制台、AWS 命令行界面 (CLI) 或 EFS API（以及各种语言的软件开发工具包）来管理文件系统。通过控制台、API 和软件开发工具包，可以创建和删除文件系统、配置文件系统的访问方式、创建和编辑文件系统标签、启用预置吞吐量和生命周期管理等功能，以及显示文件系统的详细信息。</li>
</ul>
<h1 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h1><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ul>
<li>Storage Gateway是一种将本地软硬件设备与基于云的存储相连接的服务，可在本地IT环境与AWS的存储基础架构之间提供无缝，安全的集成。</li>
<li>Storage Gateway可以将数据安全地存储到AWS云端，以实现可扩展且经济高效的数据存储。</li>
<li>在本地提供繁的数据访问并保障低延迟，同时还可通过加密将数据安全存储在S3中。</li>
<li>对于灾难恢复场景，可以作为云托管解决方案与EC2一起联动，镜像生产环境到云端。</li>
<li>Storage Gateway 可以配置为<ul>
<li>Gateway-cached volumes<ul>
<li>网关缓存卷利用S3进行主要数据备份，同时在本地保留经常访问的数据</li>
<li>最大限度地减少了扩展本地存储基础架构的需求，同时为应用程序提供对其频繁访问的数据的低延迟访问</li>
<li>写入卷的数据存储在S3中，只有最近写入和最近读取的数据的缓存本地存储在本地存储硬件上</li>
</ul>
</li>
<li>Gateway-stored volumes<ul>
<li>网关存储的卷在本地存储完整的主要数据，同时异步地将数据备份到AWS</li>
<li>这些卷为本地应用程序提供了对其整个数据集的低延迟访问，同时提供了持久的异地备份</li>
<li>写入网关存储卷的数据存储在本地存储硬件上，并以EBS快照的形式异步备份到S3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用范例-4"><a href="#使用范例-4" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>企业组织之间文件共享</li>
<li>将现有的本地备份应用程序备份到S3上的和灾难恢复场景，以及数据镜像到云端</li>
</ul>
<h2 id="Anti-Patterns（不建议模式）-2"><a href="#Anti-Patterns（不建议模式）-2" class="headerlink" title="Anti-Patterns（不建议模式）"></a>Anti-Patterns（不建议模式）</h2><ul>
<li>数据库存储<ul>
<li>对于数据库存储或备份，使用EBS卷的EC2实例是数据库存储和工作负载的最佳选择</li>
</ul>
</li>
</ul>
<h2 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h2><ul>
<li>由于Storage Gateway VM介于应用程序，本地存储和S3之间，因此所遇到的性能将取决于诸多因素，包括本地磁盘的速度和配置，iSCSI initiator与网关之间的网络带宽，Gateway VM的数量，以及VM和S3的带宽</li>
<li>对于Gateway-cached volumes，为了提供对本地应用程序的低延迟读访问，重要的是提供足够的本地缓存存储来存储最近访问的数据</li>
<li>Storage Gateway有效地使用Internet带宽将数据上传到AWS</li>
<li>Storage Gateway仅传输增量更改（已更改的数据），从而最大限度地减少通过Internet发送的数据量</li>
<li>通过在AWS和AWS之间建立连接，AWS Direct Connect可用于进一步提高吞吐量并降低网络成本</li>
</ul>
<h2 id="冗余性-amp-可用性-3"><a href="#冗余性-amp-可用性-3" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>AWS Storage Gateway通过将数据传输到S3来确保其数据持久性</li>
<li>S3提供11个9的持久性</li>
<li>S3定期执行系统的数据完整性检查并自动完成自我修复</li>
</ul>
<h2 id="可扩展性-amp-弹性-1"><a href="#可扩展性-amp-弹性-1" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>AWS Storage Gateway将数据存储在Amazon S3中，借助S3提供高级别的可扩展性和弹性</li>
</ul>
<h2 id="接口-4"><a href="#接口-4" class="headerlink" title="接口"></a>接口</h2><ul>
<li>通过AWS管理控制台可用于下载AWS Storage Gateway VM映像，在网关缓存或网关存储配置之间进行选择，通过将网关与AWS账户相关联来激活部署，选择AWS区域，以及创建 AWS Storage Gateway卷并将这些卷作为iSCSI设备连接到本地应用程序服务器</li>
</ul>
<h1 id="Snow-Family"><a href="#Snow-Family" class="headerlink" title="Snow Family"></a>Snow Family</h1><p>Snow 系列是一系列物理设备，可帮助将大量数据传入和传出云，无需依赖网络。TB数据通过internet传输其稳定性、可靠性、费用、时间都无法和Snow设备相媲美。</p>
<h2 id="Snowball"><a href="#Snowball" class="headerlink" title="Snowball"></a>Snowball</h2><ul>
<li>是一种PB级数据传输服务，内置安全如手提箱大小的移动设备，，可快速高效地将数据移入和移出AWS云端</li>
<li>将数据导入到S3 </li>
<li>转移数据从开始到结束大约1周</li>
<li>通常用于传送（移动）TB量级数据，如分析数据、医疗保健和生命科学数据、视频库、图像存储库、备份和存档，作为数据中心停用，磁带数据替换者或大规模应用数据迁移</li>
</ul>
<h2 id="Snoaball-Edge"><a href="#Snoaball-Edge" class="headerlink" title="Snoaball Edge"></a>Snoaball Edge</h2><ul>
<li>设备具有更大的容量和嵌入计算平台，可执行简单的处理任务</li>
<li>这些设备可以安装在机架上并通过集群化一起使用，以便更轻松地在极其偏远的位置收集和存储数据</li>
<li>Storage Optimized 和 Compute Optimized类型</li>
<li>可以在时断时续的环境（例如制造业、工业和运输）中或在极其偏远的位置（例如军事或海事作业）使用这些设备，然后再将其运回 AWS</li>
<li>Snowball Edge 可使用 AWS Greengrass 和 Lambda 函数在网络边缘提供无服务器计算应用程序。</li>
<li>常见使用案例包括 IoT 传感器流捕获、动态媒体转码、图像压缩、指标聚合以及工业控制信令与警报。</li>
</ul>
<h2 id="Snowmobile"><a href="#Snowmobile" class="headerlink" title="Snowmobile"></a>Snowmobile</h2><ul>
<li>Snowmobile 是一个 45 英尺长的坚固集装箱，可迁移高达 100PB 的数据（相当于 1250 台 AWS Snowball 设备），非常适合数 PB 级或 EB 级数字媒体迁移和数据中心关闭的情况。</li>
<li>Snowmobile 在抵达客户站点后显示为网络连接数据存储，可实现更加安全的高速数据传输。将数据传输到 Snowmobile 后，Snowmobile 会被运回 AWS 区域，而数据会加载到 Amazon S3 中。</li>
<li>Snowmobile 防篡改、防水，具有温度控制，配备有多层逻辑和物理安全机制，包括加密、消防、专职安全人员、GPS 跟踪、警报监控、全天候视频监控以及运输过程中的护送安全车辆。</li>
</ul>
<h2 id="功能场景"><a href="#功能场景" class="headerlink" title="功能场景"></a>功能场景</h2><table>
<thead>
<tr>
<th>—</th>
<th>Snowball</th>
<th>SnowballEdge</th>
<th>Snowmobile</th>
</tr>
</thead>
<tbody><tr>
<td>使用情景</td>
<td>数据迁移</td>
<td>通过板载设备迁移数据预处理选项</td>
<td>数据迁移</td>
</tr>
<tr>
<td>存储容量</td>
<td>50TB 和 80TB</td>
<td>100TB</td>
<td>100PB</td>
</tr>
<tr>
<td>板载计算选项</td>
<td>不适用</td>
<td>AWS Lambda| AMI</td>
<td>不适用</td>
</tr>
<tr>
<td>加密</td>
<td>有，256 位</td>
<td>有，256 位</td>
<td>有，256 位</td>
</tr>
<tr>
<td>通过 NFS 传输</td>
<td>不适用</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>通过 HDFS 传输</td>
<td>是</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>通过 S3 API 传输</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>集群</td>
<td>不适用</td>
<td>是，最多 20 个节点</td>
<td>不适用</td>
</tr>
<tr>
<td>可安装机架</td>
<td>架子</td>
<td>是</td>
<td>不适用</td>
</tr>
<tr>
<td>符合 HIPAA 要求</td>
<td>是，符合要求</td>
<td>是，符合要求</td>
<td>否</td>
</tr>
<tr>
<td>常规作业生命周期</td>
<td>数天-数周</td>
<td>数据迁移：数天-数周本地计算：数周-数月</td>
<td>数周-数月</td>
</tr>
<tr>
<td>最长作业时间</td>
<td>90 天</td>
<td>数据迁移：90 天；本地计算：120 天</td>
<td>120-360 天</td>
</tr>
</tbody></table>
<h2 id="性能-5"><a href="#性能-5" class="headerlink" title="性能"></a>性能</h2><ul>
<li>Snowball 拥有 10Gbps 的网络接口，配有 RJ45、SFP+ 铜缆和 SFP+ 光学网络接口</li>
<li>Snowball 客户端将以条件允许的最快速度将数据复制到 Snowball（例如，不到一天就可以复制 48TB 的数据，具体取决于本地环境）</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>云迁移</li>
<li>灾难恢复</li>
<li>数据中心停用</li>
<li>内容分配（定期接收或需要与客户、消费者或业务伙伴共享大量数据）</li>
</ul>
<h2 id="可扩展性-amp-冗余性"><a href="#可扩展性-amp-冗余性" class="headerlink" title="可扩展性&amp;冗余性"></a>可扩展性&amp;冗余性</h2><ul>
<li>单个 Snowball 设备可以传输数 TB 的数据，并且可以并行使用多台设备将数 PB 的数据传入或传出 Amazon S3 存储桶；或者在设置生命周期管理策略时，单个 Snowball 设备可以自动将数据从 S3 分层到 Amazon Glacier </li>
<li>多台 Snowball Edge 设备可以充当一个可扩展存储与计算池，持久性更高</li>
<li>一台 Snowmobile 一次可以传输高达 100PB 的数据，这相当于大约 1250 台 AWS Snowball 设备传输的数据量</li>
<li>数据持久性借助S3或Glacier提供11个9的持久性。</li>
</ul>
<h2 id="接口-5"><a href="#接口-5" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用 AWS 管理控制台创建一项或多项任务，申请一台或多台 Snowball 设备（具体取决于需要传输的数据量），然后下载并安装 Snowball 客户端（简称“客户端”）。当设备抵达后，将其连接到本地网络，手动或使用 DHCP 设置 IP 地址，然后使用客户端确定要复制的目录。客户端会自动加密数据并将其复制到设备，然后在传输作业完成时通知。</li>
<li>Snowball 任务管理 API 提供对 Snowball 任务创建和管理功能的编程式访问。这是一种基于标准的简单 REST Web 服务接口，旨在与任何 Internet 开发环境配合使用。</li>
<li>S3 SDK Adapter for Snowball 可以为 Snowball 客户端提供兼容 S3 的接口，以便在 Snowball 上读取和写入数据。</li>
</ul>
<h1 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h1><blockquote>
<p><strong>注：此处的备份服务并不是通常意义的特定应用程序及其数据备份，AWS提供的备份服务都是基于以上存储服务自身提供的备份服务，和NBU、Commvault、Veeam等专用备份有着很大区别。</strong></p>
</blockquote>
<p>AWS Backup 是一种完全托管的备份服务，使用 AWS Storage Gateway 轻松地集中自动管理云中以及本地的各种 AWS 服务的数据备份工作。支持集中配置备份策略并监控<font color="orange" size="2"> EBS 卷（快照）、RDS 数据库（不含Aurora，快照）、DynamoDB 表、EFS 文件系统和 Storage Gateway 卷(快照)。</font></p>
<h2 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h2><ul>
<li>集中式备份管理</li>
<li>基于策略的备份（即通常意义上的备份计划）</li>
<li>基于标记的备份策略（AWS 资源进行标记来对其应用备份计划）</li>
<li>备份活动监控（提供dashboard 审核备份和还原备份活动）</li>
<li>支持生命周期策略，可以将备份存储转移到冷存储层中</li>
<li>支持独立于源数据的备份数据存储和加密，以及基于资源的访问策略</li>
</ul>
<h2 id="使用范例-5"><a href="#使用范例-5" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>业务和法规备份合规性要求</li>
<li>原生云备份</li>
<li>混合备份，云中和本地的应用程序数据备份，结合Storage Gateway集成</li>
</ul>
<h2 id="接口-6"><a href="#接口-6" class="headerlink" title="接口"></a>接口</h2><ul>
<li>AWS集中的备份控制台、备份 API 以及 AWS Command Line Interface (AWS CLI)，用于管理备份</li>
</ul>
<h1 id="Instance-Store-Volumes"><a href="#Instance-Store-Volumes" class="headerlink" title="Instance Store Volumes"></a>Instance Store Volumes</h1><h2 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h2><ul>
<li>实例存储卷（临时卷）提供临时块级存储，与EC2实例位于同一物理服务器上的预配置和连接的磁盘存储块组成</li>
<li>实例存储的存储量取决于实例类型，较大的实例同时提供更多和更大的实例存储卷。较小的实例类型(如微实例)只能用于卷启动。</li>
<li>存储优化实例提供针对例如特定用途的特殊用途实例存储。 如HI1提供非常快速的固态驱动器（SSD）支持的实例存储，能够支持超过120,000随机读取IOPS，针对非常高的随机I / O性能和低IOPS成本进行了优化。 同时，HS1实例针对非常高的存储密度，低存储成本和高顺序I / O性能进行了优化。</li>
<li>与EBS卷不同，实例存储卷不能分离或附加到另一个实例</li>
</ul>
<h2 id="使用范例-6"><a href="#使用范例-6" class="headerlink" title="使用范例"></a>使用范例</h2><ul>
<li>EC2本地实例存储卷提供快速，免费（即包含在EC2实例的价格中）“临时卷”最适合存储不断变化的临时数据，例如buffers，cache，暂存数据或者可重新生成数据，或者为了持久性而复制的数据</li>
<li>高I / O实例提供SSD支持的实例存储卷，非常适合许多高性能数据库工作负载。 如应用程序包括像Cassandra和MongoDB这样的NoSQL数据库。</li>
<li>高存储实例支持每个EC2实例更高的存储密度，非常适合在非常大的数据集中受益于高顺序I / O性能的应用程序。 例如应用程序包括数据仓库，Hadoop存储节点，地震分析，群集文件系统等。<br>Anti-Patterns（不建议模式）</li>
<li>持久性数据<ul>
<li>对于持久性虚拟磁盘存储，类似于物理磁盘驱动器，用于文件或其他必须持续时间超过EC2实例生命周期的数据， EBS卷或S3更合适。</li>
</ul>
</li>
<li>关系型数据库数据<ul>
<li>在大多数情况下，关系数据库要求存储在EC2实例的生命周期之后持续存在，这使得EBS卷成为更好的选择。</li>
</ul>
</li>
<li>共享数据存储<ul>
<li>实例存储卷专用于单个EC2实例，无法与其他系统或用户共享。如果需要可以从一个实例分离并连接到其他实例的存储，或者需要能够轻松共享数据，那么S3或EBS卷是更好的选择。</li>
</ul>
</li>
<li>快照<ul>
<li>如果要使用基于时间点磁盘快照的便利性，长期持久性，可用性和可共享性，则EBS卷是更好的选择。</li>
</ul>
</li>
</ul>
<h2 id="性能-6"><a href="#性能-6" class="headerlink" title="性能"></a>性能</h2><ul>
<li>在大多数EC2实例家族中，非基于ssd的实例存储卷具有与标准EBS卷类似的性能</li>
<li>EC2实例和本地实例存储卷位于同一物理服务器中，与存储的交互非常快，尤其是对于顺序访问</li>
<li>提高聚合IOPS或提高顺序磁盘吞吐量，可以使用RAID 0（磁盘条带化）软件将多个实例存储卷组合在一起</li>
<li>由于磁盘的带宽不受网络限制，因此多个实例卷的聚合顺序吞吐量可能高于相同容量的EBS卷</li>
<li>EC2高I / O实例中的SSD实例存储卷可提供数万至数十万随机IOPS，低延迟，4 KB</li>
<li>由于SSD设备的I/O特性，写性能在生命周期是是可变的</li>
<li>EC2高存储实例上的实例存储卷提供非常高的存储密度和高顺序读写性能。当使用块大小为2 MB时，高存储实例能够提供2.6 GB/秒的顺序读写性能</li>
</ul>
<h2 id="冗余性-amp-可用性-4"><a href="#冗余性-amp-可用性-4" class="headerlink" title="冗余性&amp;可用性"></a>冗余性&amp;可用性</h2><ul>
<li>不应用作持久磁盘存储，并且仅在关联EC2实例的生命周期内持续存在</li>
</ul>
<h2 id="可扩展性-amp-弹性-2"><a href="#可扩展性-amp-弹性-2" class="headerlink" title="可扩展性&amp;弹性"></a>可扩展性&amp;弹性</h2><ul>
<li>本地实例存储卷绑定到特定的EC2实例，并且对于给定的EC2实例类型，本地实例存储卷的数量和大小是固定的，因此该存储的可伸缩性和弹性绑定到EC2实例的规格限制</li>
</ul>
<h2 id="接口-7"><a href="#接口-7" class="headerlink" title="接口"></a>接口</h2><ul>
<li>使用EC2 API和AWS管理控制台的块设备映射功能指定实例存储卷</li>
<li>对于EC2实例，实例存储卷的显示方式与本地磁盘驱动器类似。写入实例存储卷并从中读取数据，请使用所选操作系统的本地文件系统I / O接口</li>
</ul>
<h1 id="Reffer"><a href="#Reffer" class="headerlink" title="Reffer"></a>Reffer</h1><ol>
<li><a href="http://jayendrapatil.com/" target="_blank" rel="noopener">http://jayendrapatil.com/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/21/AWS-Direct-Connect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/AWS-Direct-Connect/" itemprop="url">AWS Direct Connect</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T21:40:54+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Direct-Connect-Overview"><a href="#Direct-Connect-Overview" class="headerlink" title="Direct Connect Overview"></a>Direct Connect Overview</h2><ul>
<li>AWS Direct Connect是一种网络服务，它是一种替代Internet来利用AWS云服务的一种方案</li>
<li>通过标准的以太网光纤电缆将内部网络链接到 AWS Direct Connect 位置。电缆的一端接到用户侧路由器，另一端接到 AWS Direct Connect 路由器</li>
<li>可以使用1Gbps和10Gbps端口建立直接连接。可以从任何支持AWS Direct Connect的APN合作伙伴订购50Mbps，100Mbps，200Mbps，300Mbps，400Mbps和500Mbps的速度</li>
<li>有了此连接以后，可以创建直接连接到公共 AWS 服务（如 Amazon S3）或 Amazon VPC 的虚拟接口，从而绕过网络路径中的 Internet 服务提供商</li>
<li>AWS Direct Connect位置提供对与其关联的区域中的Amazon Web Services的访问，以及对其他美国区域的访问（如果是美国地区的Direct Connect）。例如，可以为美国的任何AWS Direct Connect位置配置单个连接，并使用它来访问所有美国区域和AWS GovCloud（美国）中的公共AWS服务。</li>
<li>每个AWS Direct Connect位置都可以连接到地理位置最近的AWS区域内的所有可用区</li>
<li>公有区域或AWS GovCloud (US)中的 AWS Direct Connect 位置可以访问任何其他公有区域（不包括中国(北京和宁夏)）中的公有服务</li>
</ul>
<p><img src="https://i.loli.net/2019/08/21/6VWEui91R57Yyjm.png" alt="direct_connect_overview.png"></p>
<h2 id="Direct-Connect-Advantages"><a href="#Direct-Connect-Advantages" class="headerlink" title="Direct Connect Advantages"></a>Direct Connect Advantages</h2><ul>
<li>降低带宽成本<ul>
<li>所有通过专用连接传输的数据均按AWS直接连接数据传输速率(而不是Internet数据传输速率)的，从而节省成本</li>
<li>在AWS之间传输数据直接减少了Internet服务提供商的带宽承诺</li>
</ul>
</li>
<li>一致的网络性能<ul>
<li>与互联网的网络变化（抖动、延迟）相比，Direct Connect提供专用连接和更一致的网络性能体验</li>
</ul>
</li>
<li>AWS 服务兼容性<ul>
<li>Direct Connect是一种网络服务，可与S3，EC2和VPC等所有AWS服务配合使用</li>
</ul>
</li>
<li>VPC的专用连接<ul>
<li>使用直接连接专用虚拟接口（Private virtual interface）可以在网络和VPC之间建立专用的专用高带宽网络连接</li>
</ul>
</li>
<li>弹性<ul>
<li>使用更高带宽的连接或建立多个连接，可以轻松扩展直接连接以满足需求</li>
</ul>
</li>
</ul>
<h2 id="Direct-Connect-vs-IPSec-VPN-Connections"><a href="#Direct-Connect-vs-IPSec-VPN-Connections" class="headerlink" title="Direct Connect vs IPSec VPN Connections"></a>Direct Connect vs IPSec VPN Connections</h2><ul>
<li>VPC VPN连接通过IPSec在Internet上建立内部网和Amazon VPC之间的加密网络连接</li>
<li>VPN连接可以在几分钟内进行配置，而对于需要一个具有低到适度的带宽需求，并能容忍在基于互联网连接的内在变化</li>
<li>AWS Direct Connect不涉及Internet; 相反，它使用Intranet和Amazon VPC之间的专用专用网络连接</li>
<li>与Direct Connect连接相比，VPN连接非常便宜，因为它需要实际的硬件和基础设施，可能需要数千个</li>
</ul>
<h2 id="Direct-Connect-Anatomy"><a href="#Direct-Connect-Anatomy" class="headerlink" title="Direct Connect Anatomy"></a>Direct Connect Anatomy</h2><p><img src="https://i.loli.net/2019/08/21/qgxn1o5FaWQEUVT.png" alt="screen-shot-2016-05-17-at-1-56-15-pm.png"></p>
<ul>
<li>亚马逊在不同地点维护AWS Direct Connect PoP（称为主机托管设施），这与AWS区域不同</li>
<li>AWS本身维护从AWS Direct Connect PoP到AWS区域的连接</li>
<li>消费者，既可以购买机架空间，也可以使用任何已在主机托管设施中拥有基础架构的AWS APN合作伙伴并配置客户网关</li>
<li>Direct Connect PoP与Colocation Facility内的Customer网关之间的连接称为Cross Connect</li>
<li>可以使用任何服务提供商网络建立从客户网关到客户数据中心的连接</li>
<li>使用AWS创建直接连接连接后，将收到LOA-CFA（授权书 - 连接设施分配）。</li>
<li>LOA-CFA可以切换到主机托管设施或APN合作伙伴以建立交叉连接</li>
<li>一旦建立了Cross Connect以及CGW和Customer DataCenter之间的连接，就可以创建虚拟接口</li>
<li>AWS Direct Connect需要VGW才能访问AWS VPC</li>
<li>虚拟接口<ol>
<li>每个AWS Direct Connect连接都需要一个虚拟接口</li>
<li>每个AWS Direct Connect连接都可以配置一个或多个虚拟接口。</li>
<li>可以创建公共虚拟接口（public virtual interface）以连接到例如公共资源。 SQS，S3，EC2，Glacier等只能公开到达</li>
<li>可以创建专用虚拟接口以连接到例如VPC私有IP地址的实例</li>
<li>每个虚拟接口都需要VLAN ID，接口IP地址，ASN和BGP密钥</li>
</ol>
</li>
<li>要将AWS Direct Connect连接与其他AWS账户一起使用，可以为该账户创建托管虚拟接口。 这些托管虚拟接口与标准虚拟接口的工作方式相同，可以连接到公共资源或VPC。</li>
</ul>
<h2 id="Direct-Connect-Redundancy"><a href="#Direct-Connect-Redundancy" class="headerlink" title="Direct Connect Redundancy"></a>Direct Connect Redundancy</h2><p><img src="https://i.loli.net/2019/08/21/y1cnTMYo63FADd5.png" alt="screen-shot-2016-05-17-at-1-57-22-pm.png"></p>
<ul>
<li>直接连接不提供冗余，并且有多个单点故障，因为每个连接都包含路由器端口和Amazon路由器之间的单个专用连接</li>
<li>冗余连接<ol>
<li>建立第二个DX，最好使用不同的路由器和AWS Direct Connect PoP在不同的主机托管设施中建立连接</li>
<li>客户DC与VGW之间的IPsec VPN连接</li>
</ol>
</li>
<li>对于在同一AWS Direct Connect位置中请求的多个端口，Amazon本身确保在冗余Amazon路由器上配置它们以防止硬件故障的影响</li>
</ul>
<h2 id="Direct-Connect-LAG"><a href="#Direct-Connect-LAG" class="headerlink" title="Direct Connect LAG"></a>Direct Connect LAG</h2><ul>
<li>链接聚合组 (LAG) 是一个逻辑接口，使用链接聚合控制协议 (LACP) 在一个 AWS Direct Connect 终端节点处聚合多个连接，从而允许将这些连接视为一个托管连接</li>
<li>可从现有连接创建 LAG，也可配置新连接</li>
<li>在创建 LAG 之后，可将现有连接 (无论是独立连接还是其他 LAG 的一部分) 与 LAG 关联</li>
<li>LAG遵循以下规则<ol>
<li>LAG 中的所有连接都必须使用相同的带宽</li>
<li>LAG 中最多可有 4 个连接。LAG 中的每个连接都会计入区域的整体连接限制</li>
<li>LAG 中的所有连接都必须终止于同一 AWS Direct Connect 终端节点</li>
</ol>
</li>
</ul>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ul>
<li>AWS Direct Connect user guide</li>
<li><a href="http://jayendrapatil.com/aws-direct-connect-dx" target="_blank" rel="noopener">http://jayendrapatil.com/aws-direct-connect-dx</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/20/AWS-High-Availability-Fault-Tolerance-Architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/AWS-High-Availability-Fault-Tolerance-Architecture/" itemprop="url">AWS High Availability & Fault Tolerance Architecture</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T17:30:32+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>前言：AWS提供众多服务和基础架构能力，以在云中构建可靠，容错且高度可用的系统。一下为AWS的定义范围和解释</li>
</ul>
<ul>
<li>Fault Tolerance定义了构建系统的某些组件发生故障时，系统仍能保持运行的能力</li>
<li>大多数高级服务（如S3，RDS，SQS和ELB）都考虑了容错和高可用性（<font size="3" color="orange">自设计冗余性和高可用</font>）</li>
<li>提供基本基础架构（如EC2和EBS）的服务提供特定功能，例如可用区，弹性IP地址和快照，系统需要正确利用和使用这些功能才能达到容错和高可用性（<strong><font color="red">需要借助AWS基础架构实现高可用性和容错性</font></strong>）</li>
</ul>
<p><img src="https://i.loli.net/2019/08/20/UKcMhzL8VOBtHmD.png" alt="AWS-High-Availability-and-Fault-Tolerance.png"></p>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h3><ul>
<li>高可用性是指提供在本地系统单个组件故障情况下，能继续访问应用的能力，无论这个故障是业务流程、物理设施、IT软/硬件的故障。</li>
<li>主要用于确保关键系统始终正常运行，如核心业务系统、数据库场景。</li>
<li>（RPO=0，共享存储的情况下，RTO分钟级）</li>
<li>一般使用通过运行时间百分比表示其可用性，5 个9：99.999%年可用率，意味着每年停机时间在一到两分钟</li>
</ul>
<h3 id="FT"><a href="#FT" class="headerlink" title="FT"></a>FT</h3><ul>
<li>设计方式时当一个组件发生故障（无论是硬件还是软件）时，备份组件立即接管操作，从而不会丢失服务</li>
<li>容错是高可用性的更严格版本。 HA专注于提供尽可能少的停机时间，而FT则通过实现零停机而进一步提升， 但是，在容错模型中，系统在发生故障时提供高性能的能力不是首要任务，相反，预计系统可以保持运行性能，甚至降低水平</li>
<li>（ 设计目标RTO =0 &amp;&amp; RPO = 0）</li>
</ul>
<h3 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h3><ul>
<li><p>灾难恢复涉及<font color="red">一系列政策，工具和程序</font>，以便在自然灾害或人为灾难之后恢复或延续重要技术基础设施和系统。</p>
</li>
<li><p>DR需要具有异地设施，可以在其中恢复关键数据和工作负载（无论是完全还是部分），以便在发生破坏性事件后恢复足够的业务运营。要将工作负载转移到远程位置，必须采用适当的灾难恢复解决方案</p>
</li>
<li><p>灾难恢复是一个更广泛，更复杂的概念，它指的是一套具有全面组件的战略，包括：风险评估，规划，依赖关系分析，远程站点配置，员工培训，测试，自动化设置等等。灾难恢复超越了<font color="red">HA和FT</font>，但可以而且应该将这些因素包括在其技术设计中。</p>
</li>
<li><p>由于DR场景已经跨单数据中心，基本上RPO可小时级，RTO小时级到天级别</p>
</li>
<li><p>相比HA、FT，DR强调发生灾难后处理，而不是应急或预防，而是减弱灾难带来的影响。DR处理的不是单个组件的故障情况，而是DC级别的故障，应对人力不可控的风险。</p>
</li>
<li><p>在场景上一般都是有着严格行业监管要求的，如金融、医疗等</p>
</li>
<li><p>容灾通常意义上分为<font color="red"><strong>三个级别（数据、应用、业务</strong></font>，国际上专业划分为7个层次）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>级别</th>
<th>定义</th>
<th>RTO</th>
<th>RTO</th>
</tr>
</thead>
<tbody><tr>
<td>数据级</td>
<td>指通过建立异地容灾中心，做数据的远程备份，在灾难发生之后要确保原有的数据不会丢失或者遭到破坏。但在数据级容灾这个级别，发生灾难时应用是会中断的。在数据级容灾方式下，所建立的异地容灾中心可以简单地把它理解成一个远程的数据备份中心。数据级容灾的恢复时间比较长，但是相比其他容灾级别来讲它的费用比较低，而且构建实施也相对简单。但是，“数据源是一切关键性业务系统的生命源泉”，因此数据级容灾必不可少。</td>
<td>RTO 最长(若干天) ，因为灾难发生时，需要重新部署机器，利用备份数据恢复业务。</td>
<td>最低</td>
</tr>
<tr>
<td>应用级</td>
<td>在数据级容灾的基础之上，在备份站点同样构建一套相同的应用系统，通过同步或异步复制技术，这样可以保证关键应用在允许的时间范围内恢复运行，尽可能减少灾难带来的损失，让用户基本感受不到灾难的发生，这样就使系统所提供的服务是完整的、可靠的和安全的。</td>
<td>RTO 中等（若干小时）</td>
<td>中等。异地可以搭建一样的系统，或者小些的系统。</td>
</tr>
<tr>
<td>业务级</td>
<td>全业务的灾备，除了必要的 IT 相关技术，还要求具备全部的基础设施。其大部分内容是非IT系统（如电话、办公地点等），当大灾难发生后，原有的办公场所都会受到破坏，除了数据和应用的恢复，更需要一个备份的工作场所能够正常的开展业务。</td>
<td>RTO 最小（若干分钟或者秒）</td>
<td>最高</td>
</tr>
</tbody></table>
<ul>
<li><strong>RTO （Recovery Time Objective）和 RPO（Recovery Point Objective）</strong></li>
</ul>
<p><img src="https://i.loli.net/2019/08/20/o7k6O5vtfeIEcUP.png" alt="002.png"></p>
<h3 id="HA与DR关系"><a href="#HA与DR关系" class="headerlink" title="HA与DR关系"></a>HA与DR关系</h3><h4 id="两者相互关联，互相补充，互有交叉，同时又有显著的区别："><a href="#两者相互关联，互相补充，互有交叉，同时又有显著的区别：" class="headerlink" title="两者相互关联，互相补充，互有交叉，同时又有显著的区别："></a>两者相互关联，互相补充，互有交叉，同时又有显著的区别：</h4><ul>
<li>HA 往往指本地的高可用系统，表示在多个服务器运行一个或多种应用的情况下，应确保任意服务器出现任何故障时，其运行的应用不能中断，应用程序和系统应能迅速切换到其它服务器上运行，即本地系统集群和热备份。HA 往往是用共享存储，因此往往不会有数据丢失（RPO = 0），更多的是切换时间长度考虑即 RTO。</li>
<li>DR 是指异地（同城或者异地）的高可用系统，表示在灾害发生时，数据、应用以及业务的恢复能力。异地灾备的数据灾备部分是使用数据复制，根据使用的不同数据复制技术（同步、异步、Strectched Cluster 等），数据往往有损失导致 RPO &gt;0；而异地的应用切换往往需要更长的时间，这样 RT0 &gt;0。 因此，需要结合特定的业务需求，来定制所需要的 RTO 和 RPO，以实现最优的 CTO。</li>
</ul>
<h4 id="也可以从别的角度上看待两者的区别："><a href="#也可以从别的角度上看待两者的区别：" class="headerlink" title="也可以从别的角度上看待两者的区别："></a>也可以从别的角度上看待两者的区别：</h4><ul>
<li>从故障角度，HA 主要处理单组件的故障导致负载在集群内的服务器之间的切换，DR 则是应对大规模的故障导致负载在数据中心之间做切换。</li>
<li>从网络角度，LAN 尺度的任务是 HA 的范畴，WAN 尺度的任务是 DR 的范围。</li>
<li>从云的角度看，HA 是一个云环境内保障业务持续性的机制，DR 是多个云环境间保障业务持续性的机制。</li>
<li>从目标角度，HA 主要是保证业务高可用，DR 是保证数据可靠的基础上的业务可用<br>当前的国内IT对于这两个技术术语有着太多差异化的理解。从个人角度来讲<font color="red" size="5"><strong>容灾更强调业务级，而HA更强调数据的高可用，独立应用的可用性。</strong></font></li>
</ul>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://i.loli.net/2019/08/20/eBGgKt6F527nRLf.jpg" alt="HA&amp;DR (2).jpeg"></p>
<h2 id="Regions-amp-Availability-Zones"><a href="#Regions-amp-Availability-Zones" class="headerlink" title="Regions &amp; Availability Zones"></a>Regions &amp; Availability Zones</h2><ul>
<li>AWS提供多Region基础架构，并且在一个内具有多个可用区域（AZs），t提供更简易的可以轻松访问冗余部署位置。</li>
<li>AZ分布在不同的地理位置，其设计与其他AZ物理故障隔离</li>
<li>区域和AZ在地理上分布应用程序并帮助构建多站点解决方案来帮助实现更高的容错能力</li>
<li>AZ之间提供低成本，低延迟的网络连接</li>
<li>将EC2实例放置在多个AZ中，可以保护应用程序免于在单个数据中心发生故障</li>
<li>在同一区域或另一个区域中的多个AZ中运行独立的应用程序堆栈非常重要，这样，如果一个区域出现故障，另一个区域中的应用程序可以继续运行</li>
</ul>
<h2 id="Amazon-Machine-Image-–-AMIs"><a href="#Amazon-Machine-Image-–-AMIs" class="headerlink" title="Amazon Machine Image – AMIs"></a>Amazon Machine Image – AMIs</h2><ul>
<li>EC2是AWS中提供计算资源的服务</li>
<li>Amazon机器映像（AMI）提供了可用于定义服务实例的模板</li>
<li>模板包含软件配置（OS，应用服务和应用程序）并通过实例类型提供服务</li>
<li>AMI可以包含所有软件、应用程序和内置代码，也可以配置为具有启动时安装的引导脚本</li>
<li>单一的AMI可用于创建不同的实例类型的服务器，用于创建新实例或更换故障实例</li>
</ul>
<h2 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h2><ul>
<li>Auto Scaling可根据自定义的规则自动扩展或缩小EC2</li>
<li>AS除了在响应增大时，增加多个实例; 当不再需要这些实例时，它们将自动终止</li>
<li>AS可以根据需要终止服务器实例，他们将自动启动替换实例</li>
<li>AS可以在AWS Region范围内跨AZ部署</li>
</ul>
<h2 id="Elastic-Load-Balancing-–-ELB"><a href="#Elastic-Load-Balancing-–-ELB" class="headerlink" title="Elastic Load Balancing – ELB"></a>Elastic Load Balancing – ELB</h2><ul>
<li>ELB 在单个可用区或多个可用区内的多个目标（Amazon EC2 实例、容器和 IP 地址）之间自动分配流量</li>
<li>随着创建ELB，会产生一个DNS域名，发送到这个域名的任何请求都会被转发到后端处理实例上</li>
<li>ELB支持主机上的运行状况检查，在跨多个可用区域的EC2实例的流量分配，根据健康状态检查动态添加和删除EC2主机</li>
<li>ELB 可以检测无法正常运行的目标、停止向它们发送流量，然后将负载分散到剩余的正常运行的目标上，直至使用AS组无缝地恢复不健康的实例</li>
<li>AS和ELB是一个理想的组合——ELB为请求提供对外DNS访问域名，ELB自动确保始终有正确数量的健康EC2实例来接受请求处理</li>
<li>ELB可用于在一个区域的多个AZs中的多个实例之间进行平衡（<font color="red">跨AZ多实例</font>）</li>
</ul>
<h2 id="Elastic-IPs-–-EIP"><a href="#Elastic-IPs-–-EIP" class="headerlink" title="Elastic IPs – EIP"></a>Elastic IPs – EIP</h2><ul>
<li>弹性IP地址是公共静态IP地址，仅在所属区域内的实现地址于实例之间映射</li>
<li>EIP与AWS账户绑定，而不是与实例关联</li>
<li>弹性IP地址可用于固定终端服务的需求，例如，主数据库，文件服务器和EC2托管负载平衡器</li>
<li>可以通过快速将地址重新映射到另一个正在运行的实例或刚刚启动的替换实例，弹性IP地址可用于解决主机或可用区故障（EIP与实例解耦）</li>
</ul>
<h2 id="Reserved-Instance"><a href="#Reserved-Instance" class="headerlink" title="Reserved Instance"></a>Reserved Instance</h2><ul>
<li>预留实例有助于保留并保证计算始终以较低的成本提供</li>
</ul>
<h2 id="Elastic-Block-Store-–-EBS"><a href="#Elastic-Block-Store-–-EBS" class="headerlink" title="Elastic Block Store – EBS"></a>Elastic Block Store – EBS</h2><ul>
<li>弹性块存储（EBS）提供持久的实例存储卷，这些存储卷独立于实例的生命周期而存在，并且比实例存储大多个数量级</li>
<li>EBS卷以冗余方式存储数据，并在单个可用区内自动复制</li>
<li>在故障转移场景，如果EC2实例发生故障并需要更换，则EBS卷可以附加到新的EC2实例</li>
<li>有价值的数据不应该对实例（临时）存储上当没有没有适当的备份，复制或重新创建数据的能力的时候</li>
</ul>
<h2 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h2><ul>
<li>EBS卷是高度可靠的，为了进一步减轻故障的可能性并提高数据可靠性性，基于时间点的快照可以存储在S3中，然后将其复制到多个AZ</li>
<li>快照可用于创建新的EBS卷，这些卷是快照时原始卷的精确副本</li>
<li>快照提供了一种有效的方法来处理磁盘故障、主机、AZ的故障问题</li>
<li>快照是增量备份，仅备份自上一个快照以来的更改，因此建议保留最近的快照</li>
<li><font color="red">快照属于region范围内，而EBS卷属于AZ范围内</font></li>
</ul>
<h2 id="Relational-Database-Service-–-RDS"><a href="#Relational-Database-Service-–-RDS" class="headerlink" title="Relational Database Service – RDS"></a>Relational Database Service – RDS</h2><ul>
<li>RDS是在云上交付的一种数据库服务，并使数据库服务使用变得更加简单</li>
<li>RDS Multi-AZ部署，在不同的AZ提供数据库的同步备用副本，提高数据库的可用性，并保护数据库不受意外停机的影响</li>
<li>在出现故障转移的情况下，备用服务器被无缝地提升为主服务器，并将处理数据库操作</li>
<li>默认情况下，数据库启用的自动备份为数据库实例提供时间点恢复</li>
<li>RDS将备份数据库和事务日志，并将其存储在用户指定的保留期内</li>
<li>除自动备份外，还可以执行手动RDS备份，这些备份在明确删除之前一直保留</li>
<li>备份有助于从更高级别的故障中恢复，例如无意中的数据修改，无论是操作员错误还是应用程序中的错误</li>
<li>RDS只读副本提供数据库的只读副本，并提供扩展超出单个数据库部署容量的能力，用于读取大量数据库工作负载（<font color="red">注意数据库引擎，不是所有RDS支持</font>）</li>
<li>RDS只读副本是一种可扩展性而非高可用性解决方案</li>
</ul>
<h2 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h2><ul>
<li>S3提供高度持久，容错和冗余的对象存储</li>
<li>跨S3区域中的多个设施在多个设备上冗余地存储对象</li>
<li>S3是作为一个非常理想的存储解决方案，适用于静态或缓慢变化的对象，例如图像，视频和其他静态媒体</li>
<li>S3结合Amazon CloudFront服务交互来支持静态内容缓存加速和流式数据加速传输</li>
</ul>
<h2 id="Simple-Queue-Service-–-SQS"><a href="#Simple-Queue-Service-–-SQS" class="headerlink" title="Simple Queue Service – SQS"></a>Simple Queue Service – SQS</h2><ul>
<li>简单队列服务（SQS）是一种高度可靠的分布式消息传递系统，作为容错应用程序的主干环节</li>
<li>SQS旨在提供所有消息的“至少一次”传送</li>
<li>消息被保证发送到队列被保留长达四天（默认，并且可以扩展高达14天）或直到它们被应用程序读出并删除</li>
<li>消息可由多个worker轮询并进行处理，而SQS使用称为可见性超时的可配置时间间隔，一次只由一个worker处理请求</li>
<li>如果队列中的消息数量开始增加，或者处理消息的平均时间变得过高，则可以通过添加额外的EC2实例来向上扩展worker</li>
</ul>
<h2 id="Route-53"><a href="#Route-53" class="headerlink" title="Route 53"></a>Route 53</h2><ul>
<li>Route 53是一种高度可用且可扩展的域名解析 服务</li>
<li>域名的查询自动路由到最近的DNS服务器，从而提供最佳的性能作了解答</li>
<li>Route 53支持将域名请求（例如，<a href="http://www.example.com）解析为Elastic" target="_blank" rel="noopener">www.example.com）解析为Elastic</a> Load Balancer地址以及域名root记录（example.com）</li>
</ul>
<h2 id="Cloud-Front"><a href="#Cloud-Front" class="headerlink" title="Cloud Front"></a>Cloud Front</h2><ul>
<li>CloudFront可用于使用全球边缘位置网络提供网站加速访问，包括动态，静态和流媒体内容</li>
<li>对内容的请求会自动路由到最近的边缘位置，以最佳性能体验</li>
<li>CloudFront可以与其他AWS（如S3和EC2）配合使用以获得的最好的体验</li>
<li>CloudFront还可以与任何非AWS原始服务器无缝协作，该服务器存储文件的源目标</li>
</ul>
<h2 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h2><ol>
<li><a href="https://www.cnblogs.com/sammyliu/p/4741967.html" target="_blank" rel="noopener">https://www.cnblogs.com/sammyliu/p/4741967.html</a></li>
<li><a href="http://jayendrapatil.com/aws-high-availability-fault-tolerance-architecture-certification/" target="_blank" rel="noopener">http://jayendrapatil.com/aws-high-availability-fault-tolerance-architecture-certification/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/19/AWS-Disaster-Recovery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/AWS-Disaster-Recovery/" itemprop="url">AWS Disaster Recovery</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T21:08:22+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>前言：HA目标保障应用的连续运行（7\</em>24），备份确保数据的安全性，DR确保在距离上主站点故障而其应用、数据都还能够使用.</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><ul>
<li>AWS灾难恢复白皮书重点介绍了可用于灾难恢复流程的AWS服务和功能，以显著降低企业或组织的影响，包括数据、系统和业务运营方面。</li>
<li>概述实现灾难恢复的最佳实践，从最小投资到全面可用性以及容错机制，描述了如何使用AWS服务来降低成本并确保灾难事件后业务连续性的实践</li>
<li>灾备（Disaster Recovery）包括灾备方案和环境准备，以及从灾难中恢复两部分。任何对企业的业务持续性或财务有负面影响的事件都可成为灾难。AWS最佳实践之一就是始终故障设计系统的构建。</li>
<li>灾难包括硬件或软件故障、断网、断电、火灾、水灾、人为错误等等。为了减少灾难带来的损失，企业往往会投入时间和金钱来计划和准备、训练员工、定义和更新流程。为DR 计划而做的投资往往有很大不同。灾难恢复往往有两个指标：</li>
</ul>
<p>RTO - Recovery time objective：从灾难发生到恢复到满足计划SLA服务的时间<br>RPO - Reovery point objective：允许丢失的数据的时间长度<br><img src="https://i.loli.net/2019/08/19/EXpeLb4d6JwfrgO.jpg" alt="001.jpg"></p>
<ul>
<li>常见故障位置</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>硬件故障</td>
<td>系统中任何硬件组件的故障，包括主机，存储，网络或其他等。</td>
</tr>
<tr>
<td>部署失败</td>
<td>由于软件，硬件，网络或配置部署而直接导致的故障。 包括自动和手动更改。</td>
</tr>
<tr>
<td>负载因素</td>
<td>负载相关的故障可以是一个行为触发、特定进程或负载聚合加重，或者服务达到临界点。 而网络尤其可能发生负载故障。</td>
</tr>
<tr>
<td>数据因素</td>
<td>系统接受了无法处理的操作（毒丸）</td>
</tr>
<tr>
<td>凭证过期</td>
<td>证书或凭证到期导致的系统无法继续运行</td>
</tr>
<tr>
<td>依赖关系</td>
<td>相关依赖的服务故障</td>
</tr>
<tr>
<td>基础设施</td>
<td>电力或环境因素导致的硬件故障风险</td>
</tr>
<tr>
<td>资源耗尽</td>
<td>超出可用容量，达到限制条件，ID耗尽，提供的资源不再可用</td>
</tr>
</tbody></table>
<ul>
<li>常见应用应用程序设计目标和可用性</li>
</ul>
<table>
<thead>
<tr>
<th>可用性</th>
<th>最大停机时间（年）</th>
<th>应用类别</th>
</tr>
</thead>
<tbody><tr>
<td>99%</td>
<td>3天15小时</td>
<td>Batch processing, data extraction, transfer, and load jobs</td>
</tr>
<tr>
<td>99.90%</td>
<td>8小时45分钟</td>
<td>Internal tools like knowledge management, project tracking</td>
</tr>
<tr>
<td>99.95%</td>
<td>4小时22分钟</td>
<td>Online commerce, point of sale</td>
</tr>
<tr>
<td><font color="orange">99.99% </font></td>
<td><font color="orange"> 52分钟 </font></td>
<td><font color="orange">Video delivery, broadcast systems    </font></td>
</tr>
<tr>
<td><font color="orange">99.999% </font></td>
<td><font color="orange">5分钟  </font></td>
<td><font color="orange"> ATM transactions, telecommunications systems </font></td>
</tr>
</tbody></table>
<p><font face="黑体" size="5" color="red">针对最后两个AWS建议多Region部署</font></p>
<h2 id="Region级别服务"><a href="#Region级别服务" class="headerlink" title="Region级别服务"></a>Region级别服务</h2><ul>
<li><p>默认S3 DynamoDB EFS SQS Kinesis 提供区域内可靠性保障（无单点）</p>
</li>
<li><p>RDS ElasticCache ElasticSearch 需要配置多可用区部署实现可靠性保障<br><img src="https://i.loli.net/2019/08/19/IOTGYH4Q9EFVcLB.jpg" alt="002.jpg"></p>
</li>
<li><p><strong>AWS服务设计可用性目标</strong>（具体可相见文末《Reliability Pillar》，白皮书包含了非常详细的每一个服务的设计可用性）</p>
</li>
<li><p>基本上来讲，每一个服务都包含控制平面和数据平面，每一个纬度可用性不一样</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>服务</strong></th>
<th align="center"><strong>组件</strong></th>
<th align="center"><strong>可用性</strong></th>
<th align="center"><strong>多可用区可用性</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">EC2</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">单AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">EC2</td>
<td align="center">多AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9990%</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EBS</td>
<td align="center">数据平面（卷可用性）</td>
<td align="center">99.999%</td>
<td align="center">100.0000%</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">单AZ数据平面</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">RDS</td>
<td align="center">多AZ数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">Route 53</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">Route 53</td>
<td align="center">数据平面(查询结果)</td>
<td align="center">100.000%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">S3</td>
<td align="center">服务（标准）</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">Auto Scaling</td>
<td align="center">控制平面</td>
<td align="center">99.900%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">Auto Scaling</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">EFS</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">EFS</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">控制平面</td>
<td align="center">99.900%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">IAM</td>
<td align="center">数据平面</td>
<td align="center">99.995%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">Lambda</td>
<td align="center">函数调用</td>
<td align="center">99.950%</td>
<td align="center">99.9975%</td>
</tr>
<tr>
<td align="center">ELB</td>
<td align="center">控制平面</td>
<td align="center">99.950%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">ELB</td>
<td align="center">数据平面</td>
<td align="center">99.990%</td>
<td align="center">99.9999%</td>
</tr>
<tr>
<td align="center">KMS</td>
<td align="center">控制平面</td>
<td align="center">99.990%</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">KMS</td>
<td align="center">数据平面（卷可用性）</td>
<td align="center">99.995%</td>
<td align="center">N/A</td>
</tr>
</tbody></table>
<h1 id="实现DR的AWS关键服务"><a href="#实现DR的AWS关键服务" class="headerlink" title="实现DR的AWS关键服务"></a>实现DR的AWS关键服务</h1><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><ul>
<li>AWS服务在全球多个地区都可以使用，并DR站点位置可以适当地选择与主站点位置不同的区域</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><ul>
<li>11个9的持久性设计的存储架构，专为关键任务和主要数据存储设计</li>
<li>对象数据冗余的存储区域内多个设施多个设备上</li>
</ul>
<h4 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h4><ul>
<li>为数据存档和备份提供极具性价比的存储系统</li>
<li>针对不频繁访问模型进行优化，通常减速时间在3～5小时即可完成</li>
</ul>
<h4 id="EBS"><a href="#EBS" class="headerlink" title="EBS"></a>EBS</h4><ul>
<li>提供基于时间点的快照功能</li>
<li>快照卷可以用于创建新卷并附加到运行的实例上</li>
</ul>
<h4 id="Storage-Gateway"><a href="#Storage-Gateway" class="headerlink" title="Storage Gateway"></a>Storage Gateway</h4><ul>
<li>提供本地环境与AWS存储系统之间无缝和高度安全的集成服务</li>
</ul>
<h4 id="Snow-Family"><a href="#Snow-Family" class="headerlink" title="Snow Family"></a>Snow Family</h4><ul>
<li>使用便携式存储设备绕过Internet进行传输，加速大量数据移入和移出AWS</li>
<li>通过设高速内部网络将数据直接在设备与存储服务之间传输<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3></li>
</ul>
<h4 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h4><ul>
<li>在云中提供可调整大小的实例，轻松实现创建和扩展</li>
<li>实例使用预配置的AMI模板</li>
<li>EC2可以在多个AZ中启动，实现AZ级别的故障隔离<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3></li>
</ul>
<h4 id="Route53"><a href="#Route53" class="headerlink" title="Route53"></a>Route53</h4><ul>
<li>高度可用且可扩展的域名解析服务</li>
<li>支持全局负载均衡功能，这在处理灾难场景时非常有效。在多站点进行故障转移的时候，站点健康检查非常有用</li>
</ul>
<h4 id="Elastic-IP"><a href="#Elastic-IP" class="headerlink" title="Elastic IP"></a>Elastic IP</h4><ul>
<li>在实例或AZ故障的情况下，IP地址可以被重新映射到健康实例上</li>
<li>EIP专为云计算动态资源设计</li>
</ul>
<h4 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h4><ul>
<li>运行运行状况检查并自动在多个目标（如EC2实例）之间分配的应用程序流量</li>
</ul>
<h4 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h4><ul>
<li>允许配置AWS云的私有隔离部分，以便在定义的虚拟网络中启动资源</li>
</ul>
<h4 id="Direct-Connect"><a href="#Direct-Connect" class="headerlink" title="Direct Connect"></a>Direct Connect</h4><ul>
<li>设置从本地环境到AWS的专用网络连接</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>RDS，DynamoDb，Redshift提供完全托管的RDBMS，NoSQL和数据仓库解决方案，可轻松扩展</li>
<li>DynamoDB提供跨区域复制</li>
<li>RDS提供多可用区部署和只读副本，还能够将数据从一个区域快照到另一个区域</li>
</ul>
<h3 id="部署编排"><a href="#部署编排" class="headerlink" title="部署编排"></a>部署编排</h3><h4 id="CloudFormation"><a href="#CloudFormation" class="headerlink" title="CloudFormation"></a>CloudFormation</h4><ul>
<li>为开发人员和系统管理员提供了一种简单的方法来创建相关AWS资源的集合，并以有序和可预测的方式进行配置（DIY）</li>
</ul>
<h4 id="Elastice-Beanstalk"><a href="#Elastice-Beanstalk" class="headerlink" title="Elastice Beanstalk"></a>Elastice Beanstalk</h4><ul>
<li>是一种易于使用的服务，用于部署和扩展Web应用程序和服务</li>
</ul>
<h4 id="OpsWorks"><a href="#OpsWorks" class="headerlink" title="OpsWorks"></a>OpsWorks</h4><ul>
<li>完全托管的配置管理服务，基础设施和应用程序管理的自动化工具</li>
<li>应用程序塑造成一个包含不同层级 (例如负载均衡层、数据库层和应用程序服务器层) 的堆栈</li>
<li>具实例发生故障时，它将自动替换实例</li>
<li>可用于准备阶段以模拟环境，并在恢复阶段与AWS CloudFormation配合使用</li>
<li>可以依托预配置的堆栈快速的恢复预设环境（达到预设RTO）</li>
</ul>
<h1 id="四种场景"><a href="#四种场景" class="headerlink" title="四种场景"></a>四种场景</h1><p>从“备份和还原”选项（左侧）移至“多站点”选项（右侧）时，RTO和RPO会随着成本的增加而降低<br><img src="https://i.loli.net/2019/08/19/Kqtkb1VrwO5ISAh.png" alt="003.png"></p>
<h2 id="Backup-amp-Restore"><a href="#Backup-amp-Restore" class="headerlink" title="Backup &amp; Restore"></a>Backup &amp; Restore</h2><ul>
<li>备份恢复是最常见的一种容灾手段，将主站点数据备份到与主站点隔离的存储设备。当生产环境故障后，能够在备站点将数据恢复。<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a><strong>备份</strong></h3><img src="https://i.loli.net/2019/08/19/lzv5RpfmHdFo16h.jpg" alt="005.jpg"></li>
</ul>
<p><img src="https://i.loli.net/2019/08/19/S2Wusy9fhACOVko.jpg" alt="006.jpg"></p>
<ul>
<li>在大多数传统环境中，数据备份到磁带并定期发送到异地，需要花费更长时间在中断或灾难时恢复系统</li>
</ul>
<ol>
<li>S3可以在任何位置上进行数据备份和快速恢复</li>
<li>Snow Family系列设备可以直接绕过Internet进行大规模数据的传输</li>
<li>Glacier可用于存档场景，几个小时即可取回数据</li>
<li>Storage Gateway支持将本地数据卷（EBS卷）透明的复制到云上S3中进行备份。既可以作为备份解决方案的网关，也可作为主数据存储（缓存卷）</li>
<li>Direct Connect用于构建高速稳定一致的链路层（本地环境到云上）</li>
<li>EBS卷、RDS、Redshift的快照都可以存储到S3中</li>
</ol>
<h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a><strong>恢复</strong></h3><p><img src="https://i.loli.net/2019/08/19/HYOyPK4SIceX2kb.jpg" alt="007.jpg"></p>
<ul>
<li>备份数据可以快速恢复和创建EC2、数据库实例的运行环境</li>
<li>几个关键步骤<ol>
<li>选择适当的工具或方法将数据备份到AWS</li>
<li>确保对此数据采用适当的保留策略</li>
<li>确保为此数据采取适当的安全措施，包括加密和访问策略</li>
<li>定期测试此数据的恢复和系统的恢复</li>
</ol>
</li>
</ul>
<h2 id="Pilot-Light"><a href="#Pilot-Light" class="headerlink" title="Pilot Light"></a>Pilot Light</h2><p>   Pilot Light 则在AWS上创建最小运行环境，它包含业务系统中最核心部分，比如数据库。这会节省恢复时间，因为系统中最核心部分已经在运行，而且数据是最新的了。而不经常更新部分，比如操作系统和应用，则可以定期打包到AMI中</p>
<ul>
<li>通过在AWS中维持配置和运行最小或关键系统，如数据库应用（保持数据库的复制和更新）</li>
<li>在恢复过程中，一个完整的生产环境，包括应用程序、Web服务等，可以围绕这个核心系统快速配置（预配置AMI模板和EBS快照）；</li>
<li>网络层面，可以使用ELB实现流量分配，并将DNS指向ELB，也可以使用预先分配的EIP与相关实例绑定</li>
</ul>
<h3 id="Pilotlight-prep"><a href="#Pilotlight-prep" class="headerlink" title="Pilotlight-prep"></a>Pilotlight-prep</h3><p><img src="https://i.loli.net/2019/08/19/xdZmK2tVSb9plRD.jpg" alt="008.jpg"></p>
<ol>
<li>建立EC2实例或RDS实例复制或镜像关系，保持关键数据两边一致</li>
<li>确保所有的软件在AWS环境中都可用</li>
<li>建立和维护在故障恢复时的关键服务的AMI（将操作系统和应用，则可以定期打包到AMI）</li>
<li>定期运行这些服务并测试，及时更新配置、软件更新</li>
<li>建议优先考虑自动化配置AWS服务</li>
</ol>
<h3 id="Pilot-light-recovery"><a href="#Pilot-light-recovery" class="headerlink" title="Pilot light-recovery"></a>Pilot light-recovery</h3><p><img src="https://i.loli.net/2019/08/19/C18ZsEtOWjmNDSq.jpg" alt="009.jpg"></p>
<ol>
<li>启动AMI创建EC2实例</li>
<li>视情况调整数据库实例大小/存储实例大小，以应对可能增大的流量，如RDS支持scale up，而EC2也可轻松实现水平扩展</li>
<li>建议在DR站点开启RDS 多可用区部署，以增强站点数据层的健壮性</li>
<li>更改DNS域名解析到新的EC2服务器</li>
<li>安装和配置任何非基于AMI的系统，最好使用自动化方式（避免手工错误）</li>
</ol>
<h2 id="Warm-Standby"><a href="#Warm-Standby" class="headerlink" title="Warm Standby"></a>Warm Standby</h2><ul>
<li>在温备场景下，一个小规模的完整业务环境会运行在AWS中</li>
<li>还能用于非生产环境，比如测试和内部使用</li>
<li>在灾难的情况下，系统可以轻松地按比例放大或缩小处理生产负载</li>
</ul>
<h3 id="Warm-standby—prep"><a href="#Warm-standby—prep" class="headerlink" title="Warm standby—prep"></a>Warm standby—prep</h3><p><img src="https://i.loli.net/2019/08/19/VfY2FtMjGD65a89.jpg" alt="010.jpg"></p>
<ol>
<li>建立实例级别的复制或镜像关系</li>
<li>创建和维护AMI以加快部署速度</li>
<li>使用最小配置环境运行服务</li>
<li>根据需要及时更新软件、补丁和配置文件，保持与主站点一致</li>
</ol>
<h3 id="Warm-standby—recover"><a href="#Warm-standby—recover" class="headerlink" title="Warm standby—recover"></a>Warm standby—recover</h3><p><img src="https://i.loli.net/2019/08/19/UYPvqVmub3FwCnj.jpg" alt="011.jpg"></p>
<ol>
<li>增加EC2数量（横向扩展）（扩成与主站点一致）</li>
<li>根据需要增大EC2配置（纵向扩展）使其启动应用程序</li>
<li>手动更改DNS记录，或使用Route 53自动运行状况检查将所有流量路由到AWS环境</li>
<li>增大或扩展数据库以防止DR发生故障</li>
<li>考虑使用AutoScaling组以调整适应负载的变化</li>
</ol>
<h2 id="Multi-Site"><a href="#Multi-Site" class="headerlink" title="Multi Site"></a>Multi Site</h2><ul>
<li>Multi Site 指的是 active-active 的架构，在两个站点上提供同样的基础架构</li>
<li>主备站点同时对外提供服务，由DNS根据加权路由决定将请求转发到相应站点</li>
<li>在故障的情况下，通过DNS解析可以将流量转发到健康站点，并同时扩展其架构以使用负载增大</li>
</ul>
<h3 id="Multi-site—prep"><a href="#Multi-site—prep" class="headerlink" title="Multi site—prep"></a>Multi site—prep</h3><p><img src="https://i.loli.net/2019/08/19/EAqiml5hf7Iwp19.jpg" alt="012.jpg"></p>
<ol>
<li>在AWS上复制生产环境到站点</li>
<li>DNS 可以根据加权规则进行不同比率流量分配</li>
<li>配置自动故障转移以将流量从受影响的站点重新路由。 例如用于检查主数据库是否可用的应用程序，若master故障则重定向到另外一边</li>
</ol>
<h3 id="Multi-site—recovery"><a href="#Multi-site—recovery" class="headerlink" title="Multi site—recovery"></a>Multi site—recovery</h3><p><img src="https://i.loli.net/2019/08/19/lyESjqAcoma8UPg.jpg" alt="013.jpg"></p>
<ol>
<li>手动或使用DNS故障转移集群，修改DNS权重，以便将所有请求转发到将康站点</li>
<li>具备故障转移应用程r 需要能够逻辑处理在切换后使用本地的数据库（健康）</li>
<li>建议使用AutoScaling组以自动调整其负载规模的变化</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Fail-back"><a href="#Fail-back" class="headerlink" title="Fail back"></a>Fail back</h2><p>当主站点恢复以后，你往往需要将运行环境从灾备环境切换到原来的主环境，此成为 fail-back。对于不同的灾备场景，有不同的做法。</p>
<p><strong>备份和恢复</strong></p>
<ol>
<li>冻结向 DR site 的数据更新</li>
<li>做备份</li>
<li>将备份 restore 到主 site</li>
<li>将用户引流到主site</li>
<li>解冻数据更新</li>
</ol>
<p><strong>Pilot light, warm standby, and multi-site：</strong></p>
<ol>
<li>从 DR site 往主site 做数据同步，直到主site数据一致</li>
<li>冻结向 DR site 的数据更新</li>
<li>将用户引流到主site</li>
<li>解冻数据更新</li>
</ol>
<h2 id="多站点部署需要考虑的因素"><a href="#多站点部署需要考虑的因素" class="headerlink" title="多站点部署需要考虑的因素"></a>多站点部署需要考虑的因素</h2><ul>
<li>站点间的距离 - 距离越远，往往延迟越高</li>
<li>可用的带宽</li>
<li>应用所需的数据同步速率 - 这速度需要低于可用带宽</li>
<li>同步技术 - 同步需要是并行的，以提高效率</li>
<li>同步方式 - 同步的和异步的。AWS RDS 在可用区之间是同步的</li>
<li>同步目标 - 是往一个目标站点同步，还是往多个目标站点同步</li>
</ul>
<h2 id="灾备计划"><a href="#灾备计划" class="headerlink" title="灾备计划"></a>灾备计划</h2><ul>
<li>测试：一旦DR site 准备就绪，需要有完整的测试来验证</li>
<li>持续的监控和告警：对 DR site 做持续监控，并及时处理问题</li>
<li>备份：即使切换到DR site，还是要做常规备份</li>
<li>用户访问：要保证用户访问 DR site 的安全性</li>
</ul>
<p>Refer</p>
<ol>
<li><a href="https://media.amazonwebservices.com/AWS_Disaster_Recovery.pdf" target="_blank" rel="noopener">https://media.amazonwebservices.com/AWS_Disaster_Recovery.pdf</a> 《Using Amazon Web Services for Disaster Recovery》</li>
<li><a href="https://www.cnblogs.com/sammyliu/p/8902556.html" target="_blank" rel="noopener">https://www.cnblogs.com/sammyliu/p/8902556.html</a></li>
<li>《Building Fault-Tolerant Application on AWS》</li>
<li><a href="https://d1.awsstatic.com/whitepapers/architecture/AWS-Reliability-Pillar.pdf" target="_blank" rel="noopener">https://d1.awsstatic.com/whitepapers/architecture/AWS-Reliability-Pillar.pdf</a> 《Reliability Pillar》</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/19/AWS-S3-Deep-Dive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/AWS-S3-Deep-Dive/" itemprop="url">AWS S3 Deep Dive</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T17:24:15+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>前言：本文主要介绍S3的详细功能，涉及S3 存储分类，一致性模型，生命周期管理，版本控制，权限管理，数据加密和最佳实践建议等。</em> </p>
<h1 id="S3-Overview"><a href="#S3-Overview" class="headerlink" title="S3 Overview"></a>S3 Overview</h1><h2 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h2><ul>
<li>Amazon S3是一个面向Internet设计的简单的键值对象存储系统</li>
<li>S3提供无限的存储空间，并仅在使用时才产生付费（按需）。费用随着使用量增加将变得更便宜。</li>
<li>S3是对象级别存储(不是块级存储)，不能用于托管OS或动态网站</li>
<li>S3资源在默认情况下是私有的，包含bucket和对象数据</li>
</ul>
<h2 id="S3-Bucket-amp-Objects"><a href="#S3-Bucket-amp-Objects" class="headerlink" title="S3 Bucket&amp;Objects"></a>S3 Bucket&amp;Objects</h2><ul>
<li>Buckets<ul>
<li>Bucket(存储桶)是存储对象的容器空间，组织和管理S3的命名空间</li>
<li>bucket由AWS帐户拥有，该帐户创建bucket并帮助标识负责存储和数据传输费用，bucket所有权不可转让</li>
<li>S3桶名是全局惟一的，但bueket创建是需要指定其所在区域（Region），<table><tr><td bgcolor="orange"> 也就是指其名字是Global，而数据仅限于Region范围内</td></tr></table></li>
<li>每一个object依附于bucket中</li>
<li>可以存储在存储桶中的对象数量没有限制，性能也没有差异(无论使用多buckets或单一bucket)</li>
<li>S3数据模型是扁平结构，即桶内没有层次结构或文件夹。可以通过使用键名称前缀（例如Folder1 / Object1）来推断逻辑层次结构</li>
<li>限制<ul>
<li>每个AWS账户中创建100个存储桶（软限制）</li>
</ul>
</li>
<li>存储桶名称应该是全局唯一且符合DNS的要求<table><tr><td bgcolor="orange">（小写，每一个对象都能通过其唯一url访问，url包含域名）</td></tr></table><ul>
<li>bucket所有权不可转让</li>
<li>bucket不能嵌套bucket</li>
</ul>
</li>
<li>可以删除空桶或非空桶</li>
<li>S3允许检索1000个对象并提供分页支持</li>
</ul>
</li>
<li>Objects<ul>
<li>对象是存储在S3 bucket中的基本实体</li>
<li>对象的唯一标识通过<table><tr><td bgcolor="orange">键名和版本ID</td></tr></table></li>
<li>对象由对象数据、元数据等其他信息组成</li>
<li>Key（键）是对象名称</li>
<li>Value(值)是数据部分且对S3不透明</li>
<li>元数据是关于数据的数据，并且是一组name-value，其描述例如内容类型，大小，最后修改时间。还可以在存储对象时自定义元数据</li>
<li>版本ID是对象的版本，与key结合使用在桶中唯一标识对象</li>
<li>Subresource（子资源） 有助于为对象提供附加信息</li>
<li>Access Control控制对象的访问权限</li>
<li>S3对象允许对象两种元数据<ul>
<li>System metadata<ul>
<li>诸如Last-Modified 时间之类的元数据，只能有S3有权限进行修改</li>
<li>用户可以控制的系统元数据，例如为对象配置的存储类（class）。</li>
</ul>
</li>
<li>User-defined metadata<ul>
<li>User可以自定义其对象元数据上传之前或之后</li>
<li>字定义的元数据与对象一起存储，并在下载对象时返回</li>
<li>S3不处理自定义元数据</li>
<li>自定义元数据必须以“x-amz-meta”开头，否则S3将不会处理其自定义设置</li>
</ul>
</li>
</ul>
</li>
<li>对象元数据上传之后不能修改，只能通过执行复制操作来设置元数据修改</li>
<li>属于bucket的对象保存在设定的Region范围内，不能离开此区域，除非使用块区域复制进行显式复制</li>
<li>对象作为整体或部分进行检索</li>
<li>启用版本控制之后，可以检索当前和之前的版本</li>
</ul>
</li>
</ul>
<h2 id="Bucket-amp-Object-操作"><a href="#Bucket-amp-Object-操作" class="headerlink" title="Bucket &amp; Object 操作"></a>Bucket &amp; Object 操作</h2><ul>
<li>Listing<ul>
<li>S 3 允许列出存储桶中所有key</li>
<li>一个list请求最多返回1000个对象，并且支持分页展示，在响应中使用指示器显示是否响应</li>
<li>可以使用前缀和分隔符列出key</li>
<li>Prefix将结果限制为仅以指定前缀开头的键(过滤)，分隔符list将包含公共前缀的所有key列出，形成一个摘要列表</li>
</ul>
</li>
<li>Retrival<ul>
<li>对象可以作为整体取回</li>
<li>可以使用Range HTTP标头一部分或部分特定字节检索对象</li>
<li>Range HTTP 标头非常有用<ul>
<li>如只需要部分对象，在多文件作为一个归档文件上传的时候</li>
<li>在网络环境较差的情况下，进行下载数据</li>
</ul>
</li>
<li>对象支持预签名 url访问</li>
<li>对象的元数据包含在响应标头中</li>
</ul>
</li>
<li>Object Uploads<ul>
<li>单次操作——单次put 操作最大对象5GB</li>
<li>分段上传——可用于上传大于5B大小的对象，最大5TB</li>
<li>支持预签名 URL上传对象</li>
<li>上传对象是否成功，可通过reponse值显示。此外，可以将返回的ETAG值与对象的MD5值进行比对</li>
</ul>
</li>
<li>Copying Objects<ul>
<li>单次操作最大5GB的对象，使用分段上传进行大于5GB的对象（最大5TB）</li>
<li>复制对象时<ul>
<li>用户自定义的元数据，如存储类和自定义的元数据都会被复制</li>
<li>系统元数据保留（如创建日期）</li>
</ul>
</li>
<li>其他复制情形<ul>
<li>复制多个对象副本</li>
<li>跨地点复制对象</li>
<li>重命名对象</li>
<li>更改对象元数据，例如存储分类，服务器端加密等</li>
<li>更新对象的任何元数据都需要再次指定的字段</li>
</ul>
</li>
</ul>
</li>
<li>Deleting Objects<ul>
<li>S3允许单次删除一个或最多100个对象</li>
<li>未开启版本控制bucket<ul>
<li>明确提供键名（key）则永久删除对象</li>
</ul>
</li>
<li>开启版本控制bucket<ul>
<li>删除对象键(key)，S3将插入一个删除标记，当前对象将变为非当前对象</li>
<li>删除对象键（key）和version ID,S3将永久删除对象</li>
<li>若version id作为删除标记，那么删除标记将被删除，previous版本将成为当前版本对象</li>
<li>启用MFA安全删除需要删除的对象</li>
</ul>
</li>
</ul>
</li>
<li>Restoring Objects from Glacier <ul>
<li>在访问存档对象之前，必须还原对象</li>
<li>对象的恢复可能需要大约3到5个小时进行标准检索。Glacier现在可以在几分钟内提供快速检索</li>
<li>恢复请求对象需要指定需要维护对象副本（Glacier数据临时放到S3上）的时间（天）</li>
<li>在此期间，存档和副本的存储费用都要收取</li>
</ul>
</li>
</ul>
<h2 id="Pre-Signed-URLs"><a href="#Pre-Signed-URLs" class="headerlink" title="Pre-Signed  URLs"></a>Pre-Signed  URLs</h2><ul>
<li>默认情况下，所有存储桶和对象都是私有的</li>
<li>预签名URL允许用户无需AWS安全凭据或权限即可下载或上载特定对象</li>
<li>预签名URL允许任何人访问URL中标识的对象，只要创建者游泳访问权限</li>
<li>预签名url需要创建者提供其安全凭证、指定bucket名称、对象密钥、HTTP方法(GET PUT)以及过期日期和时间</li>
<li>预签名url有时间期限</li>
</ul>
<h2 id="Multipart-upload"><a href="#Multipart-upload" class="headerlink" title="Multipart upload"></a>Multipart upload</h2><ul>
<li>分段上传允许分批次上传，每一次操作都是数据的一部分（子集）</li>
<li>Multipart uploads支持将数据拆分成1~10000部分，每部分数据从5MB到5GB，最后一次上传的数据允许小于5MB</li>
<li>每一部分数据可以独立上传，并且可以任意顺序上传。如果任何部分的传输失败，不影响其他部分的情况下重新上传</li>
<li>上传对象的所有部分并完成初始化之后，S3组装这些数据并创建对</li>
<li>使用分段上传的优势<ul>
<li>提高吞吐量——并行</li>
<li>避免网络故障的影响范围——最大减小网络故障带来上传数据失败（但也只影响部分数据，而不是全部）</li>
<li>暂停和恢复上传-对象部分可以随时间上传。一旦多部分上传启动，需要指定其完成或者中断时间，要不然会持续占有进程。就</li>
<li>对象可以在创建时上传，即便未知其大小</li>
</ul>
</li>
<li>操作步骤<ul>
<li>分段上传初始化<ul>
<li>分段上传请求初始化时会为每个分段上传分配唯一ID</li>
<li>每个部分上传，在完成或中止请求以及分段调用使用供此ID</li>
<li>在初始化时需要用提供object的元数据</li>
</ul>
</li>
<li>分段上传<ul>
<li>分段上传的数据使用唯一的上传ID标识</li>
<li>每一部分都有一个part number（1~1000）标识自己的分段在对象数据中位置</li>
<li>如果上传部分有相同的part number 则会覆盖前面的数据</li>
<li>上传成功之后，S3会返回Etag标头，标头需要与part number一起记录下来</li>
</ul>
</li>
<li>上传完成或暂停<ul>
<li>一旦上传请求完成，S3根据part number顺序组装数据，并将元数据与对象关联，创建对象</li>
<li>每一部分上传完成，应包含分段唯一上传UD、Etag</li>
<li>S3 response包括唯一地标识所述组合对象数据一个ETag</li>
<li>当分段上传abort时，则中止并删除所有上传的分段。但是，任何其他已经正在上传的部分，必须在完成上传之后才能发送abort</li>
<li>S3需要明确接收到上传完成或中止请求，不然不会删除上传部分并会收取相关存储费用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟主机-vs-url路径访问模式"><a href="#虚拟主机-vs-url路径访问模式" class="headerlink" title="虚拟主机 vs url路径访问模式"></a>虚拟主机 vs url路径访问模式</h2><p>S3允许以路径样式或虚拟主机样式的url引用桶和对象</p>
<ul>
<li>Path style <ul>
<li>Bucket name不是域名一部分（除非使用区域特定端点）</li>
<li>使用的endpoint必须与存储桶所在的区域匹配，例如，如果有一个名为mybucket的存储桶位于EU（爱尔兰）区域，其对象名为puppy.jpg，则正确的路径样式语法URI为http：//s3-eu-west-1.amazonaws.com/mybucket/puppy.jpg</li>
<li>收到带有HTTP响应代码301的“PermanentRedirect”错误，这条消息表达的意思是：如果在美国东部（弗吉尼亚北部）区域之外访问存储桶，正确的合规的资源URL请使用如下表达方式：<ul>
<li><a href="http://s3.amazonaws.com" target="_blank" rel="noopener">http://s3.amazonaws.com</a></li>
<li>与存储区所在区域不同的区域的endpoint。 例如，如果使用<a href="http://s3-eu-west-1.amazonaws.com获取在美国西部（加利福尼亚州北部）地区创建的存储桶" target="_blank" rel="noopener">http://s3-eu-west-1.amazonaws.com获取在美国西部（加利福尼亚州北部）地区创建的存储桶</a></li>
</ul>
</li>
</ul>
</li>
<li>Virtual Host style <ul>
<li>S3 支持在所有区域中的虚拟主机托管和路径访问模式</li>
<li>在虚拟主机托管方式中，bucket name是url中域名的一部分</li>
<li>如<a href="http://bucketname.s3.amazonaws.com/objectname" target="_blank" rel="noopener">http://bucketname.s3.amazonaws.com/objectname</a></li>
<li>S3虚拟主机可用于通过使用HTTP host 标头头来使用REST API调用存储桶</li>
<li>优势<ul>
<li>自定义访问路径</li>
<li>提供发布到bucket虚拟主机的“root directory”的功能。此功能非常重要，许多现有应用程序会在此标准位置搜索数据</li>
</ul>
</li>
<li>当在任何区域中创建存储桶时，S3会更新DNS以将请求重新路由到正确的位置，这可能需要一些时间。</li>
<li>如果使用美国东部（弗吉尼亚北部）端点s3.amazonaws.com，则S3会将任何虚拟托管样式请求路由到美国东部（N.Virginia）区域，而不是特定于区域的端点（例如 ，s3-eu-west-1.amazonaws.com）并且S3将其重定向到HTTP 307重定向到正确的区域。</li>
<li>使用带有SSL的虚拟托管样式存储桶时，SSL通配符证书仅匹配不包含句点的存储桶。要解决此问题，请使用HTTP或自行编写证书验证逻辑。</li>
<li>如果向<a href="http://bucket.s3.amazonaws.com端点发出请求，则DNS有足够的信息将请求直接路由到存储区所在的区域。" target="_blank" rel="noopener">http://bucket.s3.amazonaws.com端点发出请求，则DNS有足够的信息将请求直接路由到存储区所在的区域。</a></li>
</ul>
</li>
</ul>
<h1 id="S3-Conssistency-Model-一致性模型"><a href="#S3-Conssistency-Model-一致性模型" class="headerlink" title="S3 Conssistency Model 一致性模型"></a>S3 Conssistency Model 一致性模型</h1><ul>
<li>S3通过在亚马逊数据数据中心内的多个服务器上复制数据来实现高可用性</li>
<li>S3为新的对象put 提供写后读一致性（read-after-write）<ul>
<li>对于PUT请求，S3在返回SUCCESS之前完成在多个设施中数据同步</li>
<li>进程对新对象的写入，可以立即读取对象</li>
<li>进程将新对象的写入S3能立即在其存储桶中列出key。 在完全传播更改之前，对象可能不会出现在list中</li>
</ul>
</li>
<li>S3对覆盖puts&amp;deletes 对象提供最终一致性<ul>
<li>对象的更新和删除，更改最终会反映出来并且不会立即可用</li>
<li>若进程替换现有对象并立即尝试读取它。 在完全传播更改之前，S3可能会返回先前的数据</li>
<li>若进程删除现有对象并立即尝试读取它。 在完全传播删除之前，S3可能会返回已删除的数据</li>
<li>若进程删除现有对象并立即在其存储桶中列出key。 在删除完全传播之前，S3可能会列出已删除的对象。</li>
</ul>
</li>
<li>对于key的更改是原子的。 例如，如果PUT到现有key，后续读取可能会返回旧数据或更新数据，但它永远不会写入损坏或只有部分数据（不存在中间状态，要么成功要么失败）。</li>
<li>S3目前不支持对象数据锁定。例如，如果同时对同一个key发出两个PUT请求，则具有最新时间戳的请求获胜。如果要避免这个问题，将需要在应用程序中构建一个对象锁定机制</li>
<li>更新是基于key的; 没有办法跨key进行原子更新。 例如，除非在应用程序中设计此功能，否则无法更新一个key取决于另一个key的更新</li>
</ul>
<h1 id="S3-Subresources"><a href="#S3-Subresources" class="headerlink" title="S3 Subresources"></a>S3 Subresources</h1><ul>
<li>S3 Subresources提供存储和管理bucket配置</li>
<li>S3 subresources 存在于特定的存储桶或对象中</li>
<li>S3定义了一组与桶和对象相关联的subresources</li>
<li>S3 subresources是对象的子集; 也就是说，它们不是自己存在的，它们总是与某个其他实体相关联，例如对象或桶(如acl或bittorrent)</li>
<li>S3支持配置存储桶的各种选项，例如，可以配置存储桶用于网站托管，添加配置以管理存储桶中对象的生命周期，以及记录对存储桶的所有访问</li>
</ul>
<h2 id="静态网站托管"><a href="#静态网站托管" class="headerlink" title="静态网站托管"></a>静态网站托管</h2><ul>
<li>S3可用于静态网站托管（client 处理脚本）</li>
<li>S3不支持服务端处理脚本</li>
<li>S3与Route 53结合使用，支持根域托管网站，直接指向指向S3网站端点</li>
<li>S3 网站端点不支持Https</li>
<li>对于S3网站托管，内容应该是公开可读的，可以使用桶策略或对象上的ACL来设置</li>
<li>用户可以自定义索引，错误页面以及指向对象名称的条件路由</li>
<li>存储桶策略仅适用于存储桶拥有者拥有的对象。如果存储桶包含不属于存储桶拥有者的对象，则应使用对象ACL授予对这些对象的公共READ权限</li>
<li>请求者支付费用或DevPay存储桶不允许通过网站端点进行访问。对此类存储桶的任何请求都将收到403 -拒绝响应</li>
</ul>
<h2 id="跨源资源共享-CORS"><a href="#跨源资源共享-CORS" class="headerlink" title="跨源资源共享 (CORS)"></a>跨源资源共享 (CORS)</h2><ul>
<li>所有浏览器都实现了同源策略，出于安全考虑，其中来自域网页只能从同一个域请求资源。</li>
<li>CORS允许装在一个域中访问受限的资源上的客户端Web应用程序从另一个域要求</li>
<li>在S3中使用CORS支持允许跨源访问S3资源</li>
<li>CORS配置规则标识允许访问存储桶的起源，每个源支持的操作（HTTP 方法）以及其他特定操作的信息</li>
</ul>
<h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><ul>
<li>默认情况下禁用日志记录，开启追踪可以记录S3访问记录</li>
<li>每单个访问请求的详细日志记录信息，包含请求者，存储桶名称，请求时间，请求操作，响应状态和错误代码（如果有）。</li>
<li>访问日志信息在安全性和访问审核中非常有用，还有助于了解客户和S3账单</li>
<li>S3定期收集访问日志记录，合并日志文件中的记录，然后将日志文件作为日志对象上载到目标存储桶。</li>
<li>如果在具有相同目标bucket的多个源存储桶上启用了日志记录，则目标存储桶将具有所有这些源存储桶的访问日志，但每个日志对象将报告指定其源存储桶的访问日志记录。<br>标签</li>
<li>S3提供标记子资源以存储和管理存储桶上的标记</li>
<li>可以将成本分配标签添加到存储桶以对AWS成本进行分类和跟踪</li>
<li>AWS可以产生与使用和添加到bucket中的标签汇总费用成本分配报告</li>
</ul>
<h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><ul>
<li>创建存储桶时，需要明确指定在将要创建S3存储桶的AWS区域</li>
<li>S3将此信息存储在subresource(子资源)中，并提供用于检索此信息的API</li>
</ul>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><ul>
<li>通过 Amazon S3 通知功能，可以在存储桶中发生某些事件时接收通知</li>
<li>通知级别是Bucket级</li>
<li>通知配置可以通过对象的key的前缀和后缀进行过滤，但是不能使用重叠定义过滤规则</li>
<li>S3支持的时间类型<ul>
<li>新对象创建<ul>
<li>PUT、POST、COPY操作</li>
<li>不会从失败的操作收到事件通知</li>
</ul>
</li>
<li>对象删除事件<ul>
<li>公共删除事件以删除对象，删除版本对象或删除标记的插入</li>
<li>不会收到来自生命周期策略或失败操作的自动删除的事件通知</li>
<li>RRS存储类别对象丢失事件</li>
<li>可用于重现/重新创建Object</li>
</ul>
</li>
</ul>
</li>
<li>S3支持将事件发布到一下目标<ul>
<li>SNS</li>
<li>SQS</li>
<li>AWS lambda</li>
<li>必须授予Amazon S3 权限以调用相应目标</li>
</ul>
</li>
</ul>
<h2 id="跨区域复制-CRR"><a href="#跨区域复制-CRR" class="headerlink" title="跨区域复制 (CRR)"></a>跨区域复制 (CRR)</h2><ul>
<li>跨区域复制是一项存储桶级别配置，该功能支持跨不同 AWS 区域中的存储桶自动异步复制对象</li>
<li>可以请求 Amazon S3 复制所有对象，也可以通过在配置中提供一个键名称前缀来请求复制部分对象</li>
<li>默认使用安全套接字层 (SSL) 跨 AWS 区域加密传输中的所有数据</li>
<li>除非复制配置中发出特定请求，否则目标存储桶中的对象副本与源存储桶中的对象完全相同</li>
<li>CRR可用于以下场景需求：<ul>
<li>合规性要求——跨区域备份</li>
<li>最大限度减少延迟 – 客户处于两个地理位置</li>
<li>操作原因 – 两个不同 AWS 区域中具有分析同一组对象的计算集群</li>
</ul>
</li>
<li>要求<ul>
<li>源存储桶和目标存储桶必须已启用版本控制</li>
<li>源存储桶和目标存储桶必须处于不同的 AWS 区域</li>
<li>对象只能从源存储桶复制到一个目标存储桶</li>
<li>S3 必须对象从源存储桶复制到目标存储桶的权限</li>
<li>源存储桶拥有者也是对象的拥有者，则其拥有复制对象的完全权限。如果不是，则对象拥有者必须通过对象 ACL 向存储桶拥有者授予 READ 和 READ_ACP 权限（s3:GetObjectVersion and s3:GetObjectVersionACL）</li>
<li>在跨账户方案 (其中，源存储桶和目标存储桶由不同的 AWS 账户拥有) 中设置复制配置，源存储区拥有者必须具有复制目标存储区中对象的权限。</li>
</ul>
</li>
<li>复制和不复制的内容<ul>
<li>复制的内容<ul>
<li>添加复制配置之后创建的任何新对象</li>
<li>S3 会复制使用 Amazon S3 托管密钥 (SSE-S3) </li>
<li>复制存储桶拥有者有权读取对象和访问控制列表 (ACL) 的源存储桶中的对象</li>
<li>虽然在Amazon S3可以使两者同步之前可能会有一些延迟，但会复制任何对象ACL更新。 这仅适用于将复制配置添加到存储桶后创建的对象。<ul>
<li>不复制的内容</li>
</ul>
</li>
<li>S3不会追溯复制添加复制配置之前存在的对象</li>
<li>S3不会复制存储桶拥有者没有权限的源存储桶中的对象</li>
<li>对存储桶级别子资源进行的更新不会进行复制</li>
<li>不会复制使用客户提供的加密密钥通过服务器端加密 (SSE-C) 创建的对象。</li>
<li>不会复制使用 AWS KMS 托管加密密钥通过服务器端加密 (SSE-KMS) 创建的对象</li>
<li>仅复制客户操作。不复制生命周期配置执行的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="S3-Storage-Tiers-存储分层"><a href="#S3-Storage-Tiers-存储分层" class="headerlink" title="S3 Storage Tiers 存储分层"></a>S3 Storage Tiers 存储分层</h1><ul>
<li>Amazon S3存储层旨在维持一个或两个设施中的并发数据丢失</li>
<li>S3存储层允许生命周期管理以自动迁移对象以节省成本</li>
<li>S3存储层支持传输中的数据和静态数据加密的SSL加密</li>
<li>S3还使用校验和定期验证数据的完整性，并提供自动修复功能</li>
</ul>
<h2 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h2><ul>
<li>针对性能敏感的场景和频繁访问数据的理想选择，能够在2个设施的故障情况下继续提供服务</li>
<li>默认的存储层</li>
<li>低延迟和高吞吐的性能</li>
<li>11个9的持久性设计方案</li>
<li>年可使用率达到99.99%</li>
<li>提供Amazon SLA服务等级保障协议</li>
</ul>
<h2 id="Standard-IA"><a href="#Standard-IA" class="headerlink" title="Standard-IA"></a>Standard-IA</h2><ul>
<li>S3 Standard-IA （infrequent Access）存储层旨在提供长周期保存和不长访问的数据，如备份和受限访问旧数据，但仍然在访问时需要提供Standard层的性能</li>
<li>STANDARD-IA旨在维持两个基础设施中的数据丢失</li>
<li>STANDARD_IA对象可用于实时访问</li>
<li>STANDARD_IA存储类适用于保留至少30天的大于128 KB的较大对象（较小的对象仅为128 KB）。</li>
<li>标准的低延迟和高吞吐量性能</li>
<li>专为99.999999999％的持久性设计</li>
<li>年可使用率达到99.99%</li>
<li>提供Amazon SLA服务等级保障协议</li>
</ul>
<h2 id="Reduced-Redundancy-Storage-–-RRS"><a href="#Reduced-Redundancy-Storage-–-RRS" class="headerlink" title="Reduced Redundancy Storage – RRS"></a>Reduced Redundancy Storage – RRS</h2><ul>
<li>RRS存储层设计用于以比STANDARD层别更低的冗余级别存储，存储非关键，可重现的数据，从而降低存储成本</li>
<li>专为99.99％的持久性设计</li>
<li>年可使用率达到99.99%</li>
<li>较低的冗余级别导致较低的耐用性和可用性</li>
<li>RRS将对象存储在多个设备的多个设备上，提供400倍于典型磁盘驱动器的耐用性，</li>
<li>RRS不会像S3标准存储一样多次复制对象，并且旨在维持单个设施中的数据丢失。</li>
<li>如果RRS对象丢失，则S3对该对象发出的请求返回405错误</li>
<li>S3可以发送在桶上配置的事件通知，以在检测到RRS对象丢失时用于警告用户或启动工作流，该RRS对象可用于替换丢失的对象</li>
</ul>
<h2 id="Glacier"><a href="#Glacier" class="headerlink" title="Glacier"></a>Glacier</h2><ul>
<li>GLACIER存储层特别适合用于存档数据，其中数据取回通常需要3-5小时罕</li>
<li>GLACIER存储层使用非常低成本的存储服务，但此存储类中的对象仍通过S3管理</li>
<li>专为99.999999999％的持久性设计</li>
<li>GLACIER不能在对象创建时指定为存储层，但必须使用生命周期管理从STANDARD，RRS或STANDARD_IA转换为GLACIER存储类。</li>
<li>访问Glacier 对象<ul>
<li>必须通过恢复对象，这可能需要3-5小时</li>
<li>对象仅适用于还原请求期间指定的时间段（天数）</li>
<li>对象的始终保存在Glacier</li>
<li>存档（GLACIER层费用）和临时恢复的副本（RRS层费用）均收取费用</li>
</ul>
</li>
<li>Vault Lock功能可锁定策略强制实施合规性</li>
</ul>
<h1 id="S3-Object-Lifecycle"><a href="#S3-Object-Lifecycle" class="headerlink" title="S3 Object Lifecycle"></a>S3 Object Lifecycle</h1><h2 id="S3-Object-Lifecycle-Overview"><a href="#S3-Object-Lifecycle-Overview" class="headerlink" title="S3 Object Lifecycle Overview"></a>S3 Object Lifecycle Overview</h2><ul>
<li>可以使用生命周期策略来管理S3对象生命周期，该生命周期策略定义S3在其生命周期中如何管理对象</li>
<li>生命周期策略简化对象的生命周期管理，例如移动访问频率较低的对象、备份或存档数年的数据或永久删除对象，所有操作都可以后台自动控制</li>
<li>每个bucket最多配置1000个生命周期规则</li>
<li>应用于存储桶的S3对象生命周期策略规则适用于存储桶中的现有对象以及将未来添加的对象</li>
<li>S3对象生命周期策略对数据管理支持两种操作：<ul>
<li>Transition(转换)，其对象可以更改存储层（class）</li>
<li>Expiration，到期时间永久删除</li>
</ul>
</li>
<li>生命周期策略可以与版本控制结合，允许一个当前对象版本和零级或多个非当前对象的版</li>
<li>生命周期策略适用于非版本控制和启用版本控制的存储桶</li>
<li>未开启版本控制bucket<ul>
<li>Transition周期从对象创建时算起</li>
</ul>
</li>
<li>开启版本控制bucket<ul>
<li>Transition周期从对象创建起开始</li>
<li>非当前对象的转换周期是为该对象成为非当前版本控制对象的日期计算的</li>
<li>S3使用自其后续对象创建以来的天数作为对象非当前的时间</li>
</ul>
</li>
<li>S3规则中指定的时间从对象创建时间开始算起，采用UTC记录。</li>
<li>不支持在bucket的生命周期策略使用MFA</li>
</ul>
<h2 id="S3-Object-Lifecycle-Management-Rules"><a href="#S3-Object-Lifecycle-Management-Rules" class="headerlink" title="S3 Object Lifecycle Management Rules"></a>S3 Object Lifecycle Management Rules</h2><ol>
<li>STANDARD或REDUCED_REDUNDANCY  - &gt;（128 KB和30天） - &gt; STANDARD_IA<ul>
<li>只能transition(转换)超过128kb的对象，因为只有较大的对象才能实现成本优势（转到Standard-ia）</li>
<li>在转换到STANDARD_IA之前，对象必须在当前存储层中至少30天，因为较新的对象被更频繁地访问或者比适合STANDARD_IA更早删除</li>
</ul>
</li>
<li>STANDARD_IA -&gt; X -&gt; STANDARD or REDUCED_REDUNDANCY<ul>
<li>无法从Standard-IA转换到Standard或reduced-redundancy</li>
</ul>
</li>
<li>STANDARD or REDUCED_REDUNDANCY or STANDARD_IA -&gt; GLACIER<ul>
<li>任何存储层数据都可以transition 到Glacier</li>
</ul>
</li>
<li>STANDARD or REDUCED_REDUNDANCY -&gt; (1 day) -&gt; GLACIER<ul>
<li>标准或RRS层转换到Glacier在一天内完成</li>
</ul>
</li>
<li>STANDARD_IA -&gt; (30 days) -&gt; GLACIER<ul>
<li>对象创建起或非当前版本日期，需要花费30~60天才能从Standard-IA转换到Glacier</li>
</ul>
</li>
<li>GLACIER-&gt; X -&gt; STANDARD or REDUCED_REDUNDANCY or STANDARD_IA<ul>
<li>对象转换到Glacier层时单向的</li>
<li>无法从Glacier层将数据转换到其他存储层</li>
</ul>
</li>
<li>GLACIER -&gt; (90 days) -&gt; Permanent Deletion<ul>
<li>归档到Glacier层的数据，已经存档3个月或更长，则删除归档对象是免费的</li>
<li>如果删除或覆盖存档3个月以内的对象，则会按比例收取相关费用</li>
</ul>
</li>
<li>STANDARD or STANDARD_IA or GLACIER -&gt; X-&gt; REDUCED_REDUNDANCY<ul>
<li>无法将数据从任何存储层转换到Reduced-redundancy</li>
</ul>
</li>
<li>使用对象生命周期策略将对象归档到Glacier是异步执行的，并且生命周期策略中的转换日期与物理转换的日期之间可能存在延迟。 但是，AWS会根据规则中指定的转换日期收取Glacier的价格。</li>
<li>开启版本控制的bucket<ul>
<li>Transition和Experition 都适合当前的版本</li>
<li>NoncurrentVersionTransition和NoncurrentVersionExpiration操作适用于非当前版本，其工作方式类似于未开启版本对象，但时间段是从对象变为非当前时间开始的</li>
</ul>
</li>
<li>过期规则<ul>
<li>未开启版本控制：对象永久删除</li>
<li>开启版本控制<ul>
<li>规则使用于current 对象，不影响任何非当前对象</li>
<li>S3将标记具有唯一ID的Delete Marker对象，并且先前的当前对象变为非当前版本</li>
<li>若当前对象已经有一个删除标记，将不会采取任何操作</li>
<li>如果bucket只有一个对象，并且已经标记删除（过期对象删除标记），S3移除删除标记</li>
</ul>
</li>
<li>版本控制suspend 桶<ul>
<li>S3将插入版本ID为null的Delete Marker标记，并覆盖版本ID为null的任何对象</li>
</ul>
</li>
</ul>
</li>
<li>当对象到达其生命周期的末尾时， S3将排队以进行删除并异步操作。 在到期日期和S3删除对象的日期之间可能存在延迟。不需要为与已过期的对象关联的存储时间付费。</li>
<li>如果生命周期策略置于STANDARD_IA中的对象不到30天，或者GLACIER少于90天，则会有额外的成本费用产生。</li>
</ol>
<h1 id="S3-Object-Versioning"><a href="#S3-Object-Versioning" class="headerlink" title="S3 Object Versioning"></a>S3 Object Versioning</h1><ul>
<li>版本控制可用于防止意外覆盖和删除数据</li>
<li>版本控制将对象多个不同版本保留在bucket中，用于保存历史版本，检索和还原对象的不同版本</li>
<li>由于版本控制保留了整个相同对象的多个副本，因此要为多个版本产生费用。 对于带有5个副本的1GB文件，如果存在细微的差异，则会消耗5GB的S3存储空间，并且需要支付相同5GB空间费用</li>
<li>默认情况下不启用版本控制，存储桶使用时要明确启用</li>
<li>版本一旦启用，无法禁用，只能暂停</li>
<li>Bucket启用版本控制，适用于存储桶中所有对象</li>
<li>权限在版本级别设置。 每个版本都有自己的对象所有者; AWS账户是创建对象版本所有者。 因此，可以为同一对象的不同版本设置不同的权限</li>
<li>无论如何控制版本，桶中每个对象都有一个版本<ul>
<li>未开启版本控制存储桶，每个对象的版本ID为null</li>
<li>开启版本控制的存储桶，每个对象分配唯一的版本ID</li>
</ul>
</li>
<li>版本控制，版本ID与桶名和对象key(键)一起构成一个唯一的key元素，用于定义桶中对象的唯一性</li>
<li>对象检索<ul>
<li>未开启版本控制存储桶：检索始终返回唯一的可用对象</li>
<li>开启版本控制的存储桶，返回当前对象，可以通过指定版本ID返回非当前对象</li>
</ul>
</li>
<li>对象添加<ul>
<li>未开启版本控制：再次上传相同键的对象，则会覆盖该对象</li>
<li>开启版本控制：上传相同键的对象，则新上传的将会成为当前版本，之前的成为非当前版本</li>
<li>可以检索和恢复非当前版本化对象，从而防止意外覆盖</li>
</ul>
</li>
<li>删除对象<ul>
<li>未开启版本控制：对象永久删除，且无法恢复</li>
<li>开启版本控制：所有对象都保留，Amazon会插入一个删除标记，用于标记当前版本；可以检索和恢复非当前版本对象，从而防止意外删除和覆盖；如果指定删除版本ID的对象，则会永久删除且无法恢复</li>
</ul>
</li>
<li>删除标记<ul>
<li>删除标记对象没有任何与之关联的数据或acl，只有key和版本ID</li>
<li>对已经使用删除标记的对象检索将返回404</li>
<li>已经标记“delete marker”对象上只允许DELETE操作</li>
<li>指定其版本ID删除标记对象，则先前的版本对象将成为当前版本对象</li>
<li>如果将DELETE标记作为当前版本在桶上触发DELETE请求，则不会删除DELETE标记，而是再次添加一个DELETE标记</li>
</ul>
</li>
<li>恢复之前版本<ul>
<li>将先前版本对象复制到同一存储桶中。复制的对象将成为该对象当前的版本，并保留之前的对象版本。（建议保留所有版本）</li>
<li>永久删除当前版本时，世纪将之前的版本转换为当前版本</li>
</ul>
</li>
<li>暂停版本控制<ul>
<li>可以暂停版本控制功能，以停止存储桶后续对象的积累新的版本</li>
<li>已存在的对象不会更改，只对新添加对象有效</li>
<li>对于每个新添加的对象，对象添加版本ID为null</li>
<li>对于具有相同key的对象添加，对象和版本ID（null）都会被覆盖</li>
<li>存储桶上的DELETE请求将永久删除版本ID空对象并插入删除标记</li>
<li>如果存储桶没有版本ID为null的对象，则DELETE请求不会删除任何内容</li>
<li>对于存储了版本ID的任何先前对象，仍然可以使用指定版本ID触发DELETE请求</li>
</ul>
</li>
<li>启用 MFA 删除<ul>
<li>启用MFA删除，可以提高起安全性</li>
<li>在存储桶上启用MFA删除，以确保不会意外删除存储桶中的数据</li>
<li>存储桶拥有者，创建存储桶（root帐户）的AWS账户以及所有授权的IAM用户可以启用版本控制，但只有存储桶拥有者（root帐户）可以启用MFA删除</li>
</ul>
</li>
</ul>
<h1 id="S3-Permission-权限"><a href="#S3-Permission-权限" class="headerlink" title="S3 Permission 权限"></a>S3 Permission 权限</h1><ul>
<li>默认情况下，所有S3 存储桶，对象和相关子资源都时私有的</li>
<li>可以通过AWS 账户或IAM（有权限）访问资源</li>
<li>存储拥有者时创建存储桶的AWS账户</li>
<li>对象所有者是将对象上载到存储桶的AWS账户，而不是该账户所拥有的存储桶</li>
<li>只有资源所有者（创建资源的AWS账户）才能访问该资源</li>
<li>资源所有者<ul>
<li>创建存储桶或对象的AWS账户时这些资源拥有者</li>
<li>如果IAM用户创建存储桶或对象，则IAM用户的AWS账户拥有该资源</li>
<li>如果存储桶拥有者向其他AWS账户用户授予跨对象权限以将对象上载到存储桶，则对象由上载对象的用户的AWS账户拥有，而不是存储桶拥有者，但以下条件除外<ul>
<li>存储桶拥有者可以拒绝访问该对象，因为它是支付该对象的存储桶拥有者</li>
<li>存储桶拥有者可以删除或应用存档规则到对象并执行恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="S3-权限分类"><a href="#S3-权限分类" class="headerlink" title="S3 权限分类"></a>S3 权限分类</h2><ul>
<li>基于资源的策略和用户策略</li>
</ul>
<h3 id="用户策略"><a href="#用户策略" class="headerlink" title="用户策略"></a>用户策略</h3><ul>
<li>基于用户的策略使用IAM和S3来控制用户或用户组对AWS账户拥有的S3存储桶的访问类型</li>
<li>基于用户的策略始终附加到用户，组或角色，无法授予匿名权限</li>
<li>如果拥有存储桶的AWS账户想要向其帐户中的用户授予权限，则可以使用存储桶策略或用户策略</li>
</ul>
<h3 id="资源策略"><a href="#资源策略" class="headerlink" title="资源策略"></a>资源策略</h3><ul>
<li>存储桶策略和访问控制列表（ACL）是基于资源的，因为它们附加到Amazon S3资源</li>
</ul>
<p><img src="https://i.loli.net/2019/08/19/qv6ix2mDjR4XkUS.jpg" alt="001.jpg"></p>
<ul>
<li>存储桶策略&amp;访问控制列表</li>
</ul>
<h3 id="存储桶策略"><a href="#存储桶策略" class="headerlink" title="存储桶策略"></a>存储桶策略</h3><ul>
<li>存储桶策略用于向其他AWS账户或IAM用户授予对其中的存储桶和对象的跨账户访问权限</li>
<li>桶策略提供集中的，基于各种条件，包括S3的操作，请求者，资源和方面请求的访问控制区和物件（例如IP地址）</li>
<li>如果拥有存储桶的AWS账户想要向其帐户中的用户授予权限，则可以使用存储桶策略或用户策略</li>
<li>附加到存储桶的权限适用于存储桶所有者创建和拥有的该存储桶中的所有对象</li>
<li>策略可以在存储桶中的所有（或子集）对象上添加或拒绝权限</li>
<li>仅允许存储桶拥有者将策略与存储桶关联</li>
<li>仅允许存储桶拥有者将策略与存储桶关联</li>
</ul>
<h3 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h3><ul>
<li>存储桶和对象都可以有与之相关联的ACL</li>
<li>ACL是一个授权列表，用于标识被授予者和授予的权限</li>
<li>ACL向其他账户授予对资源的基本读/写权限</li>
<li>ACL是一系列的受限的权限集，<ul>
<li>不能授予条件权限，</li>
<li>也不能显式拒绝权限</li>
<li>不能用于授予bucket子资源的权限</li>
</ul>
</li>
<li>可以通过电子邮件地址或规范用户ID（模糊匹配的帐户ID）向AWS账户授予权限。 如果提供了电子邮件地址，S3仍会找到该用户的规范用户ID并将其添加到ACL</li>
<li>建议使用规范的用户ID，电子邮件地址将来不会被支持</li>
</ul>
<h3 id="Bucket-ACL"><a href="#Bucket-ACL" class="headerlink" title="Bucket ACL"></a>Bucket ACL</h3><ul>
<li>仅推荐用于 bucket ACL的用例是向S3 Log Delivery组授予写入权限，以将访问日志对象写入存储区</li>
<li>如果存储桶需要访问日志传送，则bucket ACL将有助于将存储桶的写入权限授予日志传送组</li>
<li>只有这样才能通过bucket ACL为日志传送组授予必要的权限</li>
</ul>
<h3 id="Object-ACL"><a href="#Object-ACL" class="headerlink" title="Object ACL"></a>Object ACL</h3><ul>
<li>对象ACL仅控制对象级权限</li>
<li>对象ACL是管理不属于存储桶拥有者的存储桶中对象的权限的唯一方法，即如果存储桶拥有者允许跨帐户对象上载，并且对象所有者与存储桶拥有者不同，则对象的所有者授予对象的权限是通过对象ACL</li>
<li>如果存储桶和对象由同一AWS账户拥有，则可以使用存储桶策略来管理权限</li>
<li>如果对象和用户归同一AWS账户所有，则可以使用用户策略来管理权限</li>
</ul>
<h3 id="Amazon-S3-请求授权"><a href="#Amazon-S3-请求授权" class="headerlink" title="Amazon S3 请求授权"></a>Amazon S3 请求授权</h3><pre><code>当Amazon S3收到请求时，它将评估所有用户策略，存储桶策略和确定是否授权或拒绝该请求。</code></pre><p>S3将在3个方面进行策略评估</p>
<ul>
<li><p>User context 是S3评估AWS父账户（上下文）附加到用户策略的基本策略</p>
</li>
<li><p>Bucket context是S3评估存储桶所有者拥有访问策略的上下文，以检查存储桶所有者是否显式拒绝访问资源</p>
</li>
<li><p>Object context是是S3评估对象所有者拥有的策略的上下文</p>
<h3 id="类比场景"><a href="#类比场景" class="headerlink" title="类比场景"></a>类比场景</h3></li>
<li><p>假设有三个AWS账户，A、B、C且其子用户（IAM user）分别为AA、BA、CA</p>
</li>
<li><p>A账户拥有Toy bucket,其中存储对象Toy AAA,允许对象被删掉和创建</p>
</li>
<li><p>A账户创建一个授权，AA可以访问Toy bucket和其中对象（user policy或Bucket policy或两者都包含）</p>
</li>
<li><p>A创建一个授权（bucket policy），允许B可以创建对象在Toy bucket中；那么B可以授权其BA在Toy bucket中创建对象(如BAA)的策略（user policy）</p>
</li>
<li><p>B可以授权A访问Toy bucket中BAA的权限策略（object acl）</p>
</li>
<li><p>A创建一个授权（bucket policy）访问Toy bucket中AAA（object）的策略，而C又可以授权CA访问AAA的权限策略（user policy）</p>
</li>
<li><p>A 可以授权C访问BAA（object）的权限(IAM role）,而C又可以授权CA访问BAA的权限（user policy）</p>
</li>
</ul>
<h3 id="Bucket-操作授权"><a href="#Bucket-操作授权" class="headerlink" title="Bucket 操作授权"></a>Bucket 操作授权</h3><p><img src="https://i.loli.net/2019/08/19/k6UAI5Cyf87sE1P.jpg" alt="002.jpg"></p>
<ol>
<li>如果请求者是 IAM 用户，则该用户必须拥有来自其所属的父 AWS 账户的权限。在此步骤中，Amazon S3 将评估由父账户 (也称为上下文机构) 拥有的一个策略子集。该策略子集包含父账户附加到该用户的用户策略。如果父级也拥有请求中的资源 (在本例中为存储桶)，则 Amazon S3 还会同时评估相应资源策略 (存储桶策略和存储桶 ACL)。</li>
<li>请求者必须拥有来自存储桶拥有者的权限才能执行特定存储桶操作。在此步骤中，Amazon S3 对由拥有该存储桶的 AWS 账户拥有的策略子集进行评估。</li>
<li>存储桶拥有者可通过使用存储桶策略或存储桶 ACL 来授予权限</li>
</ol>
<h3 id="Object操作授权"><a href="#Object操作授权" class="headerlink" title="Object操作授权"></a>Object操作授权</h3><p> <img src="https://i.loli.net/2019/08/19/skd6nRq1mWagxoB.jpg" alt="003.jpg"></p>
<ol>
<li>如果请求者是 IAM 用户，则该用户必须拥有来自其所属的父 AWS 账户的权限</li>
<li>Amazon S3 会评估由父账户 (也称为上下文机构) 拥有的一个策略子集。该策略子集包含父级附加到该用户的用户策略。如果父级也拥有请求中的资源 (存储桶、对象)，则 Amazon S3 还会同时评估相应资源策略 (存储桶策略、存储桶 ACL 和对象 ACL)</li>
<li>在此上下文中，Amazon S3 评估拥有该存储桶的 AWS 账户所拥有的策略。如果拥有请求中的对象的 AWS 账户与存储桶拥有者不同，则 Amazon S3 会在存储桶上下文中检查策略，查看存储桶拥有者是否已显式拒绝对该对象的访问。如果对该对象设置了显式拒绝，则 Amazon S3不对请求授权。</li>
<li>请求者必须拥有来自对象拥有者的权限才能执行特定对象操作。在此步骤中，Amazon S3将评估对象 ACL</li>
</ol>
<h3 id="权限委派"><a href="#权限委派" class="headerlink" title="权限委派"></a>权限委派</h3><ul>
<li>如果AWS账户拥有资源，则可以将这些权限授予另一个AWS账户。</li>
<li>该帐户可以将这些权限或其中一部分委派给帐户中的用户。 这称为权限委派。</li>
<li>但是，从其他帐户接收权限的帐户无法将权限跨帐户委派给其他AWS账户。</li>
<li>如果Bucket所有者想要将不属于它的Object的权限授予其他AWS账户，则无法通过跨账户权限执行该操作，并且需要定义IAM角色，AWS账户可以采用该角色来获取访问权限</li>
</ul>
<h1 id="S3-Data-Protection"><a href="#S3-Data-Protection" class="headerlink" title="S3 Data Protection"></a>S3 Data Protection</h1><ul>
<li>Amazon S3 为任务关键型和主数据存储提供了高度耐用的存储基础设施。在 Amazon S3 区域，对象以冗余方式存储在多个设施间的多个设备中。</li>
<li>对象冗余地存储在S3区域中的多个设施上的多个设备上</li>
<li>为帮助确保数据持久性，Amazon S3 PUT 和 PUT Object copy 操作会在多个设施间同步完成之后，然后才会返回 SUCCESS</li>
<li>存储对象后，Amazon S3 将通过快速检测和修复任何丢失的冗余数据，保持对象的持久性</li>
<li>S3 还会使用校验和定期验证所存储数据的完整性。如果 Amazon S3 检测到数据损坏，它将使用冗<br>余的数据进行修复</li>
<li>Amazon S3 还会在存储或检索数据时对所有网络流量计算校验和，以检测数据包是否损坏</li>
<li>S3还提供保护传输中的数据（当它往返S3时）和静止存放（当它存储在S3中时）的能力</li>
</ul>
<h2 id="传输中的数据"><a href="#传输中的数据" class="headerlink" title="传输中的数据"></a>传输中的数据</h2><ul>
<li>通过SSL或使用客户端加密进行通信来保护传输中的数据</li>
</ul>
<h2 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h2><ul>
<li>支持客户端加密和服务器端加密，以保护静态数据</li>
<li>服务器端加密关乎静态数据加密，即 Amazon S3 将数据写入数据中心内的磁盘时会在对象级别上加密这些数据，并在访问这些数据时解密这些数据</li>
<li>使用客户端加密，可以加密客户端数据并将加密数据上传到S3。 在这种情况下，自行管理加密过程，加密密钥和相关工具</li>
</ul>
<h2 id="Server-side-加密"><a href="#Server-side-加密" class="headerlink" title="Server-side 加密"></a>Server-side 加密</h2><ul>
<li>服务器端加密关于静态数据加密</li>
<li>服务器端加密仅加密对象数据,对象元数据是不加密的</li>
<li>S3处理数据对象的加密（写入磁盘时）和解密（访问对象时）</li>
<li>加密或未加密对象的访问机制没有区别，并由S3透明处理</li>
</ul>
<h2 id="Server-Side-Encryption-with-Amazon-S3-Managed-Keys-SSE-S3"><a href="#Server-Side-Encryption-with-Amazon-S3-Managed-Keys-SSE-S3" class="headerlink" title="Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)"></a>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)</h2><ul>
<li><p>Amazon S3 托管加密密钥的服务器端加密 (SSE-S3) 采用了多因素强加密。S3 使用唯一的密钥来加密每个对象。作为额外的保护，它将使用定期轮换的主密钥对密钥本身进行加密。</p>
</li>
<li><p>S3 服务器端加密使用可用的最强数据块密码之一 (即 256 位高级加密标准 (AES-256))来加密数据</p>
</li>
<li><p>当使用预签名url上传对象时，不能强制使用SSE-S3加密对象，因为指定服务器端加密的惟一方法是通过AWS管理控制台或HTTP请求头<br>Server-Side Encryption with AWS KMS-Managed Keys (SSE-KMS)<br><img src="https://i.loli.net/2019/08/19/3Ekn2RjTqsCFVUW.jpg" alt="004.jpg"></p>
</li>
<li><p>SSE-KMS类似于SSE-S3，但它使用AWS Key Management Services（KMS），它提供额外的优势和性价比</p>
<ul>
<li>AWS Key Management Service (AWS KMS) 是一项将安全、高度可用的硬件和软件结合起来，提供可扩展到云的密钥管理系统的服务</li>
<li>KMS 使用用户主密钥 (CMK) 加密Amazon S3 对象</li>
<li>主密钥（master key）从不使用</li>
<li>KMS集中创建加密密钥，定义控制密钥使用方式的策略</li>
<li>通过检查AWS CloudTrail中的日志，审计使用密钥用法是否正确使用</li>
<li>允许临时禁用和重新启用密钥</li>
<li>允许key进行定期轮换</li>
<li>AWS KMS中的安全控制有助于满足与加密相关的合规性要求</li>
</ul>
</li>
<li><p>SSE-KMS为使用信封密钥（即保护数据加密密钥的密钥）启用单独的权限，从而提供额外的保护，防止在S3中对对象进行未经授权的访问</p>
</li>
<li><p>SSE-KMS提供了创建和管理加密密钥的选项，或者默认使用客户主密钥(CMK)，该主密钥可用于当前服务，并且所工作的区域是惟一的</p>
</li>
<li><p>创建自定义的CMK可提供更大灵活性，包括创建、轮换、禁用和定义访问控制，以及审核用于保护数据的加密密钥的能力</p>
</li>
<li><p>用于加密数据的数据密钥也会加密并与它们保护的数据一起存储，并且对每个对象都是唯一的</p>
</li>
<li><p>处理流程</p>
<ul>
<li>应用程序或AWS服务客户端请求加密密钥来加密数据，并将引用传递给帐户下的主密钥</li>
<li>验证客户端请求是否有权使用主密钥进行加密</li>
<li>创建新的<table><tr><td bgcolor="orange">数据加密密钥</td></tr></table>，并在<table><tr><td bgcolor="red">主密钥（CMK）</td></tr></table>下加密<table><tr><td bgcolor="orange">数据加密密钥</td></tr></table>（经过授权）</li>
<li>数据密钥和加密数据密钥都返回给客户端</li>
<li>数据密钥用于加密客户数据，建议在实际使用完加密密钥之后尽快将其从内存中删除</li>
<li>保留<table><tr><td bgcolor="orange">加密数据密钥</td></tr></table>以供以后使用，并在需要解密数据时将其发送回AWS KMS进行解密获取数据密钥<br>Server-Side Encryption with Customer-Provided Keys (SSE-C)<br><img src="https://i.loli.net/2019/08/19/KT7oy4njN6IH9Fb.jpg" alt="005.jpg"></li>
</ul>
</li>
<li><p>使用客户提供的加密密钥的服务器端加密 (SSE-C) 允许设置自己的加密密钥。</p>
</li>
<li><p>S3在访问对象时管理加密，写入磁盘和解密载对象时，加密密钥作为请求的一部分提供，S3使用该加密密钥对数据应用AES-256加密，并从内存中删除加密密钥</p>
</li>
<li><p>在检索对象时，必须提供相同的加密密钥作为请求的一部分。Amazon S3 在将对象数据返回之前，会首先验证提供的加密密钥是否匹配，然后再解密对象</p>
</li>
<li><p>每个对象，每个对象的版本可以使用不同的密钥进行加密，但需要自行负责维护对象和所使用的加密密钥之间的映射。</p>
</li>
<li><p>SSE-C请求必须通过HTTPS完成，S3将拒绝使用SSE-C时通过http发出的任何请求</p>
</li>
<li><p>出于安全原因，错误地使用 http 发送的任何密钥都将存在被外泄的可能性。此时应丢弃该密钥，并根据需要轮换密钥</p>
</li>
<li><p>S3 不存储加密密钥，而是存储加密密钥添加了随机数据的 HMAC 值来验证请求。无法使用添加了随机数据的 HMAC 值来推导出加密密钥的值或解密加密对象的内容。这意味着，如果丢失加密密钥，则会失去该对象</p>
</li>
</ul>
<h2 id="客户端加密"><a href="#客户端加密" class="headerlink" title="客户端加密"></a>客户端加密</h2><p>客户端加密是指在将数据发送到Amazon S3之前加密数据并在下载之后解密数据。</p>
<h2 id="使用-AWS-KMS-托管客户主密钥-CMK"><a href="#使用-AWS-KMS-托管客户主密钥-CMK" class="headerlink" title="使用 AWS KMS 托管客户主密钥 (CMK)"></a>使用 AWS KMS 托管客户主密钥 (CMK)</h2><ul>
<li>客户可以使用 AWS KMS 托管客户主密钥用于客户端数据加密时，此时使 AWS KMS 客户主密钥 ID (CMK ID)</li>
<li>上传对象时<ul>
<li>客户端首先将请求发送到 AWS Key Management Service (AWS KMS)以获取可用于加密对象数据的密钥</li>
<li>AWS KMS 将返回一个随机生成的数据加密密钥，其中包含客户端用于<table><tr><td bgcolor="orange">加密对象数据的纯文本版本</td></tr></table>和客户端将作为对象元数据上传到 Amazon S3 的<table><tr><td bgcolor="orange">同一数据加密密钥的密码 blob</td></tr></table></li>
<li>客户端将为其上传的每个对象获取一个唯一的数据加密密钥</li>
<li>AWS S3加密的客户端上载与对象元数据的加密数据和加密BLOB</li>
</ul>
</li>
<li>下载对象时<ul>
<li>客户端首先从 Amazon S3 下载加密的对象以及作为对象元数据存储的数据加密密钥的密blob 版本</li>
<li>客户端将密码 blob 发送到 AWS KMS 以获取密钥的纯文本版本，以便让客户端解密对象数据<br>使用客户端主密钥</li>
</ul>
</li>
<li>加密主密钥完全在客户端维护</li>
<li>上传对象时<ol>
<li>Amazon S3 加密客户端在本地生成一个一次性对称密钥 (也称为“数据加密密钥”或“数据密钥”)。它使用数据密钥加密单个 Amazon S3 对象的数据。该客户端将为每个对象生成一个单独的数据密钥。</li>
<li>该客户端使用主密钥来加密数据加密密钥。客户端会将加密的数据密钥及其材料说明作为对象元数据的一部分上传。</li>
<li>该客户端将加密数据上传到 Amazon S3 并在 Amazon S3 中将加密数据密钥保存为对象元数据 (xamz-meta-x-amz-key)</li>
</ol>
</li>
<li>下载对象时<ul>
<li>该客户端从 Amazon S3 下载加密的对象。</li>
<li>通过对象元数据中的说明，该客户端将确定要用于解密数据密钥的主密钥</li>
<li>该客户端将使用该主密钥解密数据密钥，然后使用该数据密钥对对象进行解密</li>
</ul>
</li>
<li>客户端主密钥和未加密的数据从来不会发送到 AWS。务必安全地管理加密密钥</li>
<li>如果丢失了加密密钥，将无法解密数据</li>
</ul>
<h1 id="S3-最佳实践"><a href="#S3-最佳实践" class="headerlink" title="S3 最佳实践"></a>S3 最佳实践</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="并发PUTS-GETS"><a href="#并发PUTS-GETS" class="headerlink" title="并发PUTS/GETS"></a>并发PUTS/GETS</h3><ul>
<li>Amazon S3 可进行扩展，以支持非常高的请求速率。如果请求速率稳定增长，则 Amazon S3 会自动根据需要将存储桶进行分区，以支持更高的请求速率</li>
<li>如果典型工作负载仅涉及每秒100个请求的偶尔突发和每秒少于800个请求，则AWS会自动进行扩展和处理</li>
<li>如果预计存储桶的请求速率会快速提高到超过每秒 300 个 PUT/LIST/DELETE 请求或超过每秒 800 个 GET 请求，建议申请support,以便为工作负载做好准备，并且避免对请求速率的任何临时限制</li>
<li>仅当每秒定期处理100个或更多请求时，才能应用S3最佳实践指南</li>
<li>混合请求类型的工作负载<ul>
<li>如果请求一般为 GET、PUT、DELETE 或 GET Bucket (列出对象) 的组合，则为对象合理选择键名称可缩短访问 Amazon S3 索引的延迟，从而确保实现更高的性能</li>
<li>这种方式是由S3 存储key驱动的<ul>
<li>Amazon S3 在每个 AWS 区域维护对象键名称的索引</li>
<li>对象键以 UTF-8 二进制顺序保存在索引的多个分区中，键名称指示用于存储键的分区</li>
<li>对于大量键，使用顺序前缀 (如时间戳或字母顺序) 可增大 Amazon S3以特定分区为目标的可能性，从而耗尽该分区的 I/O 容量。</li>
</ul>
</li>
<li>如果在键名称前缀中引入某种随机性，则键名称 (以及 I/O 负载) 会在多个分区间分布</li>
<li>无论每秒发送的请求数量如何，它还可确保可扩展性</li>
</ul>
</li>
<li>GET 密集型工作负载<ul>
<li>建议使用 Amazon CloudFront 内容传输服务</li>
<li>向用户分发内容时同时实现低延迟和高数据传输速率。另外可以减少向 Amazon S3 发送直接请求，从而降低成本</li>
<li>支持Web分发或RTMP分发<h3 id="PUTs-GETs-for-Large-Objects"><a href="#PUTs-GETs-for-Large-Objects" class="headerlink" title="PUTs/GETs for Large Objects"></a>PUTs/GETs for Large Objects</h3></li>
</ul>
</li>
<li>AWS支持并行化PUT / GET请求以提高上载和下载性能以及在失败时恢复的能力</li>
<li>对于上传，分段上传可以帮助改善上传体验<ul>
<li>同时执行多个上载并最大化网络带宽利用率</li>
<li>从故障中快速恢复，因为只有一部分上传失败需要重新上传</li>
<li>暂停和恢复上传的能力</li>
<li>在已知对象大小之前开始上载</li>
</ul>
</li>
<li>对于GET，range http标头可以帮助提高下载<ul>
<li>允许在部分而不是整个对象中检索对象</li>
<li>从故障中快速恢复，因为只有无法下载的部分需要重试</li>
</ul>
</li>
</ul>
<h2 id="List-Operations"><a href="#List-Operations" class="headerlink" title="List Operations"></a>List Operations</h2><ul>
<li>对象键(key)以字典顺序存储在Amazon S3索引中，因此很难对LIST的内容进行排序和操作</li>
<li>S3维护单个按字典顺序排序的索引列表</li>
<li>在S3之外构建和维护二级索引，例如 DynamoDB或RDS用于存储，索引和查询对象元数据，而不是在S3上执行操作</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>开启版本控制<ul>
<li>防止意外的覆盖和删除</li>
<li>允许检索和恢复已删除对象或回滚到以前版本的功能</li>
</ul>
</li>
<li>启用MFA（多重身份验证）删除来启用安全性</li>
<li>版本控制不会阻止Bucket删除，必须进行备份，就像意外或恶意删除数据一样</li>
<li>使用跨区域复制功能将数据备份到其他区域</li>
<li>将VPC与S3一起使用时，建议使用VPC S3端点<ul>
<li>是水平缩放，冗余和高可用性的VPC组件</li>
<li>帮助在VPC和S3之间建立专用连接，流量永远不会离开AWS网络</li>
</ul>
</li>
</ul>
<h2 id="Traking"><a href="#Traking" class="headerlink" title="Traking"></a>Traking</h2><ul>
<li>使用事件通知来通知S3put或delete请求</li>
<li>使用CloudTrail，便于 AWS账户捕获特定的API调用，并提供日志文件到一个S3桶</li>
<li>使用CloudWatch监控Amazon S3存储桶，跟踪存储的对象计数和字节等指标，并配置相应的操作</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/18/思考心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/思考心得/" itemprop="url">思考心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T18:29:45+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/思考心得/" itemprop="url" rel="index">
                    <span itemprop="name">思考心得</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="思考心得"><a href="#思考心得" class="headerlink" title="思考心得"></a>思考心得</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>架构的本质并非时要解决领域内的具体问题，而是复杂度管理，用于将所面对的复杂度客观对象。问题和解决方案的复杂度进行有效的分解和管理，并尽量减轻内外变化所产生影响。</li>
<li>领域问题的解决方案靠的时相关的解决方案，同样的一个问题可以有不同的解决方案，虽然他们的目标时一致的，但由于各架构的不同，各个结局方案的灵活性、坚固性和扩展性不同，因而我们在为解决方案选择架构的时候关注的并不是其是否可以解决问题，更多的是对架构所带来的灵活性、坚固性和扩展性于相应的成本之间进行权衡。</li>
</ul>
<ol>
<li>根据要解决的问题，对目标系统的边界进行界定</li>
<li>并对目标系统按某个原则进行切分。切分的原则，要适于不同的角色，对切分出来的部分，并行或串行开展工作，一般并行才能减少时间</li>
<li>并对切分出来的部分，设立沟通机制</li>
<li>根据3，使得这些部分之间能够进行有机联系，合并组装成为一个整体，完成目标系统所有工作<br>核心：对问题的分析，以及解决问题方案<br>目标问题是<font color="red">谁</font>的问题    问题的主体（隐含边界）<br>问题不是解决方案</li>
</ol>
<h3 id="企业架构"><a href="#企业架构" class="headerlink" title="企业架构"></a>企业架构</h3><ul>
<li><strong>物理架构</strong>：包括IDC机房、机房之间访问关系、机房内机器物理部署图、机房与业务分布、网络架构、数据库架构、集群清单和域名清单</li>
<li><strong>应用架构</strong>：应用+架构，应用时系统的最小单元，应用分类和应用编排则构成了应用关系即应用架构</li>
<li><strong>企业商务模型</strong>：静态商务业务主体、组织架构、动态的商务运作模型、业务流程</li>
<li><strong>信息系统模型</strong>：功能架构、应用架构、数据设计和物理架构</li>
</ul>
<blockquote>
<p>应用架构从单一应用角度出发，其主要时从应用的功能触发，即从应用的数据、展现方式和业务逻辑等方面来制定应用的结构和构造方法</p>
</blockquote>
<blockquote>
<p>企业架构则从企业战略和整体业务触发，从技术上制定用以支持企业和战略的各种应用、数据和基础设施</p>
</blockquote>
<p> <em>软件本身并不能解决企业问题，只有配套的架构、流程、制度与意识才能发挥软件的功效</em></p>
<ul>
<li>运维要为应用服务，应用要为业务服务，业务为客户服务</li>
</ul>
<h2 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h2><ul>
<li><p>与当前的<strong>传统客户</strong>谈PaaS，其不可避免的要谈到应用的解构和重构，而这是当前国内非常难做的，并不像IaaS基础资源已经融入到用户的实际生产、测试环境中。</p>
</li>
<li><p>开源社区做的是项目，不是产品，尤其不是企业级产品</p>
</li>
<li><p>私有云严格来说不是云，至少缺乏云应有的规模和弹性</p>
</li>
<li><p>现有的企业私有云或公有云一资源为中心，而PaaS要以应用为中心</p>
</li>
<li><p>伤员不能只是资源上云，上云更应是一种理念。上云至少还包括开发上云（面向云开发、DevOps、CI/CD）、应用上云（面向云定制应用的云上架构）</p>
</li>
<li><p>面向业务运维，而不是面向资源运维</p>
</li>
<li><p>企业用户需求：</p>
<ul>
<li>关注稳定、数据安全、现有DC打通、迁移成本、是否要更改应用架构才能上云、现有运维整合</li>
</ul>
</li>
<li><p>2B和2C产品经理区别：前者关注企业用户需求，后者关注产品运营、用户体验</p>
</li>
</ul>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>国内的互联网巨头成就了体量和估值，却没有创造出来真正的商业文明和伦理。</li>
<li>后摇，将这份寄生在我们身上的痛苦，化为一面镜子，我们赤裸地站在面前，审视在镜中同样赤裸的自己，打破、流血、痛哭、沉默、颓唐、寂灭，我们被迫接受现实，寄生于身上的痛苦，不过是被生命的贪婪所灼伤。</li>
<li>骄傲是对自己拥有某一方面突出价值的确信，但虚荣则试图在别人那里唤起自己对此的确信。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://sevengarden.club/2019/08/18/AWS-RDS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seven">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="岳阳北寒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/AWS-RDS/" itemprop="url">AWS RDS </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-18T10:39:26+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AWS/" itemprop="url" rel="index">
                    <span itemprop="name">AWS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AWS-Relation-Database-Service"><a href="#AWS-Relation-Database-Service" class="headerlink" title="AWS Relation Database Service"></a>AWS Relation Database Service</h1><ul>
<li>Amazon Relational Database Service (Amazon RDS) 是一项 Web 服务，让用户能够在云中更轻松地设置、操作和扩展关系数据库。</li>
<li>它可以经济有效的为用户提供一个容量可调的行业标准的关系数据库，并承担常见的数据库管理任务。</li>
<li>RDS 功能及优势<ul>
<li>CPU，内存，存储和IOPS可以独立扩展</li>
<li>Amazon RDS 可以管理备份、软件修补、自动故障检测和恢复</li>
<li>可以在需要时执行自动备份，也可以手动创建备份快照。可以使用这些备份还原数据库。Amazon RDS 还原过程将可靠且高效地工作</li>
<li>通过主实例和在发生问题时可向其执行故障转移操作的同步辅助实例实现高可用性。还可以使用 MySQL、MariaDB 或 PostgreSQL 只读副本扩展读取, 从而提供弹性和可伸缩性。</li>
<li>支持MySQL，MariaDB，PostgreSQL，Oracle，Microsoft SQL Server以及与MySQL兼容的全新Amazon Aurora数据库引擎</li>
<li>除了数据库包中的安全性之外，IAM用户和权限还可以帮助控制谁有权访问RDS数据库服务</li>
<li>数据库可以通过将它们放在VPC中进行进一步保护，使用SSL传输数据并对其余数据进行加密</li>
<li>由于它是托管服务，因此不提供对数据库实例的shell（root ssh）访问，这限制了对需要高级权限的某些系统过程和表的访问</li>
</ul>
</li>
</ul>
<h2 id="RDS-Components"><a href="#RDS-Components" class="headerlink" title="RDS Components"></a>RDS Components</h2><h3 id="DB-Instance"><a href="#DB-Instance" class="headerlink" title="DB Instance"></a>DB Instance</h3><ul>
<li>数据库实例的基本构建块</li>
<li>数据库实例是在云中运行的独立数据库环境</li>
<li>每个数据库实例均运行一个数据库引擎。Amazon RDS 当前支持 MySQL、MariaDB、PostgreSQL、Oracle 和 Microsoft SQL Server 数据库引擎</li>
<li>AWS Command Line Interface、Amazon RDS、API 或 AWS 管理控制台 创建和修改数据库实例</li>
<li>数据库实例的计算和内存容量由数据库实例类决定。选择最能满足需求的数据库实例。</li>
<li>数据库实例存储有三种类型：磁性、通用型 (SSD) 和配置的 IOPS (PIOPS)</li>
<li><font color="red">对于每个数据库实例，可以选择5 GB到6 TB的关联存储容量（会时常更新，目前最大容量可达64TB）</font></li>
<li>每个数据库实例都有一个数据库实例标识符，该标识符是客户提供的名称，对于AWS区域中的该客户必须是唯一的。它在与Amazon RDS API和AWS CLI命令交互时唯一标识数据库实例</li>
<li>每个数据库实例可以托管多个数据库，也可以托管具有多个模式的单个Oracle数据库。</li>
<li>建议托管在AWS VPC环境中以获得更好的控制</li>
</ul>
<h3 id="区域和可用区"><a href="#区域和可用区" class="headerlink" title="区域和可用区"></a>区域和可用区</h3><ul>
<li>Amazon 云计算资源安置在世界不同地区 (例如：北美、欧洲或亚洲) 的高度可用的数据中心设施内。每个数据中心位置称为一个地区</li>
<li>每个地区包含很多称为可用区或 AZ 的不同位置。每个可用区都被设计成不受其他可用区故障的影响，并提供低价、低延迟的网络连接，以连接到同一地区其他可用区。</li>
<li>可以在多个可用区运行数据库实例，此选项称为多可用区部署。<ul>
<li>Amazon 会自动在不同的可用区预配置和维护辅助备用数据库实例</li>
<li>主数据库实例可以跨可用区同步复制到辅助实例，从而在系统备份期间提供数据冗余、故障转移支持、消除 I/O 冻结和最大程度地降低延迟峰值</li>
</ul>
</li>
<li>安全组<ul>
<li>安全组通过允许访问指定的IP地址范围或EC2实例来控制对数据库实例的访问</li>
</ul>
</li>
<li>DB 参数组<ul>
<li>包含可应用于同一实例类型的一个或多个数据库实例的引擎配置值</li>
</ul>
</li>
<li>DB选项组<ul>
<li>一些数据库引擎提供的工具可以简化数据库管理并为数据库提供更多安全保护。</li>
<li>亚马逊RDS通过选项组提供此类工具，例如 Oracle Application Express（APEX），SQL Server透明数据加密和MySQL memcached支持</li>
</ul>
</li>
<li>RDS  接口<ul>
<li>AWS RDS 控制台</li>
<li>CLI</li>
<li>SDK、RDS API</li>
</ul>
</li>
</ul>
<h1 id="RDS-Replication-–-Multi-AZ-amp-Read-Replica"><a href="#RDS-Replication-–-Multi-AZ-amp-Read-Replica" class="headerlink" title="RDS Replication – Multi-AZ &amp; Read Replica"></a>RDS Replication – Multi-AZ &amp; Read Replica</h1><ul>
<li>数据库实例副本可通过多可用区部署或只读副本方式创建</li>
<li>多可用区部署<ul>
<li>多可用区部署提供高可用性和故障转移支持</li>
<li>RDS自动在不同的AZ（物理上独立的位置中的独立基础架构）中配置和管理同步备用副本</li>
<li>RDS会自动故障转移到备用数据库，以便数据库操作可以在没有干预的情况下快速恢复<ol>
<li>计划数据库维护</li>
<li>软件修补</li>
<li>重新启动主实例</li>
<li>主数据库实例连接或主机故障，或</li>
<li>可用区失败</li>
</ol>
</li>
</ul>
</li>
<li>只读副本<ul>
<li>Amazon RDS 还使用 MariaDB、MySQL、Oracle 和 PostgreSQL 数据库引擎的内置复制功能来从源数据库实例创建一个特殊类型的数据库实例，称为只读副本</li>
<li>对源数据库实例的更新将异步复制到只读副本。可以将应用程序发出的读取查询路由到只读副本，以减轻源数据库实例上的负载。</li>
<li>利用只读副本，可针对进行大量读取操作的数据库负载灵活地进行扩展，突破单个数据库实例的容量限制。</li>
</ul>
</li>
</ul>
<h2 id="Multi-AZ-deployment"><a href="#Multi-AZ-deployment" class="headerlink" title="Multi-AZ deployment"></a>Multi-AZ deployment</h2><ul>
<li>Amazon RDS 使用多可用区部署为数据库实例提供高可用性和故障转移支持。Amazon RDS 使用几种不同的技术来提供故障转移支持。用于 Oracle、PostgreSQL、MySQL 和 MariaDB 数据库实例的多可用区部署使用 Amazon 的故障转移技术。SQL Server 数据库实例使用 SQL Server 数据库镜像 (DBM)</li>
<li>高可用性功能不是面向只读情况的扩展解决方案；不能使用备用副本处理读取流量。要处理只读流量，应当使用只读副本</li>
<li>Multi-AZ 部署<ul>
<li>在多可用区部署中，Amazon RDS 会自动在不同可用区中配置和维护一个同步备用副本</li>
<li>主数据库实例将跨可用区同步复制到备用副本，以提供数据冗余、消除 I/O 冻结并在系统备份期间将延迟峰值降至最小</li>
<li>与单可用区部署相比，使用多可用区部署的数据库实例由于执行同步数据复制，因此会增加写入和提交延迟</li>
<li>仅当主数据库和备用数据库上的提交都成功时，才会返回事务成功</li>
<li>尽管 AWS 设计用于处理可用区之间的低延迟网络连接，但如果、部署故障转移到备用副本，延迟可能会发生更改</li>
</ul>
</li>
<li>使用BYOL许可模型时，需要主实例和备用副本的许可证</li>
<li>对于生产工作负载，建议使用具有预配置IOPS和数据库实例类（m1.large和更大）的多可用区部署，针对预配置IOPS进行了优化，以实现快速，一致的性能</li>
<li>将单可用区部署修改为多可用区部署时（对于SQL Server或Amazon Aurora以外的引擎）<ol>
<li>Amazon RDS拍摄主数据库实例的快照，然后将该快照还原到另一个可用区。</li>
<li>Amazon RDS 在主数据库实例与新实例之间设置同步复制</li>
<li>避免在从单可用区转换到多可用区时出现停机，但会在首次转换到多可用区时体验明显的性能影响。对于大型写入密集型数据库实例来说，此影响更明显</li>
</ol>
</li>
</ul>
<h2 id="RDS-Multi-AZ-Failover-Process"><a href="#RDS-Multi-AZ-Failover-Process" class="headerlink" title="RDS Multi-AZ Failover Process"></a>RDS Multi-AZ Failover Process</h2><ul>
<li>数据库实例发生计划内或计划外的中断时，对已启用多可用区，则 Amazon RDS 会自动切换到另一个可用区中的备用副本</li>
<li>完成故障转移所用的时间取决于在主数据库实例变为不可用时的数据库活动和其他条件。故障转移时间通常为 60-120 秒</li>
<li>故障转移机制自动更改数据库实例的 DNS 记录，使其指向备用数据库实例</li>
<li>多可用区切换与应用程序无缝连接，因为端点URL没有变化，只需要重新建立与数据库实例的任何现有连接</li>
<li>Amazon RDS 会自动处理故障转移，因此，可以尽快恢复数据库操作而无需管理干预。如果出现以下任一情况，主数据库实例会自动切换到备用副本：<ul>
<li>可用区中断</li>
<li>主数据库实例故障</li>
<li>更改数据库实例服务器类型</li>
<li>数据库实例的操作系统在进行软件修补</li>
<li>数据库实例的手动故障转移是使用 Reboot with failover 启动的</li>
</ul>
</li>
<li>可通过多种方法确定多可用区数据库实例是否进行了故障转移：<ul>
<li>数据库事件订阅可设置为在故障转移启动时向发送电子邮件或 SMS 通知。</li>
<li>使用 Amazon RDS 控制台或 API 操作查看数据库事件。</li>
<li>使用 Amazon RDS 控制台 API 操作查看多可用区部署的当前状态</li>
</ul>
</li>
</ul>
<h2 id="Read-Replica"><a href="#Read-Replica" class="headerlink" title="Read Replica"></a>Read Replica</h2><ul>
<li>Amazon RDS 还使用 MariaDB、MySQL、Oracle 和 PostgreSQL 数据库引擎的内置复制功能来从源数据库实例创建一个特殊类型的数据库实例，称为只读副本</li>
<li>对源数据库实例的更新将异步复制到只读副本</li>
<li>将应用程序发出的读取查询路由到只读副本，以减轻源数据库实例上的负载</li>
<li>利用只读副本，可针对进行大量读取操作的数据库负载灵活地进行扩展，突破单个数据库实例的容量限制</li>
<li>只读副本作为允许只读连接的数据库实例运行; 应用程序可以像对任何数据库实例一样连接到只读副本</li>
</ul>
<h3 id="Read-Replica-creation"><a href="#Read-Replica-creation" class="headerlink" title="Read  Replica creation"></a>Read  Replica creation</h3><ul>
<li>一个源数据库实例最多可以创建五个只读副本</li>
<li>创建只读副本过程<ol>
<li>先通过将备份保留期设置为一个非零值来在源数据库实例上启用自动备份</li>
<li>需要将现有数据库实例指定为源</li>
<li>RDS获取源实例的快照，并从快照创建只读实例</li>
<li>然后，RDS使用数据库引擎的异步复制方法更新只读副本以获取对源数据库实例的任何更改</li>
</ol>
</li>
<li>RDS复制源数据库实例中的所有数据实例</li>
<li>如果只读副本位于与数据库实例不同的AWS区域中，则RDS会在源数据库实例与只读副本之间建立安全通信通道</li>
<li>RDS建立启用安全通道所需的任何AWS安全配置，例如添加安全组</li>
<li>在只读副本创建期间，可以在发生数据库快照时体验源数据库实例上的简短I / O挂起</li>
<li>I / O暂停通常持续大约一分钟，如果源数据库实例是多可用区部署，则可以避免（在多可用区部署的情况下，数据库快照是从备用数据库获取的）</li>
<li>长时间运行的活动事务会减慢创建只读副本的过程。建议等待长时间运行的事务完成，然后再创建只读副本。</li>
<li>如果从同一源数据库实例同时创建多个并行只读副本，则 Amazon RDS 仅在开始第一个创建操作时创建一张快照</li>
<li>可以将只读副本提升为新的独立源数据库，在这种情况下，只读副本和源数据库之间的复制链接会断开。 但是，使用原始源DB作为复制源继续复制其他副本</li>
</ul>
<h3 id="Read-Replica-Deletion-amp-DB-Failover"><a href="#Read-Replica-Deletion-amp-DB-Failover" class="headerlink" title="Read Replica Deletion&amp; DB Failover"></a>Read Replica Deletion&amp; DB Failover</h3><ul>
<li>只读副本删除，必须采用与数据库实例一样的显式删除方法</li>
<li>若删除源数据库而不删除副本，则会将每个副本提升为可用区内独立的数据库实例</li>
<li>若multi-az部署的源实例故障转移到备用数据库，则会切换源实例的关联副本到备用数据库上（作为新的源）</li>
</ul>
<h3 id="Read-Replica-Storage-amp-Compute-requirements"><a href="#Read-Replica-Storage-amp-Compute-requirements" class="headerlink" title="Read Replica Storage &amp; Compute requirements"></a>Read Replica Storage &amp; Compute requirements</h3><ul>
<li>默认情况下，使用与源数据库实例相同的存储类型创建只读副本</li>
<li>为使复制有效运行，每个只读副本应具有与源数据库实例相同数量的计算和存储资源</li>
<li>源数据库实例，如果缩放，则应相应地缩放只读副本</li>
</ul>
<h3 id="Read-Replica-Features-amp-Limitations"><a href="#Read-Replica-Features-amp-Limitations" class="headerlink" title="Read Replica Features &amp; Limitations"></a>Read Replica Features &amp; Limitations</h3><ul>
<li>RDS不支持循坏复制</li>
<li>只能从现有数据库实例创建新的只读副本，例如，如果MyDBInstance复制到ReadReplica1，则无法将ReadReplica1配置为复制回MyDBInstance。 从ReadReplica1，只能创建一个新的只读副本，例如ReadRep2</li>
<li>跨区域复制<ul>
<li>只有在使用 MariaDB、PostgreSQL (版本 9.4.7 和 9.5.2 和更高版本) 或 MySQL 5.6 和更高版本的 Amazon RDS 数据库实例时，才能在区域之间进行复制</li>
<li>灾难恢复功能（减少RTO和RPO）</li>
<li>将操作扩展到更接近最终用户的区域，</li>
<li>从一个地区的数据中心迁移到另一个地区</li>
</ul>
</li>
<li>也可以从其他只读副本创建只读副本。 但是，这些实例的副本滞后更高，并且复制链中涉及的实例不能超过四个。</li>
</ul>
<h3 id="RDS-不同引擎的只读副本区别"><a href="#RDS-不同引擎的只读副本区别" class="headerlink" title="RDS 不同引擎的只读副本区别"></a>RDS 不同引擎的只读副本区别</h3><table>
<thead>
<tr>
<th>操作</th>
<th>MySQL 和 MariaDB</th>
<th>Oracle</th>
<th>PostgreSQL</th>
</tr>
</thead>
<tbody><tr>
<td>复制方法是什么？</td>
<td>逻辑复制。</td>
<td>物理复制。</td>
<td>物理复制。</td>
</tr>
<tr>
<td>如何清除事务日志？</td>
<td>Amazon RDS MySQL 和 MariaDB 保留尚未应用的任何二进制日志。</td>
<td>Amazon RDS for Oracle 在源数据库实例中保留至少两个小时的事务日志。两小时之后或在传递 archivelog retention hours 设置之后从源中清除日志，以时间较长者为准。传递 archivelog retention hours 设置之后，仅当它们已成功应用到数据库时，才会从只读副本清除日志。有关设置 archivelog retention hours 的信息，请参阅 保留存档重做日志。</td>
<td>PostgreSQL 具有参数 wal_keep_segments，该参数指示保留多少个提前写入日志 (WAL) 文件以便为只读副本提供数据。该参数值指定要保留的日志的数量。</td>
</tr>
<tr>
<td>是否能将副本设置为可写？</td>
<td>是。 可将 MySQL 或 MariaDB 只读副本设置为可写。</td>
<td>否。Oracle 只读副本是物理副本，Oracle 不允许写入只读副本。可以提升只读副本以将它设置为可写。提升的只读副本拥有提出提升请求时的已复制数据。</td>
<td>否。PostgreSQL 只读副本是一个物理副本，PostgreSQL 不允许将只读副本设置为可写。</td>
</tr>
<tr>
<td>是否能在副本上执行备份？</td>
<td>是。可以对 MySQL 或 MariaDB 只读副本启用自动备份。</td>
<td>否。不能创建 Amazon RDS for Oracle 只读副本的手动快照或为它们启用自动备份。</td>
<td>是，可以创建 PostgreSQL 只读副本的手动快照，但无法启用自动备份。</td>
</tr>
<tr>
<td>是否能使用并行复制？</td>
<td>是。MySQL 5.6 版和更高版本和所有支持的 MariaDB 版本允许并行复制线程。</td>
<td>是。重做日志数据始终会从源数据库并行传输到其所有只读副本。</td>
<td>否。PostgreSQL 是一个处理复制的过程。</td>
</tr>
</tbody></table>
<h3 id="Read-Replica-Use-cases"><a href="#Read-Replica-Use-cases" class="headerlink" title="Read Replica Use cases"></a>Read Replica Use cases</h3><ul>
<li>为读取繁重的数据库工作负载扩展超出单个数据库实例的计算或I / O容量，将过多的读取流量引导到只读副本</li>
<li>在源数据库实例不可用时提供读取流量，例如 如果源数据库实例由于备份I / O挂起或计划维护而无法接收I / O请求，则可以将读取流量定向到只读副本。（此时 数据可能是陈旧的）</li>
<li>业务报告或数据仓库方案，可以对只读副本而不是主要生产数据库实例执行业务报告查询</li>
</ul>
<h1 id="RDS-Storage"><a href="#RDS-Storage" class="headerlink" title="RDS Storage"></a>RDS Storage</h1><ul>
<li>RDS使用EBS存储数据库数据和日志</li>
<li>RDS会自动对多个EBS卷进行条带化，以提高IOPS性能，具体取决于所请求的存储量</li>
</ul>
<h2 id="RDS-Storage-Types"><a href="#RDS-Storage-Types" class="headerlink" title="RDS Storage Types"></a>RDS Storage Types</h2><ul>
<li>RDS 提供三个存储类型：通用型 SSD（也称为 gp2）、预配置 IOPS SSD（也称为 io1）和磁性存储</li>
<li>它们的性能特性和价格不同，这意味着可以根据数据库工作负载需求定制存储性能和成本</li>
<li>以创建最多具有 64 TiB 存储的 MySQL、MariaDB 和 PostgreSQL RDS 数据库实例。最多可以创建具有 64 TiB 存储的 Oracle RDS 数据库实例。可以创建最多具有 16 TiB 存储的 SQL Server RDS 数据库实例。对于此存储量，请使用预配置 IOPS SSD 和通用型 (SSD) 存储类型</li>
</ul>
<h2 id="Magnetic-Standard"><a href="#Magnetic-Standard" class="headerlink" title="Magnetic (Standard)"></a>Magnetic (Standard)</h2><ul>
<li>磁存储，也称为标准存储，提供经济高效的存储，目前AWS建议使用SSD或预配IOPS类型</li>
<li>不允许使用 SQL Server 数据库引擎时扩展存储</li>
<li>不支持弹性卷。</li>
<li>限制为 3 TiB 的最大大小</li>
<li>限制为最大 1,000 IOPS</li>
</ul>
<h2 id="General-Purpose-SSD"><a href="#General-Purpose-SSD" class="headerlink" title="General Purpose (SSD)"></a>General Purpose (SSD)</h2><ul>
<li>通用型 SSD（也称作 gp2）卷提供了适用于各种工作负载的经济高效的存储。这些卷可以提供几毫秒的延迟，能够突增至 3000 IOPS 并维持一段较长的时间</li>
<li>MariaDB、MySQL 和 PostgreSQL 数据库实例：20 GiB–64 TiB</li>
<li>SQL Server for Enterprise、Standard、Web 和 Express 版本：20 GiB–16 TiB</li>
<li>Oracle 实例：20 GiB- 64 TiB</li>
<li>非常适合中小型数据库</li>
</ul>
<h2 id="Provisioned-IOPS"><a href="#Provisioned-IOPS" class="headerlink" title="Provisioned IOPS"></a>Provisioned IOPS</h2><ul>
<li>预配置 IOPS 存储符合 I/O 密集型工作负载（尤其是数据库工作负载）的需求，此类工作负载需要低 I/O 延迟和一致的 I/O 吞吐量</li>
<li>提供了可预测的性能以及一致的低延迟</li>
<li>需要快速且一致的I / O性能的任何生产应用程序，Amazon建议使用预配置IOPS存储类型</li>
<li>预配置的 IOPS 存储针对性能要求一致的联机事务处理 (OLTP) 工作负载进行了优化</li>
<li>下表显示每个数据库引擎的预配置 IOPS 的范围和存储大小范围</li>
</ul>
<table>
<thead>
<tr>
<th>数据库引擎</th>
<th>预配置的 IOPS 的范围</th>
<th>存储的范围</th>
</tr>
</thead>
<tbody><tr>
<td>MariaDB</td>
<td>1000–80000 IOPS</td>
<td>100 GiB–64 TiB</td>
</tr>
<tr>
<td>SQL Server、Enterprise 和 Standard 版本</td>
<td>1000–64000 IOPS*</td>
<td>20 GiB–16 TiB</td>
</tr>
<tr>
<td>SQL Server，Web 和 Express 版本</td>
<td>1000–64000 IOPS*</td>
<td>100 GiB–16 TiB</td>
</tr>
<tr>
<td>MySQL</td>
<td>1000–80000 IOPS</td>
<td>100 GiB–64 TiB</td>
</tr>
<tr>
<td>Oracle</td>
<td>1000–80000 IOPS</td>
<td>100 GiB– 64 TiB</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>1000–80000 IOPS</td>
<td>100 GiB–64 TiB</td>
</tr>
</tbody></table>
<blockquote>
<p>** 最大 IOPS 64000 仅在基于 Nitro 的实例（m5 实例类型）上是可保证的。其他实例系列可确保最高 32000 IOPS 的性能 ** </p>
<ul>
<li>创建数据库实例时，指定专用IOPS速率和存储空间分配。 RDS规定IOPS速率和存储在数据库实例的生命周期内或直到其更改。</li>
</ul>
</blockquote>
<h2 id="Adding-Storage-and-Changing-Storage-Type"><a href="#Adding-Storage-and-Changing-Storage-Type" class="headerlink" title="Adding Storage and Changing Storage Type"></a>Adding Storage and Changing Storage Type</h2><ul>
<li>可以修改数据库实例以使用其他存储并转换为不同的存储类型。但是，不能减少分配的存储空间（增大可以，缩小不可以）</li>
<li>MySQL，MariaDB，PostgreSQL和Oracle数据库实例可以扩展存储，这有助于提高I / O容量</li>
<li>由于附加到Windows Server环境的条带存储的可扩展性限制，可以更改SQL Server数据库实例的存储容量和存储类型</li>
<li>扩展过程中，数据库实例可用于读取和写入，但可能会出现性能下降</li>
<li>添加存储可能需要几个小时;过程的持续时间取决于几个因素，例如负载，存储大小，存储类型，配置的IOPS数量（如果有）以及先前规模存储操作的数量</li>
<li>在添加存储时，会暂停每夜备份，并且不会执行任何其他RDS操作，包括修改，重新引导，删除，创建只读副本和创建数据库快照</li>
</ul>
<h2 id="Performance-Metrics"><a href="#Performance-Metrics" class="headerlink" title="Performance Metrics"></a>Performance Metrics</h2><p>Amazon RDS提供了多个指标，可用于监控数据库的性能<br><strong>IOPS</strong></p>
<ul>
<li>每秒完成的I / O操作数</li>
<li>它被报告为给定时间间隔的平均IOPS</li>
<li>RDS每隔一分钟报告一次读写IOPS</li>
<li>总IOPS是读写IOPS的总和</li>
<li>IOPS的典型值范围为每秒零到几万<br><strong>Latency</strong></li>
<li>提交I / O请求到完成之间经过的时间</li>
<li>它被报告为给定时间间隔的平均延迟。</li>
<li>RDS以一分钟为单位分别报告读取和写入延迟，单位为秒</li>
<li>延迟的典型值以毫秒（ms）为单位<br><strong>Throughput</strong></li>
<li>传输到磁盘或从磁盘传输的每秒字节数</li>
<li>它被报告为给定时间间隔的平均吞吐量</li>
<li>RDS使用每秒兆字节（MB / s）的单位分别以一分钟的间隔报告读写吞吐量</li>
<li>吞吐量的典型值范围从零到I / O通道的最大带宽<br><strong>Queue Depth</strong></li>
<li>队列中等待服务的I / O请求数。</li>
<li>这些是由应用程序提交但尚未发送到设备的I / O请求，因为设备正在忙于处理其他I / O请求。</li>
<li>它被报告为给定时间间隔的平均队列深度。</li>
<li>RDS以一分钟为间隔报告队列深度。队列深度的典型值范围从零到几百。</li>
<li>在队列中等待的时间是Latency和服务时间（不作为指标）</li>
</ul>
<h2 id="Amazon-RDS-Storage-Facts"><a href="#Amazon-RDS-Storage-Facts" class="headerlink" title="Amazon RDS Storage Facts"></a>Amazon RDS Storage Facts</h2><ul>
<li>第一次启动数据库实例并首次访问磁盘区域时，该进程可能比对同一磁盘区域的所有后续访问花费的时间更长。这被称为“first touch penalty”。一旦磁盘区域产生了“first touch penalty”，即使数据库实例重新启动，重新启动或数据库实例类发生更改，该磁盘区域也不会在实例的生命周期内再次受到惩罚。请注意，从快照，时间点恢复或只读副本创建的数据库实例是新实例，并且会导致此“first touch penalty</li>
<li>RDS管理DB实例，并在实例上保留开销空间。如果预留的存储量随DB实例类和其他因素而变化，那么这个预留空间可能是总存储的1%或2%</li>
<li>预配置IOPS提供了一种通过指定IOPS来保留I / O容量的方法。与任何其他系统容量属性一样，负载下的最大吞吐量将受到首先消耗的资源的约束，这可能是IOPS，通道带宽，CPU，内存或数据库内部资源。</li>
<li>当前可用的最大信道带宽是4000兆比特每秒（Mbps）全双工。就读取和写入吞吐量度量而言，这相当于每个方向上大约210兆字节/秒（MB / s）。 50％读取和50％写入的完美平衡工作负载可以达到420 MB / s的最大组合吞吐量，其中包括协议开销，因此实际数据吞吐量可能更低。</li>
<li>预配置IOPS的I / O请求大小为32 KB。预配置IOPS消耗是I / O请求大小超过32 KB的线性函数。小于32 KB的I / O请求作为一个I / O处理;例如1000 16 KB I / O请求的处理方式与1000 32 KB请求相同。大于32 KB的I / O请求会消耗多个I / O请求;而48 KB I / O请求消耗1.5个I / O存储容量请求; 64 KB I / O请求消耗2个I / O请求</li>
</ul>
<h2 id="Factors-That-Impact-Storage-Performance"><a href="#Factors-That-Impact-Storage-Performance" class="headerlink" title="Factors That Impact Storage Performance"></a>Factors That Impact Storage Performance</h2><ul>
<li>系统活动和数据库工作负载均可能影响存储性能</li>
<li>系统活动，以下系统相关活动圴使用 I/O 容量，并且可能会在执行这些活动时降低数据库实例性能：<ul>
<li>多可用区备用创建</li>
<li>创建只读副本</li>
<li>创建存储类型</li>
</ul>
</li>
<li>数据库工作负载，数据库或应用程序设计导致并发问题、锁定或其他形式的数据库争用。在这类情况下，可能无法直接使用所有预配置的带宽<ul>
<li>已到达基础实例类型的吞吐量限制。</li>
<li>因为应用程序没有驱动足够的 I/O 操作，所以少于队列深度始终小于 1</li>
<li>在数据库中遇到查询争用，即使部分 I/O 容量未使用也是如此</li>
</ul>
</li>
</ul>
<h1 id="RDS-Snapshots-Backup-amp-Restore"><a href="#RDS-Snapshots-Backup-amp-Restore" class="headerlink" title="RDS Snapshots, Backup &amp; Restore"></a>RDS Snapshots, Backup &amp; Restore</h1><ul>
<li>RDS创建数据库实例的存储卷快照，备份整个数据库实例，而不仅仅是单个数据库。</li>
<li>RDS提供了两种不同的自动和手动方法来备份数据库实例：</li>
</ul>
<h2 id="Automated-backups"><a href="#Automated-backups" class="headerlink" title="Automated backups"></a>Automated backups</h2><ul>
<li>将自动创建并保留数据库实例的备份</li>
<li>默认情况下，为新数据库实例启用自动备份</li>
<li>自动备份在每日用户可配置的时间段内发生，称为首选备份窗口<ul>
<li>如果在创建数据库实例时未指定首选备份窗口，则RDS会分配默认的30分钟备份窗口，该窗口是从每个区域的8小时时间块中随机选择的</li>
<li>对备份窗口的更改会立即生效</li>
<li>备份窗口不能与数据库实例的每周维护窗口重叠</li>
</ul>
</li>
<li>创建数据库实例时设置备份保留期。如果未设置备份保留期，则在使用 Amazon RDS API 或 AWS CLI 创建数据库实例时，默认备份保留期为一天。如果使用控制台创建数据库实例，默认备份保留期为七天。创建数据库实例后，可以修改备份保留期。可以将备份保留期设置为在 0 到 35 天之间。要禁用自动备份，请将备份保留期设置为 0</li>
<li>手动快照限制 (每个区域 100 个) 不适用于自动备份</li>
<li>如果更改备份保留期，则会立即发生中断</li>
<li>RDS将周期性数据备份与事务日志结合使用，以便在保留期内将数据库实例恢复到任何秒，直到LatestRestorableTime（通常直到最后几分钟）。</li>
<li>在备份窗口期间，<ul>
<li>对于单个AZ实例，可能会在备份过程初始化（通常在几秒钟内）时暂时暂停存储I / O，并且可能会遇到短暂的高延迟时间。</li>
<li>对于多可用区数据库部署，由于备份是从备用实例获取的，因此没有I / O暂停</li>
</ul>
</li>
<li>自动数据库快照删除<ul>
<li>保留期限到期</li>
<li>数据库实例的自动数据库快照已禁用</li>
<li>数据库实例已删除</li>
</ul>
</li>
<li>删除数据库实例时<ul>
<li>删除后可以创建最终的数据库快照; 可用于在以后恢复已删除的数据库实例</li>
<li>RDS保留最终用户创建的数据库快照以及所有其他手动创建的数据库快照</li>
</ul>
</li>
<li>所有自动备份都将被删除，无法恢复</li>
</ul>
<h2 id="Point-In-Time-Recovery"><a href="#Point-In-Time-Recovery" class="headerlink" title="Point-In-Time Recovery"></a>Point-In-Time Recovery</h2><ul>
<li>除了每日自动备份之外，RDS还存档数据库更改日志。 这样可以将数据库恢复到备份保留期间的任何时间点，直到数据库使用的最后五分钟。</li>
<li>禁用自动备份还会禁用时间点恢复</li>
<li>RDS存储数据的多个副本，但对于单可用区数据库实例，这些副本存储在单个可用区中</li>
<li>如果出于任何原因，单可用区数据库实例变得不可用，则可以使用时间点恢复来启动具有最新可恢复数据的新数据库实例</li>
</ul>
<h2 id="用户自定义数据库快照"><a href="#用户自定义数据库快照" class="headerlink" title="用户自定义数据库快照"></a>用户自定义数据库快照</h2><ul>
<li>手动数据库快照是用户启动的备份，可以将数据库实例备份到已知状态，并可以随时还原到该特定状态。</li>
<li>RDS会保留所有手动数据库快照，直到明确删除</li>
</ul>
<h2 id="创建数据库快照"><a href="#创建数据库快照" class="headerlink" title="创建数据库快照"></a>创建数据库快照</h2><ul>
<li>建数据库实例的存储卷快照，并备份整个数据库实例而不仅仅是单个数据库</li>
<li>数据库快照可以根据需要在已知状态下备份数据库实例，然后可以随时将其还原到该特定状态</li>
<li>保留数据库快照，直到明确删除</li>
<li>在单可用区数据库实例上创建数据库快照会导致短暂的I / O挂起，通常持续时间不会超过几分钟</li>
<li>由于备份是在备用实例上进行的，因此多可用区数据库实例不受此I / O挂起的影响</li>
</ul>
<h2 id="快照还原"><a href="#快照还原" class="headerlink" title="快照还原"></a>快照还原</h2><ul>
<li>数据库实例可以在此保留期内恢复到任何特定时间，从而创建新的数据库实例</li>
<li>从数据库快照还原来创建具有不同endpoint的新数据库实例</li>
<li>RDS将周期性数据备份与事务日志结合使用，以便在保留期内将数据库实例恢复到任何秒，直到LatestRestorableTime（通常直到最后几分钟）</li>
<li>在还原数据库实例时，默认安全组与还原的实例相关联。还原完成之后新数据库实例即变为可用状态，这时必须关联还原的源实例所用的所有自定义安全组</li>
<li>建议保留所创建的数据库快照的参数组，这样还原的数据库实例就可以与正确的参数组关联。可以在还原数据库实例时指定参数组</li>
<li>可以使用与源数据库快照不同的存储类型还原数据库实例。在这种情况下，由于将数据迁移到新存储类型所需的额外工作，恢复过程将变慢。从GP2到预配置IOPS</li>
<li>有当数据库快照具有为新版本分配的所需存储时，才能使用不同版本的数据库引擎还原数据库实例，例如，从SQL Server Web Edition更改为SQL Server标准版，数据库快照必须已经过从具有至少200 GB分配存储的SQL Server数据库实例创建，该实例是SQL Server标准版的最小分配存储</li>
</ul>
<h2 id="DB-Snapshot-Copy"><a href="#DB-Snapshot-Copy" class="headerlink" title="DB Snapshot Copy"></a>DB Snapshot Copy</h2><ul>
<li>可以复制自动或手动数据库快照</li>
<li>复制自动数据库快照以在同一AWS区域中创建手动数据库快照。手动数据库快照不会自动删除，可以无限期保留。</li>
<li>将自动或手动数据库快照从一个区域复制到另一个区域。通过将数据库快照复制到另一个区域，将创建一个保留在该区域中的手动数据库快照</li>
<li>手动数据库快照可以与其他AWS账户共享，并复制其他AWS账户共享数据库快照</li>
<li>快照加密<ul>
<li>可以复制已使用 AWS KMS 加密密钥加密的快照</li>
<li>复制加密的快照，则此快照的副本也必须加密。如果在相同 AWS 区域内复制加密的快照，可使用原始快照的 KMS 加密密钥来加密此副本，也可指定不同的 KMS 加密密钥。如果跨区域复制加密的快照，由于 KMS 密钥是区域特定的，所以不能使用与源快照相同的 KMS 加密密钥</li>
</ul>
</li>
</ul>
<h2 id="快照共享"><a href="#快照共享" class="headerlink" title="快照共享"></a>快照共享</h2><ul>
<li>手动数据库快照或数据库集群快照可与最多20个其他AWS账户共享</li>
<li>与其他AWS账户共享的手动快照可以复制快照，或从该快照还原数据库实例或数据库集群</li>
<li>手动快照也可以作为公共共享，这使快照可供所有AWS账户使用。将快照共享为公共时应小心，以便不包含任何私人信息</li>
<li>共享快照可以复制到另一个区域</li>
<li>与其他 AWS 账户共享手动快照时存在以下限制：<ul>
<li>当使用 AWS Command Line Interface (AWS CLI) 或 Amazon RDS API 从共享的快照还原数据库实例时，必须指定共享快照的 Amazon 资源名称 (ARN) 作为快照标识符</li>
<li>无法共享使用了包含永久或持续性选项的选项组的数据库快照</li>
<li>不能从选项组中移除永久选项。若为数据库实例指定了包含持续性选项的选项组，则不能从数据库实例中删除这些选项组</li>
</ul>
</li>
<li>可共享使用 AES-256 加密算法“静态”加密的数据库快照</li>
<li>用户可以访问用于加密数据库快照的AWS Key Management Service（AWS KMS）加密密钥，则用户只能复制加密的数据库快照</li>
<li>通过将其他帐户添加到KMS密钥策略，可以与其他AWS账户共享AWS KMS加密密钥</li>
<li>但是，在共享加密的数据库快照之前，必须首先通过添加任何帐户来共享KMS密钥策略以共享快照</li>
</ul>
<p>#RDS Security</p>
<ul>
<li>在基于 Amazon VPC 服务的 Virtual Private Cloud (VPC) 中运行数据库实例以获得可能最大的网络访问控制</li>
<li>使用 AWS Identity and Access Management (IAM) 策略分配决定谁可以管理 Amazon RDS 资源的权限</li>
<li>使用安全组可以控制可连接到数据库实例上的数据库的 IP 地址或 Amazon EC2 实例</li>
<li>使用数据库实例的安全套接字层 (SSL) 连接</li>
<li>使用 Amazon RDS 加密保护静态数据库实例和快照</li>
<li>对 Oracle 数据库实例使用网络加密和透明数据加密</li>
<li>使用数据库引擎的安全功能控制可以登录数据库实例上的数据库的人员</li>
</ul>
<h2 id="RDS-Authentication-and-Access-Control"><a href="#RDS-Authentication-and-Access-Control" class="headerlink" title="RDS Authentication and Access Control"></a>RDS Authentication and Access Control</h2><ul>
<li>IAM可用于控制每个用户有权调用的RDS操作</li>
</ul>
<h2 id="Encrypting-RDS-Resources"><a href="#Encrypting-RDS-Resources" class="headerlink" title="Encrypting RDS Resources"></a>Encrypting RDS Resources</h2><ul>
<li>使用行业标准AES-256加密算法来加密承载RDS实例的服务器上的数据</li>
<li>在加密数据后，Amazon RDS 将以透明方式处理访问的身份验证和数据的解密，并且对性能产生的影响最小。无需修改数据库客户端应用程序来使用加密</li>
<li>静态数据加密<ul>
<li>可以在RDS实例上启用以加密底层存储</li>
<li>加密密钥由KMS管理</li>
<li>只能在实例创建期间启用</li>
<li>启用后，无法更改加密密钥</li>
<li>如果密钥丢失，则只能从备份中恢复数据库</li>
</ul>
</li>
<li>为RDS实例启用加密后，<ul>
<li>日志已加密</li>
<li>快照已加密</li>
<li>自动备份已加密</li>
<li>只读副本是加密的</li>
</ul>
</li>
<li>跨区域副本和快照副本不起作用，因为密钥仅在单个区域中可用</li>
<li>快照注意事项<ul>
<li>可以复制使用KMS加密密钥加密的数据库快照</li>
<li>复制加密的数据库快照会生成数据库快照的加密副本</li>
<li>复制时，可以使用与原始数据库快照相同的KMS加密密钥加密数据库快照，也可以使用其他KMS加密密钥加密数据库快照的副本。</li>
<li>可以将未加密的数据库快照复制到加密快照，这是一种向以前未加密的数据库实例添加加密的快速方法。</li>
<li>加密快照只能还原到加密的数据库实例</li>
<li>如果从未加密的数据库集群快照还原时指定了KMS加密密钥，则使用指定的KMS加密密钥对还原的数据库集群进行加密</li>
<li>复制从另一个AWS账户共享的加密快照需要访问用于加密数据库快照的KMS加密密钥。</li>
<li>由于KMS加密密钥特定于创建它们的区域，因此无法将加密快照复制到其他区域</li>
</ul>
</li>
<li>透明数据加密<ul>
<li>在将数据写入底层存储设备之前自动加密数据，并在从存储设备读取数据时进行解密</li>
<li>Oracle和SQL Server支持</li>
<li>Oracle需要KMS外部的密钥存储，并与CloudHSM集成</li>
<li>SQL Server需要密钥，但由RDS管理</li>
</ul>
</li>
</ul>
<h2 id="使用-SSL-加密与数据库实例的连接"><a href="#使用-SSL-加密与数据库实例的连接" class="headerlink" title="使用 SSL 加密与数据库实例的连接"></a>使用 SSL 加密与数据库实例的连接</h2><ul>
<li>使用SSL加密连接，以便在应用程序和数据库实例之间传输数据</li>
<li>当RDS配置实例时，Amazon RDS会创建SSL证书并在数据库实例上安装证书</li>
<li>SSL证书由证书颁发机构签名。 SSL证书包括数据库实例端点作为SSL证书的公用名（CN）以防止欺骗攻击</li>
<li>虽然SSL提供了安全性优势，但请注意，SSL加密是一项计算密集型操作，会增加数据库连接的延迟。</li>
</ul>
<h2 id="RDS-安全组"><a href="#RDS-安全组" class="headerlink" title="RDS 安全组"></a>RDS 安全组</h2><ul>
<li>安全组控制流量进出数据库实例的访问权限</li>
<li>VPC安全组的作用类似于控制对数据库实例的网络访问的防火墙</li>
<li>可以配置VPC安全组并将其与数据库实例关联，以允许从IP地址范围，端口或EC2安全组进行访问</li>
<li>数据库安全组默认为“拒绝所有”访问模式，客户必须专门授权网络入口</li>
</ul>
<h2 id="主账户权限"><a href="#主账户权限" class="headerlink" title="主账户权限"></a>主账户权限</h2><ul>
<li>创建新数据库实例时，使用的默认主用户将获得该数据库实例的特定权限</li>
<li>随后，可以创建具有权限的其他用户</li>
</ul>
<h2 id="事件通知"><a href="#事件通知" class="headerlink" title="事件通知"></a>事件通知</h2><ul>
<li>可以为数据库实例上发生的重要事件配置事件通知</li>
<li>RDS实例上可能发生的各种重要事件的通知，例如实例是否已关闭，备份是否已启动，是否发生故障转移，安全组是否已更改，或者存储空间是否低</li>
</ul>
<h1 id="RDS-Maintenance-amp-Upgrades"><a href="#RDS-Maintenance-amp-Upgrades" class="headerlink" title="RDS Maintenance &amp; Upgrades"></a>RDS Maintenance &amp; Upgrades</h1><p>当手动修改数据库实例时，可能会发生对数据库实例的更改。 数据库引擎版本已升级，或者当Amazon RDS对实例执行维护时</p>
<h2 id="RDS-维护"><a href="#RDS-维护" class="headerlink" title="RDS 维护"></a>RDS 维护</h2><ul>
<li>RDS会定期对Amazon RDS资源（例如数据库实例）执行维护，并且通常涉及对数据库实例的操作系统（OS）的更新</li>
<li>维护项目也可以<ul>
<li>在方便时手动应用于数据库实例</li>
<li>或者等待Amazon RDS在定义的每周维护窗口期间启动的自动维护过程。</li>
</ul>
</li>
<li>维护窗口仅确定挂起操作何时开始，但不限制这些操作的总执行时间。 维护操作无法保证在维护窗口结束之前完成，并且可以继续超过指定的结束时间</li>
<li>可以在RDS控制台上和使用RDS API检查维护更新可用性。 如果有更新，可以<ul>
<li>推迟维护项目</li>
<li>立即应用维护项目</li>
<li>安排它们在下一个定义的维护窗口期间启动</li>
</ul>
</li>
<li>维护项目标记为<ul>
<li>如果延期AWS将在下次执行更新时发送通知，则无法无限期延期</li>
<li>可用且可以无限期延迟，更新不会应用于数据库实例</li>
</ul>
</li>
<li>必需的补丁自动只适用于相关的安全性和可靠性，例如补丁计划。 这种修补很少发生（通常每隔几个月一次），很少需要维护窗口的一小部分。</li>
<li>维护项目要求RDS的数据库实例在短时间内脱机。 需要数据库实例脱机的维护包括扩展计算操作，从开始到结束通常只需几分钟，并且需要操作系统或数据库修补。</li>
<li>数据库实例的多可用区部署通过以下步骤减少了维护事件的影响：<ul>
<li>在备用数据库上执行维护。</li>
<li>将备用数据库提升为主数据库。</li>
<li>对旧主服务器执行维护，这将成为新的主服务器。</li>
</ul>
</li>
<li>在多可用区部署中修改数据库实例的数据库引擎时，RDS会同时升级主数据库实例和辅助数据库实例。 在这种情况下，升级期间将关闭整个多可用区部署的数据库引擎</li>
</ul>
<h2 id="OS-升级"><a href="#OS-升级" class="headerlink" title="OS 升级"></a>OS 升级</h2><ul>
<li>升级到操作系统通常是出于安全问题，应该尽快完成。</li>
<li>数据库实例上的操作系统更新可以方便的时候应用，也可以等待RDS启动的维护过程在定义的维护时段应用更新</li>
<li>应用操作系统更新时，不会自动备份数据库实例，应在应用更新之前进行备份</li>
</ul>
<h2 id="DB-引擎升级"><a href="#DB-引擎升级" class="headerlink" title="DB 引擎升级"></a>DB 引擎升级</h2><ul>
<li>当RDS支持新的数据库引擎版本时，可以升级数据库实例引擎版本</li>
<li>数据库版本升级包括主要版本和次要版本升级</li>
</ul>
<h3 id="主要数据库版本升级"><a href="#主要数据库版本升级" class="headerlink" title="主要数据库版本升级"></a>主要数据库版本升级</h3><ul>
<li>可以包含不向后兼容的更改</li>
<li>RDS不会自动应用主要版本升级</li>
<li>在将数据库实例应用于生产实例之前，应手动修改并彻底测试数据库实例</li>
</ul>
<h3 id="次要版本升级"><a href="#次要版本升级" class="headerlink" title="次要版本升级"></a>次要版本升级</h3><ul>
<li>每个数据库引擎处理次要版本升级略有不同</li>
<li>例如 RDS会自动将次要版本升级应用于运行PostgreSQL的数据库实例，但必须手动应用于运行Oracle的数据库实例</li>
<li>AWS向论坛公告页面发布公告，并在升级数据库实例之前发送客户电子邮件通知</li>
<li>AWS计划在一年中的特定时间进行升级，以帮助计划周围的升级，因为升级数据库引擎版本需要停机时间，即使对于多可用区实例也是如此</li>
<li>RDS在升级过程中需要两个数据库快照。</li>
<li>在进行任何升级更改之前，第一个数据库快照属于数据库实例。 如果升级失败，可以从快照还原以创建运行旧版本的数据库实例。</li>
<li>升级完成后将执行第二个数据库快照。 升级完成后，无法将数据库引擎恢复为以前的版本。 要返回到先前版本，请还原用于创建新数据库实例的第一个数据库快照</li>
<li>如果数据库实例正在使用读取复制，则必须先升级所有只读副本，然后再升级源实例</li>
<li>如果数据库实例处于多可用区部署中，则主要副本和备用副本将同时升级并导致中断。 中断的时间因数据库引擎，版本和数据库实例的大小而异</li>
</ul>
<h2 id="RDS-维护窗口"><a href="#RDS-维护窗口" class="headerlink" title="RDS 维护窗口"></a>RDS 维护窗口</h2><ul>
<li>每个数据库实例都定义了一个每周维护窗口，在此期间应用任何系统更改</li>
<li>在请求或要求的情况下，维护窗口是控制何时发生数据库实例修改和软件修补的机会。</li>
<li>如果为某一周安排了维护事件，则将在定义的30分钟维护时段内启动该事件</li>
<li>维护事件大多在30分钟维护窗口期间完成，但较大的维护事件可能需要更多时间</li>
<li>从每个区域的8小时时间块中随机选择30分钟的维护窗口。如果在创建数据库实例时未指定首选维护时段，则Amazon RDS会在一周中随机选择的某一天分配30分钟的维护时段</li>
<li>在应用维护时，RDS将消耗数据库实例上的一些资源，从而最大限度地降低性能</li>
<li>对于某些维护事件，可能需要多可用区故障转移才能完成维护更新</li>
</ul>
<h1 id="RDS-Monitoring-amp-Notification"><a href="#RDS-Monitoring-amp-Notification" class="headerlink" title="RDS Monitoring &amp; Notification"></a>RDS Monitoring &amp; Notification</h1><ul>
<li>RDS与CloudWatch集成，并提供监控指标</li>
<li>可以在警报更改状态时发送SNS消息的单个度量标准上创建CloudWatch警报</li>
<li>每当发生任何RDS事件时，RDS也会提供SNS通知</li>
</ul>
<h2 id="CloudWatch-RDS-Monitoring"><a href="#CloudWatch-RDS-Monitoring" class="headerlink" title="CloudWatch RDS Monitoring"></a>CloudWatch RDS Monitoring</h2><ul>
<li>可以使用CloudWatch监视RDS数据库实例，CloudWatch可以将RDS中的原始数据收集并处理为可读的近实时指标。</li>
<li>统计信息记录为期两周，以便可以访问历史信息并更好地了解服务的执行情况。</li>
<li>默认情况下，RDS指标数据会在1分钟内自动发送到Amazon CloudWatch</li>
<li>CloudWatch RDS指标</li>
</ul>
<table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BinLogDiskUsage</td>
<td>主节点上的二进制日志所占的磁盘空间大小。适用于 MySQL 只读副本。单位：字节</td>
</tr>
<tr>
<td>BurstBalance</td>
<td>可用的通用型 SSD (GP2) 突增存储桶 I/O 点数的百分比。单位：百分比</td>
</tr>
<tr>
<td>CPUUtilization</td>
<td>CPU 使用百分率。单位：百分比</td>
</tr>
<tr>
<td>CPUCreditUsage</td>
<td>[T2 实例] 实例为保持 CPU 使用率而花费的 CPU 积分数。单位：积分 (vCPU 分钟)</td>
</tr>
<tr>
<td>CPUCreditBalance</td>
<td>[T2 实例] 实例自启动后已累积获得的 CPU 积分数。单位：积分 (vCPU 分钟)</td>
</tr>
<tr>
<td>DatabaseConnections</td>
<td>使用中的数据库连接数。单位：计数</td>
</tr>
<tr>
<td>DiskQueueDepth</td>
<td>等待访问磁盘的未完成 IO（读取/写入请求）的数量。单位：计数</td>
</tr>
<tr>
<td>FailedSQLServerAgentJobsCount</td>
<td>过去 1 分钟内失败的 SQL Server 代理作业的数量。单位：计数/分钟</td>
</tr>
<tr>
<td>FreeableMemory</td>
<td>随机存取内存的可用大小。单位：字节</td>
</tr>
<tr>
<td>FreeStorageSpace</td>
<td>可用存储空间的大小。单位：字节</td>
</tr>
<tr>
<td>MaximumUsedTransactionIDs</td>
<td>已使用的最大事务 ID。适用于 PostgreSQL。单位：计数</td>
</tr>
<tr>
<td>NetworkReceiveThroughput</td>
<td>数据库实例的传入（接收）网络流量，包括用于监控和复制的客户数据库流量和 Amazon RDS 流量。单位：字节/秒</td>
</tr>
<tr>
<td>NetworkTransmitThroughput</td>
<td>数据库实例的传出（传输）网络流量，包括用于监控和复制的客户数据库流量和 Amazon RDS 流量。单位：字节/秒</td>
</tr>
<tr>
<td>OldestReplicationSlotLag</td>
<td>在接收 WAL 数据方面最滞后的副本的滞后大小。适用于 PostgreSQL。单位：MB</td>
</tr>
<tr>
<td>ReadIOPS</td>
<td>每秒平均磁盘读取 I/O 操作数。单位：计数/秒</td>
</tr>
<tr>
<td>ReadLatency</td>
<td>每个磁盘 I/O 操作所需的平均时间。单位：秒</td>
</tr>
<tr>
<td>ReadThroughput</td>
<td>每秒从磁盘读取的平均字节数。单位：字节/秒</td>
</tr>
<tr>
<td>ReplicaLag</td>
<td>只读副本数据库实例滞后于源数据库实例的时间量。适用于 MySQL、MariaDB 和 PostgreSQL 只读副本。单位：秒</td>
</tr>
<tr>
<td>ReplicationSlotDiskUsage</td>
<td>复制插槽文件使用的磁盘空间。适用于 PostgreSQL。单位：MB</td>
</tr>
<tr>
<td>SwapUsage</td>
<td>数据库实例上使用的交换空间的大小。此指标对于 SQL Server 不可用。单位：字节</td>
</tr>
<tr>
<td>TransactionLogsDiskUsage</td>
<td>事务日志使用的磁盘空间。适用于 PostgreSQL。单位：MB</td>
</tr>
<tr>
<td>TransactionLogsGeneration</td>
<td>每秒生成的事务日志的大小。适用于 PostgreSQL。单位：字节/秒</td>
</tr>
<tr>
<td>WriteIOPS</td>
<td>每秒平均磁盘写入 I/O 操作数。单位：计数/秒</td>
</tr>
<tr>
<td>WriteLatency</td>
<td>每个磁盘 I/O 操作所需的平均时间。单位：秒</td>
</tr>
<tr>
<td>WriteThroughput</td>
<td>每秒写入磁盘的平均字节数。单位：字节/秒</td>
</tr>
</tbody></table>
<h2 id="RDS-Event-Notification"><a href="#RDS-Event-Notification" class="headerlink" title="RDS Event Notification"></a>RDS Event Notification</h2><ul>
<li>RDS使用SNS在发生RDS事件时提供通知</li>
<li>RDS将事件分组，可以订阅这些类别，以便在发生该类别中的事件时发送通知。</li>
<li>可以订阅数据库实例，数据库集群，数据库快照，数据库集群快照，数据库安全组或数据库参数组的事件类别</li>
<li>事件通知将发送到订阅创建期间提供的电子邮件地址</li>
<li>通过在RDS控制台中将Enabled单选按钮设置为No或使用CLI或RDS API将Enabled参数设置为false，可以轻松关闭订阅而不删除订阅</li>
</ul>
<h1 id="RDS-最佳实践"><a href="#RDS-最佳实践" class="headerlink" title="RDS 最佳实践"></a>RDS 最佳实践</h1><h2 id="Amazon-RDS-基本操作指导"><a href="#Amazon-RDS-基本操作指导" class="headerlink" title="Amazon RDS 基本操作指导"></a>Amazon RDS 基本操作指导</h2><ul>
<li>Monitoring<ul>
<li>监控内存、CPU 和存储空间使用情况。可以将 Amazon CloudWatch 设置为在使用模式发生变化或接近部署容量时向发送通知，以保持系统性能和可用性</li>
</ul>
</li>
<li>Scaling <ul>
<li>当接近存储容量限制时，可以向上扩展数据库实例</li>
<li>存储和内存中应含有一些缓冲区，以适应应用程序的意外增大需求</li>
</ul>
</li>
<li>Backup<ul>
<li>启用自动备份并设置备份时段，以在每天写入 IOPS 较低的时段进行</li>
</ul>
</li>
<li>在MySQL数据库实例上，<ul>
<li>不要创建使用自动配置的IOPS或1000个表使用标准存储超过10000个表。故障转移或数据库崩溃后，大量表将显着增加数据库恢复时间。 如果需要创建多于建议的表，请将innodb_file_per_table参数设置为0。</li>
<li>避免数据库中的表变得过大。 预配置存储限制将MySQL表文件的最大大小限制为6 TB。 而是对大表进行分区，以使文件大小远低于6 TB的限制。 这还可以提高性能和恢复时间。</li>
</ul>
</li>
<li>Performance</li>
<li>数据库工作负载需要的 I/O 超过配置，那么出现故障转移或数据库故障后，恢复的速度将会变缓<ul>
<li>迁移到具有高 I/O 容量的数据库实例类</li>
<li>从标准存储转换为通用存储或配置的 IOPS 存储，具体取决于需要增加的量</li>
<li>已在使用配置的 IOPS 存储，请额外配置吞吐量容量</li>
</ul>
</li>
<li>多可用区和故障转移<ul>
<li>在所有可用区中部署应用程序，如果AZ发生故障，其他AZ中的应用程序仍可用</li>
<li>使用Amazon RDS数据库事件来监控故障转移</li>
<li>如果客户端应用程序正在缓存数据库实例的DNS数据，则设置小于30秒的TTL。 由于数据库实例的基础IP地址可能在故障转移后发生更改，因此如果应用程序尝试连接到不再使用的IP地址，则将DNS数据缓存较长时间可能会导致连接失败</li>
<li>多可用区要求启用事务日志记录功能。 不要使用简单恢复模式，脱机模式或只读模式等功能来转换事务日志记录</li>
<li>缩短故障转移时间<ol>
<li>确保工作负载分配了足够的预配置IOPS。 I / O不足可能会延长故障转移时间。 数据库恢复需要I / O</li>
<li>使用较小的交易。 数据库恢复依赖于事务，因此将大型事务分解为多个较小的事务以缩短故障转移时间</li>
</ol>
</li>
<li>测试数据库实例的故障转移，以了解进程对用例的持续时间，并确保访问数据库实例的应用程序可以在故障转移后自动连接到新的数据库实例</li>
</ul>
</li>
</ul>
<h2 id="数据库实例-RAM-建议"><a href="#数据库实例-RAM-建议" class="headerlink" title="数据库实例 RAM 建议"></a>数据库实例 RAM 建议</h2><ul>
<li>RDS 性能最佳实践是分配足够的 RAM，以便工作集几乎完全驻留在内存中</li>
<li>ReadIOPS 的值应是一个较小且稳定的值</li>
<li>要确定工作集是否几乎完全位于内存中，请在数据库实例加载期间检查 ReadIOPS 指标 (使用 Amazon CloudWatch)</li>
<li>如果将数据库实例类向上扩展—到带更多 RAM 的类—则会导致 ReadIOPS 大幅降低，从而使工作集不能几乎完全位于内存中。继续向上扩展直至 ReadIOPS 不再在扩展操作后大幅降低，否则 ReadIOPS 将降低至非常小的数量</li>
</ul>
<h2 id="RDS安全实践"><a href="#RDS安全实践" class="headerlink" title="RDS安全实践"></a>RDS安全实践</h2><ul>
<li>不要使用AWS根凭据来管理Amazon RDS资源; 应该为每个人创建IAM用户</li>
<li>为每个用户授予执行其职责所需的最小权限集</li>
<li>使用IAM组有效管理多个用户的权限</li>
<li>定期轮换IAM凭据</li>
</ul>
<h2 id="使用增强监控操作系统"><a href="#使用增强监控操作系统" class="headerlink" title="使用增强监控操作系统"></a>使用增强监控操作系统</h2><ul>
<li>Amazon RDS为数据库实例运行的操作系统（OS）提供实时指标</li>
</ul>
<h2 id="使用指标确定性能问题"><a href="#使用指标确定性能问题" class="headerlink" title="使用指标确定性能问题"></a>使用指标确定性能问题</h2><ul>
<li>要确定资源不足和其他常见瓶颈导致的性能问题，可以监控可用于 Amazon RDS 数据库实例的指标</li>
<li>应定期监控性能指标以查看各种时间范围内的平均值、最大值和最小值</li>
<li>可以针对特定指标阈值设置 Amazon CloudWatch 警报，以便在达到这些阈值时发出警报</li>
<li>数据库实例具有许多不同类别的度量标准，包括CPU，内存，磁盘空间，IOPS，数据库连接和网络流量，以及如何确定可接受的值取决于度量标准。</li>
<li>提高数据库实例性能的最佳方法之一是调整最常用和最耗费资源的查询，以降低运行成本</li>
</ul>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul>
<li>InnoDB是Amazon RDS上MySQL数据库实例的推荐和支持的存储引擎。</li>
<li>但是，如果需要强大的全文搜索功能，MyISAM的性能优于InnoDB。</li>
<li>Amazon RDS for MySQL的时间点恢复和快照恢复功能需要可崩溃恢复的存储引擎，并且仅支持InnoDB存储引擎。</li>
<li>尽管MySQL支持具有不同功能的多个存储引擎，但并非所有存储引擎都针对崩溃恢复和数据持久性进行了优化</li>
<li>MyISAM存储引擎不支持可靠的崩溃恢复，并且可能会阻止时间点还原或快照还原按预期工作，这可能会导致在崩溃后重新启动MySQL时丢失或损坏数据</li>
</ul>
<h3 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h3><ul>
<li>XtraDB是Amazon RDS上MariaDB数据库实例的推荐和支持的存储引擎</li>
<li>Amazon RDS for MariaDB的时间点恢复和快照恢复功能需要可崩溃恢复的存储引擎，并且仅支持XtraDB存储引擎</li>
<li>尽管 Aria 是 MyISAM 的崩溃安全替代，但它仍可能使时间点还原或快照还原无法按预期工作。这可能导致在崩溃后重新启动 MariaDB 时丢失或损坏数据</li>
</ul>
<h1 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h1><ul>
<li>Amazon Relational Database Service user guide</li>
<li><a href="http://jayendrapatil.com/aws-relational-database-service-rds/" target="_blank" rel="noopener">http://jayendrapatil.com/aws-relational-database-service-rds/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">seven</p>
              <p class="site-description motion-element" itemprop="description">seven 的精神家园，学习笔记</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="1988xuegang@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">seven</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
